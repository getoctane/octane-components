/**
 * This file was auto-generated by openapi-typescript.
 * Do not make direct changes to the file.
 */

export interface paths {
  '/vendors/': {
    /** Fetch vendor data. The vendor used is based on the API Key provided as a part of auth. */
    get: {
      responses: {
        /** OK */
        200: {
          content: {
            'application/json': components['schemas']['Vendor'];
          };
        };
        default: components['responses']['DEFAULT_ERROR'];
      };
    };
    /** Update vendor metadata. */
    put: {
      responses: {
        /** OK */
        200: {
          content: {
            'application/json': components['schemas']['Vendor'];
          };
        };
        422: components['responses']['UNPROCESSABLE_ENTITY'];
        default: components['responses']['DEFAULT_ERROR'];
      };
      requestBody: {
        content: {
          'application/json': components['schemas']['UpdateVendorArgs'];
        };
      };
    };
    /** **[ADMIN ONLY]** Create a new vendor. */
    post: {
      responses: {
        /** OK */
        200: {
          content: {
            'application/json': components['schemas']['Vendor'];
          };
        };
        422: components['responses']['UNPROCESSABLE_ENTITY'];
        default: components['responses']['DEFAULT_ERROR'];
      };
      requestBody: {
        content: {
          'application/json': components['schemas']['CreateVendorArgs'];
        };
      };
    };
    delete: {
      responses: {
        /** No Content */
        204: never;
        default: components['responses']['DEFAULT_ERROR'];
      };
    };
  };
  '/meters/': {
    /** Retrieve all meters for a given vendor. */
    get: {
      responses: {
        /** OK */
        200: {
          content: {
            'application/json': components['schemas']['Meter'][];
          };
        };
        default: components['responses']['DEFAULT_ERROR'];
      };
    };
    /** Create a new Meter. */
    post: {
      responses: {
        /** OK */
        200: {
          content: {
            'application/json': components['schemas']['Meter'];
          };
        };
        422: components['responses']['UNPROCESSABLE_ENTITY'];
        default: components['responses']['DEFAULT_ERROR'];
      };
      requestBody: {
        content: {
          'application/json': components['schemas']['MeterInputArgs'];
        };
      };
    };
  };
  '/meters/{meter_name}': {
    /** Fetch a meter by its unique name */
    get: {
      parameters: {
        path: {
          meter_name: string;
        };
      };
      responses: {
        /** OK */
        200: {
          content: {
            'application/json': components['schemas']['Meter'];
          };
        };
        default: components['responses']['DEFAULT_ERROR'];
      };
    };
    /** Update a meter by its unique name */
    put: {
      parameters: {
        path: {
          meter_name: string;
        };
      };
      responses: {
        /** OK */
        200: {
          content: {
            'application/json': components['schemas']['Meter'];
          };
        };
        422: components['responses']['UNPROCESSABLE_ENTITY'];
        default: components['responses']['DEFAULT_ERROR'];
      };
      requestBody: {
        content: {
          'application/json': components['schemas']['UpdateMeterArgs'];
        };
      };
    };
    /** Delete a meter by its unique name. Meters can only be deleted if not in-use by a price plan. */
    delete: {
      parameters: {
        path: {
          meter_name: string;
        };
      };
      responses: {
        /** No Content */
        204: never;
        default: components['responses']['DEFAULT_ERROR'];
      };
    };
    parameters: {
      path: {
        meter_name: string;
      };
    };
  };
  '/measurements/': {
    post: {
      responses: {
        /** OK */
        200: {
          content: {
            'application/json': components['schemas']['Measurement'];
          };
        };
        422: components['responses']['UNPROCESSABLE_ENTITY'];
        default: components['responses']['DEFAULT_ERROR'];
      };
      requestBody: {
        content: {
          'application/json': components['schemas']['Measurement'];
        };
      };
    };
  };
  '/measurements/multi': {
    post: {
      responses: {
        /** OK */
        200: {
          content: {
            'application/json': components['schemas']['Measurement'][];
          };
        };
        422: components['responses']['UNPROCESSABLE_ENTITY'];
        default: components['responses']['DEFAULT_ERROR'];
      };
      requestBody: {
        content: {
          'application/json': components['schemas']['Measurement'][];
        };
      };
    };
  };
  '/customers/': {
    /** Retrieve all customers for a given vendor. */
    get: {
      responses: {
        /** OK */
        200: {
          content: {
            'application/json': components['schemas']['Customer'][];
          };
        };
        default: components['responses']['DEFAULT_ERROR'];
      };
    };
    /** Create a new customer. */
    post: {
      responses: {
        /** OK */
        200: {
          content: {
            'application/json': components['schemas']['Customer'];
          };
        };
        422: components['responses']['UNPROCESSABLE_ENTITY'];
        default: components['responses']['DEFAULT_ERROR'];
      };
      requestBody: {
        content: {
          'application/json': components['schemas']['CreateCustomerArgs'];
        };
      };
    };
  };
  '/customers/{customer_name}': {
    /** Fetch a customer by their unique name. */
    get: {
      parameters: {
        path: {
          customer_name: string;
        };
      };
      responses: {
        /** OK */
        200: {
          content: {
            'application/json': components['schemas']['Customer'];
          };
        };
        default: components['responses']['DEFAULT_ERROR'];
      };
    };
    /** Update a single customer. To update Customer measurement mappings, use the `customers/{customer_name}/mappings` endpoint. */
    put: {
      parameters: {
        path: {
          customer_name: string;
        };
      };
      responses: {
        /** OK */
        200: {
          content: {
            'application/json': components['schemas']['Customer'];
          };
        };
        422: components['responses']['UNPROCESSABLE_ENTITY'];
        default: components['responses']['DEFAULT_ERROR'];
      };
      requestBody: {
        content: {
          'application/json': components['schemas']['UpdateCustomerArgs'];
        };
      };
    };
    /** Delete a customer by their unique name. */
    delete: {
      parameters: {
        path: {
          customer_name: string;
        };
      };
      responses: {
        /** No Content */
        204: never;
        default: components['responses']['DEFAULT_ERROR'];
      };
    };
    parameters: {
      path: {
        customer_name: string;
      };
    };
  };
  '/customers/{customer_name}/mappings': {
    /** Fetch all measurement mappings for a specific customer (by unique customer name). */
    get: {
      parameters: {
        path: {
          customer_name: string;
        };
      };
      responses: {
        /** OK */
        200: {
          content: {
            'application/json': components['schemas']['CustomerMeasurementMapping'][];
          };
        };
        default: components['responses']['DEFAULT_ERROR'];
      };
    };
    /** Create a new measurement mapping for a customer. If no value_regex is passed, label existence is checked instead. */
    post: {
      parameters: {
        path: {
          customer_name: string;
        };
      };
      responses: {
        /** OK */
        200: {
          content: {
            'application/json': components['schemas']['CustomerMeasurementMapping'];
          };
        };
        422: components['responses']['UNPROCESSABLE_ENTITY'];
        default: components['responses']['DEFAULT_ERROR'];
      };
      requestBody: {
        content: {
          'application/json': components['schemas']['CustomerMeasurementMappingInputArgs'];
        };
      };
    };
    parameters: {
      path: {
        customer_name: string;
      };
    };
  };
  '/customers/{customer_name}/payment_method_status': {
    get: {
      parameters: {
        path: {
          customer_name: string;
        };
      };
      responses: {
        /** OK */
        200: {
          content: {
            'application/json': components['schemas']['CustomerPaymentMethodStatus'];
          };
        };
        default: components['responses']['DEFAULT_ERROR'];
      };
    };
    parameters: {
      path: {
        customer_name: string;
      };
    };
  };
  '/customers/{customer_name}/payment_gateway_credentials': {
    get: {
      parameters: {
        path: {
          customer_name: string;
        };
      };
      responses: {
        /** OK */
        200: {
          content: {
            'application/json': components['schemas']['PaymentGatewayCredential'];
          };
        };
        default: components['responses']['DEFAULT_ERROR'];
      };
    };
    post: {
      parameters: {
        path: {
          customer_name: string;
        };
      };
      responses: {
        /** OK */
        200: {
          content: {
            'application/json': components['schemas']['PaymentGatewayCredential'];
          };
        };
        422: components['responses']['UNPROCESSABLE_ENTITY'];
        default: components['responses']['DEFAULT_ERROR'];
      };
      requestBody: {
        content: {
          'application/json': components['schemas']['CustomerPaymentGatewayCredentialInputArgs'];
        };
      };
    };
    parameters: {
      path: {
        customer_name: string;
      };
    };
  };
  '/customers/{customer_name}/billing_settings': {
    /** Fetch the billing settings for a customer. */
    get: {
      parameters: {
        path: {
          customer_name: string;
        };
      };
      responses: {
        /** OK */
        200: {
          content: {
            'application/json': components['schemas']['BillingSettings'];
          };
        };
        default: components['responses']['DEFAULT_ERROR'];
      };
    };
    /** Update billing settings for a customer. */
    put: {
      parameters: {
        path: {
          customer_name: string;
        };
      };
      responses: {
        /** OK */
        200: {
          content: {
            'application/json': components['schemas']['BillingSettings'];
          };
        };
        422: components['responses']['UNPROCESSABLE_ENTITY'];
        default: components['responses']['DEFAULT_ERROR'];
      };
      requestBody: {
        content: {
          'application/json': components['schemas']['UpdateBillingSettingsInputArgs'];
        };
      };
    };
    /** Create billing settings for a vendor. */
    post: {
      parameters: {
        path: {
          customer_name: string;
        };
      };
      responses: {
        /** OK */
        200: {
          content: {
            'application/json': components['schemas']['BillingSettings'];
          };
        };
        422: components['responses']['UNPROCESSABLE_ENTITY'];
        default: components['responses']['DEFAULT_ERROR'];
      };
      requestBody: {
        content: {
          'application/json': components['schemas']['CreateBillingSettingsInputArgs'];
        };
      };
    };
    /** Delete billing settings for a customer. */
    delete: {
      parameters: {
        path: {
          customer_name: string;
        };
      };
      responses: {
        /** No Content */
        204: never;
        default: components['responses']['DEFAULT_ERROR'];
      };
    };
    parameters: {
      path: {
        customer_name: string;
      };
    };
  };
  '/customers/{customer_name}/revenue': {
    /** Fetch revenue of a customer from start_time and end_time. */
    get: {
      parameters: {
        path: {
          customer_name: string;
        };
        query: {
          end_time?: string;
          start_time?: string;
        };
      };
      responses: {
        /** OK */
        200: {
          content: {
            'application/json': components['schemas']['RevenueResponse'];
          };
        };
        422: components['responses']['UNPROCESSABLE_ENTITY'];
        default: components['responses']['DEFAULT_ERROR'];
      };
    };
    parameters: {
      path: {
        customer_name: string;
      };
    };
  };
  '/customers/{customer_name}/invoice/{invoice_id}/{token}': {
    /** Fetch current cycle revenue for a customer and generate an invoice. */
    get: {
      parameters: {
        path: {
          customer_name: string;
          token: string;
          invoice_id: number;
        };
      };
      responses: {
        default: components['responses']['DEFAULT_ERROR'];
      };
    };
    parameters: {
      path: {
        customer_name: string;
        token: string;
        invoice_id: number;
      };
    };
  };
  '/customers/{customer_name}/sample_invoice/{token}': {
    /** Fetch current cycle revenue for a customer and generate an invoice. */
    get: {
      parameters: {
        path: {
          customer_name: string;
          token: string;
        };
      };
      responses: {
        default: components['responses']['DEFAULT_ERROR'];
      };
    };
    parameters: {
      path: {
        customer_name: string;
        token: string;
      };
    };
  };
  '/customers/{customer_name}/status': {
    get: {
      parameters: {
        path: {
          customer_name: string;
        };
      };
      responses: {
        /** OK */
        200: {
          content: {
            'application/json': components['schemas']['CustomerStatus'];
          };
        };
        default: components['responses']['DEFAULT_ERROR'];
      };
    };
    parameters: {
      path: {
        customer_name: string;
      };
    };
  };
  '/customers/{customer_name}/usage': {
    get: {
      parameters: {
        path: {
          customer_name: string;
        };
        query: {
          /** Ending timestamp to consider usage formatted as ISO-8601. */
          end_time?: string;
          meter_name?: string;
          /** Starting timestamp to consider usage formatted as ISO-8601. */
          start_time?: string;
        };
      };
      responses: {
        /** OK */
        200: {
          content: {
            'application/json': components['schemas']['CustomerUsage'];
          };
        };
        422: components['responses']['UNPROCESSABLE_ENTITY'];
        default: components['responses']['DEFAULT_ERROR'];
      };
    };
    parameters: {
      path: {
        customer_name: string;
      };
    };
  };
  '/customers/{customer_name}/features/{feature_name}': {
    get: {
      parameters: {
        path: {
          customer_name: string;
          feature_name: string;
        };
      };
      responses: {
        /** OK */
        200: {
          content: {
            'application/json': components['schemas']['CustomerFeature'];
          };
        };
        default: components['responses']['DEFAULT_ERROR'];
      };
    };
    parameters: {
      path: {
        customer_name: string;
        feature_name: string;
      };
    };
  };
  '/customers/{customer_name}/accrued_revenue': {
    get: {
      parameters: {
        path: {
          customer_name: string;
        };
      };
      responses: {
        /** OK */
        200: {
          content: {
            'application/json': components['schemas']['RevenueBreakdown'];
          };
        };
        default: components['responses']['DEFAULT_ERROR'];
      };
    };
    parameters: {
      path: {
        customer_name: string;
      };
    };
  };
  '/customers/{customer_name}/invoices': {
    get: {
      parameters: {
        path: {
          customer_name: string;
        };
        query: {
          /** The number of items to fetch. Defaults to 10. */
          limit?: number;
          start_time?: string;
        };
      };
      responses: {
        /** OK */
        200: {
          content: {
            'application/json': components['schemas']['Invoice'][];
          };
        };
        422: components['responses']['UNPROCESSABLE_ENTITY'];
        default: components['responses']['DEFAULT_ERROR'];
      };
    };
    parameters: {
      path: {
        customer_name: string;
      };
    };
  };
  '/customers/{customer_name}/subscriptions': {
    /** Get all subscriptions for the customer. */
    get: {
      parameters: {
        path: {
          customer_name: string;
        };
      };
      responses: {
        /** OK */
        200: {
          content: {
            'application/json': components['schemas']['Subscription'][];
          };
        };
        default: components['responses']['DEFAULT_ERROR'];
      };
    };
    /** Create a new subscription for a customer / price plan combination (by unique name). */
    post: {
      parameters: {
        path: {
          customer_name: string;
        };
      };
      responses: {
        /** OK */
        200: {
          content: {
            'application/json': components['schemas']['Subscription'];
          };
        };
        422: components['responses']['UNPROCESSABLE_ENTITY'];
        default: components['responses']['DEFAULT_ERROR'];
      };
      requestBody: {
        content: {
          'application/json': components['schemas']['CreateSubscriptionArgs'];
        };
      };
    };
    parameters: {
      path: {
        customer_name: string;
      };
    };
  };
  '/customers/{customer_name}/subscription': {
    /** Update a subscription for a specific customer (by customer name). */
    put: {
      parameters: {
        path: {
          customer_name: string;
        };
      };
      responses: {
        /** OK */
        200: {
          content: {
            'application/json': components['schemas']['Subscription'];
          };
        };
        422: components['responses']['UNPROCESSABLE_ENTITY'];
        default: components['responses']['DEFAULT_ERROR'];
      };
      requestBody: {
        content: {
          'application/json': components['schemas']['UpdateSubscriptionArgs'];
        };
      };
    };
    /** Delete a subscription for a specific customer (by customer name). */
    delete: {
      parameters: {
        path: {
          customer_name: string;
        };
      };
      responses: {
        /** No Content */
        204: never;
        422: components['responses']['UNPROCESSABLE_ENTITY'];
        default: components['responses']['DEFAULT_ERROR'];
      };
      requestBody: {
        content: {
          'application/json': components['schemas']['DeleteSubscriptionArgs'];
        };
      };
    };
    parameters: {
      path: {
        customer_name: string;
      };
    };
  };
  '/customers/{customer_name}/active_subscription': {
    get: {
      parameters: {
        path: {
          customer_name: string;
        };
      };
      responses: {
        /** OK */
        200: {
          content: {
            'application/json': components['schemas']['ActiveSubscription'];
          };
        };
        default: components['responses']['DEFAULT_ERROR'];
      };
    };
    parameters: {
      path: {
        customer_name: string;
      };
    };
  };
  '/customers/{customer_name}/scheduled_subscriptions': {
    get: {
      parameters: {
        path: {
          customer_name: string;
        };
      };
      responses: {
        /** OK */
        200: {
          content: {
            'application/json': components['schemas']['Subscription'][];
          };
        };
        default: components['responses']['DEFAULT_ERROR'];
      };
    };
    parameters: {
      path: {
        customer_name: string;
      };
    };
  };
  '/price_plans/': {
    /** Fetch all price plans associated with a vendor. */
    get: {
      responses: {
        /** OK */
        200: {
          content: {
            'application/json': components['schemas']['PricePlan'][];
          };
        };
        default: components['responses']['DEFAULT_ERROR'];
      };
    };
    post: {
      responses: {
        /** OK */
        200: {
          content: {
            'application/json': components['schemas']['PricePlan'];
          };
        };
        422: components['responses']['UNPROCESSABLE_ENTITY'];
        default: components['responses']['DEFAULT_ERROR'];
      };
      requestBody: {
        content: {
          'application/json': components['schemas']['CreatePricePlanArgs'];
        };
      };
    };
  };
  '/price_plans/{price_plan_name}': {
    /** Fetch an existing price plan. */
    get: {
      parameters: {
        path: {
          price_plan_name: string;
        };
      };
      responses: {
        /** OK */
        200: {
          content: {
            'application/json': components['schemas']['PricePlan'];
          };
        };
        default: components['responses']['DEFAULT_ERROR'];
      };
    };
    /** Update an existing price plan. */
    put: {
      parameters: {
        path: {
          price_plan_name: string;
        };
      };
      responses: {
        /** OK */
        200: {
          content: {
            'application/json': components['schemas']['PricePlan'];
          };
        };
        422: components['responses']['UNPROCESSABLE_ENTITY'];
        default: components['responses']['DEFAULT_ERROR'];
      };
      requestBody: {
        content: {
          'application/json': components['schemas']['UpdatePricePlanArgs'];
        };
      };
    };
    /** Delete an existing Price Plan. Plans which map to active Subscriptions must be replaced or removed before deletion can occur. */
    delete: {
      parameters: {
        path: {
          price_plan_name: string;
        };
      };
      responses: {
        /** No Content */
        204: never;
        default: components['responses']['DEFAULT_ERROR'];
      };
    };
    parameters: {
      path: {
        price_plan_name: string;
      };
    };
  };
  '/payment_gateway_credentials/': {
    get: {
      responses: {
        /** OK */
        200: {
          content: {
            'application/json': components['schemas']['PaymentGatewayCredential'];
          };
        };
        default: components['responses']['DEFAULT_ERROR'];
      };
    };
    post: {
      responses: {
        /** OK */
        200: {
          content: {
            'application/json': components['schemas']['PaymentGatewayCredential'];
          };
        };
        422: components['responses']['UNPROCESSABLE_ENTITY'];
        default: components['responses']['DEFAULT_ERROR'];
      };
      requestBody: {
        content: {
          'application/json': components['schemas']['PaymentGatewayCredentialInputArgs'];
        };
      };
    };
  };
  '/billing_settings/': {
    /** Fetch the billing settings for a vendor. */
    get: {
      responses: {
        /** OK */
        200: {
          content: {
            'application/json': components['schemas']['BillingSettings'];
          };
        };
        default: components['responses']['DEFAULT_ERROR'];
      };
    };
    /** Update billing settings for a vendor. */
    put: {
      responses: {
        /** OK */
        200: {
          content: {
            'application/json': components['schemas']['BillingSettings'];
          };
        };
        422: components['responses']['UNPROCESSABLE_ENTITY'];
        default: components['responses']['DEFAULT_ERROR'];
      };
      requestBody: {
        content: {
          'application/json': components['schemas']['UpdateBillingSettingsInputArgs'];
        };
      };
    };
    /** Create billing settings for a vendor. */
    post: {
      responses: {
        /** OK */
        200: {
          content: {
            'application/json': components['schemas']['BillingSettings'];
          };
        };
        422: components['responses']['UNPROCESSABLE_ENTITY'];
        default: components['responses']['DEFAULT_ERROR'];
      };
      requestBody: {
        content: {
          'application/json': components['schemas']['CreateBillingSettingsInputArgs'];
        };
      };
    };
    /** Delete billing settings for a vendor. */
    delete: {
      responses: {
        /** No Content */
        204: never;
        default: components['responses']['DEFAULT_ERROR'];
      };
    };
  };
  '/coupons/': {
    /** Gets all the coupons for a vendor. */
    get: {
      responses: {
        /** OK */
        200: {
          content: {
            'application/json': components['schemas']['Coupon1'][];
          };
        };
        default: components['responses']['DEFAULT_ERROR'];
      };
    };
    /** Create a new coupon. */
    post: {
      responses: {
        /** OK */
        200: {
          content: {
            'application/json': components['schemas']['Coupon1'];
          };
        };
        422: components['responses']['UNPROCESSABLE_ENTITY'];
        default: components['responses']['DEFAULT_ERROR'];
      };
      requestBody: {
        content: {
          'application/json': components['schemas']['CouponInputArgs'];
        };
      };
    };
  };
  '/coupons/{coupon_name}': {
    /** Fetch a Coupon by its unique name. */
    get: {
      parameters: {
        path: {
          coupon_name: string;
        };
      };
      responses: {
        /** OK */
        200: {
          content: {
            'application/json': components['schemas']['Coupon1'];
          };
        };
        default: components['responses']['DEFAULT_ERROR'];
      };
    };
    /** Delete a coupon by its unique name. */
    delete: {
      parameters: {
        path: {
          coupon_name: string;
        };
      };
      responses: {
        /** No Content */
        204: never;
        default: components['responses']['DEFAULT_ERROR'];
      };
    };
    parameters: {
      path: {
        coupon_name: string;
      };
    };
  };
  '/coupons/apply_coupon': {
    post: {
      responses: {
        /** OK */
        200: unknown;
        422: components['responses']['UNPROCESSABLE_ENTITY'];
        default: components['responses']['DEFAULT_ERROR'];
      };
      requestBody: {
        content: {
          'application/json': components['schemas']['ApplyCouponInputArgs'];
        };
      };
    };
  };
}

export interface components {
  schemas: {
    ContactInfo: {
      address_line_1?: string | null;
      address_line_2?: string | null;
      city?: string | null;
      state?: string | null;
      country?: string | null;
      zipcode?: string | null;
      url?: string | null;
      logo_url?: string | null;
      email?: string | null;
      phone?: string | null;
    };
    Vendor: {
      /** Unique name identifier of a Vendor */
      name: string;
      display_name?: string;
      api_key?: string;
      contact_info?: components['schemas']['ContactInfo'] | null;
    };
    ContactInfoInputArgs: {
      zipcode?: string;
      url?: string;
      address_line_1?: string;
      email?: string;
      logo_url?: string;
      city?: string;
      state?: string;
      phone?: string;
      address_line_2?: string;
      country?: string;
    };
    CreateVendorArgs: {
      contact_info?: components['schemas']['ContactInfoInputArgs'];
      name?: string;
      display_name?: string;
      api_key?: string;
      vendor_display_name?: string;
      vendor_name?: string;
    };
    UpdateVendorArgs: {
      display_name?: string;
      contact_info?: components['schemas']['ContactInfoInputArgs'];
      vendor_id?: number;
    };
    Error: {
      /** Error message */
      message?: string;
      /** Error name */
      status?: string;
      /** Error code */
      code?: number;
      /** Errors */
      errors?: { [key: string]: unknown };
    };
    Meter: {
      /** Unique name identifier */
      name: string;
      /** Name used for display in UI */
      display_name?: string;
      description?: string | null;
      /** Whether measurement values are to be considered incremental (versus a running total) */
      is_incremental?: boolean;
      meter_type?: unknown;
      /** The expected unit for the measurement values associated with this meter. */
      unit_name?: unknown;
      expected_labels?: unknown[];
      primary_labels?: unknown[];
    };
    MeterInputArgs: {
      name?: string;
      meter_type?: string;
      vendor_id?: number;
      unit_name?: string;
      display_name?: string;
      description?: string;
      is_incremental?: boolean;
      expected_labels?: string[];
      primary_labels?: string[];
    };
    UpdateMeterArgs: {
      name?: string;
      meter_type?: string;
      vendor_id?: number;
      unit_name?: string;
      display_name?: string;
      description?: string;
      is_incremental?: boolean;
      expected_labels?: string[];
      primary_labels?: string[];
    };
    Measurement: {
      /** All times are parsed as `ISO-8601` formatted, UTC-based timestamps */
      time?: string;
      /** Applies to incremental meters and resets the total current value to this new value. */
      reset_total?: boolean;
      /** The unique name of the meter associated with this measurement */
      meter_name: string;
      /** A set of key:value label pairs to supplement a measurement. Each meter defines its own set of primary and/or expected labels. */
      labels?: { [key: string]: string };
      /** The raw value of the measurement */
      value: number;
    };
    Customer: {
      /** Unique name identifier of a customer */
      name: string;
      display_name?: string;
      contact_info?: components['schemas']['ContactInfo'] | null;
      measurement_mappings?: unknown[];
    };
    CustomerMeasurementMappingInputArgs: {
      value_regex?: string;
      label?: string;
    };
    CreateCustomerArgs: {
      contact_info?: components['schemas']['ContactInfoInputArgs'];
      tags?: string[];
      name?: string;
      vendor_id?: number;
      display_name?: string;
      measurement_mappings?: components['schemas']['CustomerMeasurementMappingInputArgs'][];
      price_plan_tag?: string;
      autogenerate_payment_gateway_customer?: boolean;
      price_plan_name?: string;
    };
    UpdateCustomerArgs: {
      contact_info?: components['schemas']['ContactInfoInputArgs'];
      tags?: string[];
      name?: string;
      vendor_id?: number;
      display_name?: string;
      measurement_mappings?: components['schemas']['CustomerMeasurementMappingInputArgs'][];
    };
    CustomerMeasurementMapping: {
      /** The label key used to map measurements to customers. */
      label: string;
      /** A regex used to match the value of the associated label key. */
      value_regex?: string | null;
    };
    CustomerPaymentMethodStatus: {
      status?: string;
    };
    PaymentGatewayCredential: {
      payment_gateway?: unknown;
      /** Payment gateway account id associated with customer */
      account_id: string;
      /** Unique name identifier of a customer */
      auth_token?: string | null;
    };
    CustomerPaymentGatewayCredentialInputArgs: {
      account_id?: string;
    };
    BillingSettings: {
      /** Time length of the grace period between the end of a billing cycle and invoice generation. *NOTE*: The specified length is unitless. Unit is designated with the `invoice_grace_period_unit` field. */
      invoice_grace_period_length?: number | null;
      /** Time length unit of the grace period between the end of a billing cycle and invoice generation. One of `minute`, `hour`, `day`. */
      invoice_grace_period_unit?: string | null;
      /** Time length of the grace period between the end of invoice generation and the actual charge. *NOTE*: The specified length is unitless. Unit is designated with the `payment_grace_period_unit` field. */
      payment_grace_period_length?: number | null;
      /** Time length unit of the grace period between the end of invoice generation and actual charge. One of `minute`, `hour`, `day`. */
      payment_grace_period_unit?: string | null;
      /** Flag that controls whether or not invoices should be sent to customers. */
      should_send_invoice_to_customers?: boolean | null;
      /** Flag that controls whether to invoice through Octane or through payment provider */
      invoice_via_octane?: boolean | null;
      /** Flag that controls whether invoices are auto-approved or require manual approval */
      auto_approve_invoices?: boolean | null;
      customer_invoice_detail_level?: unknown;
      /** Flag that controls whether or not to auto-charge the customer based on the invoice. */
      charges_enabled?: boolean | null;
      /** Flag that controls whether or not to invoice/charge the base rate, add ons and other fixed price plan components at the beginning of the billing cycle. */
      invoice_fixed_components_at_start?: boolean | null;
      /** Flag that controls the number of retry attempts for invoicing/payments. */
      retry_attempts?: number | null;
      /** Time length after which to attempt invoice/payment retry. */
      retry_frequency_length?: number | null;
      /** Time length unit after which to attempt invoice/payment retry. */
      retry_frequency_unit?: string | null;
      /** The percentage tax rate to apply to invoices. */
      tax_rate?: number | null;
    };
    CreateBillingSettingsInputArgs: {
      customer_invoice_detail_level?: string;
      vendor_id?: number;
      payment_grace_period_length?: number;
      charges_enabled?: boolean;
      retry_attempts?: number;
      invoice_grace_period_unit?: string;
      invoice_grace_period_length?: number;
      auto_approve_invoices?: boolean;
      should_send_invoice_to_customers?: boolean;
      tax_rate?: number | null;
      retry_frequency_unit?: string;
      customer_id?: number;
      retry_frequency_length?: number;
      invoice_fixed_components_at_start?: boolean;
      invoice_via_octane?: boolean;
      payment_grace_period_unit?: string;
    };
    UpdateBillingSettingsInputArgs: {
      customer_invoice_detail_level?: string;
      vendor_id?: number;
      payment_grace_period_length?: number;
      charges_enabled?: boolean;
      retry_attempts?: number;
      invoice_grace_period_unit?: string;
      invoice_grace_period_length?: number;
      auto_approve_invoices?: boolean;
      should_send_invoice_to_customers?: boolean;
      tax_rate?: number | null;
      retry_frequency_unit?: string;
      customer_id?: number;
      retry_frequency_length?: number;
      invoice_fixed_components_at_start?: boolean;
      invoice_via_octane?: boolean;
      payment_grace_period_unit?: string;
    };
    RevenueResponse: {
      revenue?: number;
    };
    CustomerStatus: {
      status?: string;
    };
    CustomerUsage: {
      usage?: number;
    };
    CustomerFeature: {
      limit?: number;
      enabled?: boolean;
      feature_name?: string;
    };
    LineItems: {
      price_int?: number;
      name?: string;
      description?: string;
      price?: string;
      id?: string;
      quantity?: number;
      quantity_unit?: string;
      metadata?: { [key: string]: string };
    };
    RevenueBreakdown: {
      line_items?: components['schemas']['LineItems'][];
      total_revenue?: number;
    };
    Invoice: {
      /** Any discount credits applied to the invoice */
      discount_credit?: number;
      /** Amount due before any credits are applied */
      sub_total?: number;
      /** False if invoice has not been sent to the customer */
      is_invoiced?: boolean;
      latest_invoice_attempt_at?: string;
      /** False if not approved */
      is_approved?: boolean;
      latest_payment_attempt_at?: string;
      start_time?: string;
      id?: string;
      /** Non-empty string if there was an error while processing payment */
      payment_error?: string;
      /** Non-empty string if there was an error while sending out invoice */
      invoicing_error?: string;
      due_date?: string;
      end_time?: string;
      line_items?: components['schemas']['LineItems'][];
      /** False if not paid yet */
      is_paid?: boolean;
      /** The number of retries done to process the payment */
      payment_retry_attempt?: number;
      /** The number of retries done to send the invoice */
      invoice_retry_attempt?: number;
      /** Total amount due */
      amount_due?: number;
    };
    Coupon: {
      /** Unique name identifier. */
      name: string;
    };
    PriceTier: {
      /** The price (in lowest currency denomination by which to charge, given that the usage is within the cap range. */
      price: number;
      /** Cap of the tier, meaning that any subsequent usage will be bucketed into the following tier. If cap is undefined, it is effectively treated as Infinity. */
      cap?: number;
    };
    PriceScheme: {
      display_name?: string | null;
      name?: string | null;
      scheme_type?: unknown;
      /** Array of price tiers, each of which consists of `price` and `cap` key:value pairs */
      prices?: components['schemas']['PriceTier'][];
      time_unit_name?: string | null;
      unit_name?: string | null;
    };
    MeteredComponent: {
      /** Unique name identifier */
      meter_name?: unknown;
      price_scheme?: components['schemas']['PriceScheme'];
      /** Limit to set on the metered component. */
      limit?: number | null;
    };
    Discount: {
      discount_type?: unknown;
      amount?: number | null;
      /** The date when the discount is applied from. */
      start_date?: string | null;
      /** The date when the discount ends. */
      end_date?: string | null;
      /** The id of coupon associated with this discount, none if discount does not originate from coupon */
      coupon_id?: number | null;
    };
    Feature: {
      description?: string | null;
      /** Unique name of a feature */
      name: string;
      display_name?: string;
    };
    Limit: {
      feature?: components['schemas']['Feature'];
      /** Limit on feature */
      limit: number;
    };
    PricePlanTag: {
      /** Supplementary tag label that is associated with a specific version of a price plan */
      tag: string;
    };
    Trial: {
      time_length?: number | null;
      time_unit_name?: string | null;
      credit?: number | null;
    };
    PricePlan: {
      /** Unique name indentifier of a price plan */
      name: string;
      /** UI-friendly name used for data display. Defaults to `name`. */
      display_name?: string;
      description?: string | null;
      /** Lowest denomination of currency. e.g. USD is represented as cents. */
      base_price?: number | null;
      /** Time period that defines the length of a price plan cycle. One of `day`, `week`, `month`, `quarter`, or `year`. */
      period: string;
      coupon?: components['schemas']['Coupon'];
      metered_components?: components['schemas']['MeteredComponent'][];
      discount?: components['schemas']['Discount'];
      features?: components['schemas']['Feature'][];
      limits?: components['schemas']['Limit'][];
      tags?: components['schemas']['PricePlanTag'][];
      trial?: components['schemas']['Trial'];
    };
    Subscription: {
      /** Unique name identifier of a customer */
      customer_name: unknown;
      /** Unique name indentifier of a price plan */
      price_plan_name: unknown;
      /** Price plan associated with this subscription. */
      price_plan?: components['schemas']['PricePlan'];
      /** Optional discount override for the associated subscription. */
      discount_override?: components['schemas']['Discount'];
      /** Optional trial override for the associated subscription. */
      trial_override?: components['schemas']['Trial'];
      /** Optional base price override for the associated subscription. */
      base_price_override?: number | null;
      /** ISO-8601 formatted timestamp that defines when the subscription should take effect. If this field is omitted, the subscription is effective upon creation. */
      effective_at?: string;
    };
    DiscountInputArgs: {
      discount_type?: string;
      amount?: number;
    };
    CreateSubscriptionArgs: {
      discount_override?: components['schemas']['DiscountInputArgs'];
      coupon_override_id?: number;
      vendor_id?: number;
      effective_at?: string;
      coupon_override_name?: string;
      price_plan_tag?: string;
      price_plan_id?: number;
      customer_id?: number;
      price_plan_name?: string;
    };
    UpdateSubscriptionArgs: {
      discount_override?: components['schemas']['DiscountInputArgs'];
      coupon_override_id?: number;
      vendor_id?: number;
      effective_at?: string;
      coupon_override_name?: string;
      price_plan_tag?: string;
      price_plan_id?: number;
      customer_id?: number;
      price_plan_name?: string;
    };
    DeleteSubscriptionArgs: {
      expire_at?: string;
      customer_id?: number;
      vendor_id?: number;
    };
    BillingCycleDate: {
      cycle_start?: string;
      cycle_end?: string;
    };
    ActiveSubscription: {
      /** Unique name identifier of a customer */
      customer_name: unknown;
      /** Unique name indentifier of a price plan */
      price_plan_name: unknown;
      /** Price plan associated with this subscription. */
      price_plan?: components['schemas']['PricePlan'];
      /** Optional discount override for the associated subscription. */
      discount_override?: components['schemas']['Discount'];
      /** Optional trial override for the associated subscription. */
      trial_override?: components['schemas']['Trial'];
      /** ISO-8601 formatted timestamp that defines when the subscription should take effect. If this field is omitted, the subscription is effective upon creation. */
      effective_at?: string;
      /** Optional base price override for the associated subscription. */
      base_price_override?: number | null;
      current_billing_cycle?: components['schemas']['BillingCycleDate'];
    };
    FeatureInputArgs: {
      display_name?: string;
      description?: string;
      name?: string;
    };
    TrialInputArgs: {
      credit?: number;
      time_unit_name?: string;
      time_length?: number;
    };
    PriceInputArgs: {
      price?: number;
      cap?: number;
    };
    PriceSchemeInputArgs: {
      scheme_type?: string;
      time_unit_name?: string;
      prices?: components['schemas']['PriceInputArgs'][];
      unit_name?: string;
    };
    MeteredComponentInputArgs: {
      id?: number;
      meter_id?: number;
      limit?: number;
      price_scheme?: components['schemas']['PriceSchemeInputArgs'];
      meter_name?: string;
    };
    AddOnInputArgs: {
      price?: number;
      feature?: components['schemas']['FeatureInputArgs'];
    };
    LimitInputArgs: {
      limit?: number;
      feature?: components['schemas']['FeatureInputArgs'];
    };
    CreatePricePlanArgs: {
      tags?: string[];
      period?: string;
      name?: string;
      vendor_id?: number;
      display_name?: string;
      description?: string;
      base_price?: number;
      features?: components['schemas']['FeatureInputArgs'][];
      trial?: components['schemas']['TrialInputArgs'];
      metered_components?: components['schemas']['MeteredComponentInputArgs'][];
      add_ons?: components['schemas']['AddOnInputArgs'][];
      discount?: components['schemas']['DiscountInputArgs'];
      limits?: components['schemas']['LimitInputArgs'][];
      coupon_name?: string;
    };
    UpdatePricePlanArgs: {
      tags?: string[];
      period?: string;
      name?: string;
      vendor_id?: number;
      display_name?: string;
      description?: string;
      base_price?: number;
      features?: components['schemas']['FeatureInputArgs'][];
      trial?: components['schemas']['TrialInputArgs'];
      metered_components?: components['schemas']['MeteredComponentInputArgs'][];
      add_ons?: components['schemas']['AddOnInputArgs'][];
      discount?: components['schemas']['DiscountInputArgs'];
      limits?: components['schemas']['LimitInputArgs'][];
      coupon_name?: string;
    };
    PaymentGatewayCredentialInputArgs: {
      payment_gateway?: string;
      account_id?: string;
      auth_token?: string;
    };
    Customer1: {
      /** Unique name identifier of a customer */
      name: string;
    };
    PricePlan1: {
      /** Unique name indentifier of a price plan */
      name: string;
    };
    Coupon1: {
      /** Unique name identifier. */
      name: string;
      /** UI-friendly name used for data display. Defaults to `name`. */
      display_name?: string;
      /** The time when the coupon will stop being effective one its applied. */
      duration_length?: number | null;
      /** The unit time unit to apply to the specified duration length. */
      duration_unit?: string | null;
      /** ISO-8601 formatted timestamp that defines after what timestamp this coupon cannot be applied. */
      expiration_time?: string | null;
      /** One of RECURRRING or ONCE. */
      frequency?: ('ONCE' | 'RECURRING') | null;
      /** The maximum number of times this coupon can be used. */
      max_uses?: number | null;
      /** Customer facing code that can be used to apply coupon. */
      code?: string | null;
      /** True if prorate at application date, false otherwise */
      is_start_prorated?: boolean | null;
      /** True if prorate at end of duration, false otherwise */
      is_end_prorated?: boolean | null;
      /** One of FLAT or PERCENT. */
      discount_type: 'FLAT' | 'PERCENT';
      /** The amount of discount to give based on discount_type */
      discount_amount: number;
      excluded_customers?: components['schemas']['Customer1'][];
      excluded_price_plans?: components['schemas']['PricePlan1'][];
    };
    CouponInputArgs: {
      frequency: string;
      discount_type: string;
      name: string;
      discount_amount: number;
      vendor_id?: number;
      max_uses?: number;
      display_name?: string;
      is_end_prorated?: boolean;
      excluded_customers?: string[];
      code?: string;
      expiration_time?: string;
      duration_length?: number;
      excluded_price_plans?: string[];
      is_start_prorated?: boolean;
      duration_unit?: string;
    };
    ApplyCouponInputArgs: {
      name?: string;
      vendor_id?: number;
      customer_id?: number;
      code?: string;
      customer_name?: string;
    };
  };
  responses: {
    /** Default error response */
    DEFAULT_ERROR: {
      content: {
        'application/json': components['schemas']['Error'];
      };
    };
    /** Unprocessable Entity */
    UNPROCESSABLE_ENTITY: {
      content: {
        'application/json': components['schemas']['Error'];
      };
    };
  };
}

export interface operations {}

export interface external {}
