/**
 * This file was auto-generated by openapi-typescript.
 * Do not make direct changes to the file.
 */

export interface paths {
  '/live_measurements/': {
    /** Get a list of most recent measurements (maximum of 5000) for a vendor. Optionally filter by customer name. */
    get: {
      responses: {
        /** OK */
        200: unknown;
        default: components['responses']['DEFAULT_ERROR'];
      };
    };
  };
  '/meters/': {
    /** Get all meters for a given vendor. */
    get: {
      responses: {
        /** OK */
        200: {
          content: {
            'application/json': components['schemas']['Meter'][];
          };
        };
        default: components['responses']['DEFAULT_ERROR'];
      };
    };
    /** Create a new meter for a given vendor. */
    post: {
      responses: {
        /** OK */
        200: {
          content: {
            'application/json': components['schemas']['Meter'];
          };
        };
        422: components['responses']['UNPROCESSABLE_ENTITY'];
        default: components['responses']['DEFAULT_ERROR'];
      };
      requestBody: {
        content: {
          'application/json': components['schemas']['CreateMeterArgs'];
        };
      };
    };
  };
  '/meters/{meter_name}': {
    /** Get a meter by its unique name. */
    get: {
      parameters: {
        path: {
          meter_name: string;
        };
      };
      responses: {
        /** OK */
        200: {
          content: {
            'application/json': components['schemas']['Meter'];
          };
        };
        default: components['responses']['DEFAULT_ERROR'];
      };
    };
    /** Update a meter by its unique name. */
    put: {
      parameters: {
        path: {
          meter_name: string;
        };
      };
      responses: {
        /** OK */
        200: {
          content: {
            'application/json': components['schemas']['Meter'];
          };
        };
        422: components['responses']['UNPROCESSABLE_ENTITY'];
        default: components['responses']['DEFAULT_ERROR'];
      };
      requestBody: {
        content: {
          'application/json': components['schemas']['UpdateMeterArgs'];
        };
      };
    };
    /** Delete a meter by its unique name. Meters can only be deleted if not in-use by a price plan. */
    delete: {
      parameters: {
        path: {
          meter_name: string;
        };
      };
      responses: {
        /** No Content */
        204: never;
        default: components['responses']['DEFAULT_ERROR'];
      };
    };
    parameters: {
      path: {
        meter_name: string;
      };
    };
  };
  '/meters/{meter_name}/archive': {
    /** Update a meter by its unique name. */
    post: {
      parameters: {
        path: {
          meter_name: string;
        };
      };
      responses: {
        /** OK */
        200: unknown;
        default: components['responses']['DEFAULT_ERROR'];
      };
    };
    parameters: {
      path: {
        meter_name: string;
      };
    };
  };
  '/measurements/': {
    post: {
      responses: {
        /** OK */
        200: {
          content: {
            'application/json': components['schemas']['Measurement'];
          };
        };
        422: components['responses']['UNPROCESSABLE_ENTITY'];
        default: components['responses']['DEFAULT_ERROR'];
      };
      requestBody: {
        content: {
          'application/json': components['schemas']['Measurement'];
        };
      };
    };
  };
  '/measurements/multi': {
    post: {
      responses: {
        /** OK */
        200: {
          content: {
            'application/json': components['schemas']['Measurement'][];
          };
        };
        422: components['responses']['UNPROCESSABLE_ENTITY'];
        default: components['responses']['DEFAULT_ERROR'];
      };
      requestBody: {
        content: {
          'application/json': components['schemas']['Measurement'][];
        };
      };
    };
  };
  '/customers/': {
    /** Retrieve all customers for a given vendor. */
    get: {
      responses: {
        /** OK */
        200: {
          content: {
            'application/json': components['schemas']['Customer'][];
          };
        };
        default: components['responses']['DEFAULT_ERROR'];
      };
    };
    /** Create a new customer. */
    post: {
      responses: {
        /** OK */
        200: {
          content: {
            'application/json': components['schemas']['Customer'];
          };
        };
        422: components['responses']['UNPROCESSABLE_ENTITY'];
        default: components['responses']['DEFAULT_ERROR'];
      };
      requestBody: {
        content: {
          'application/json': components['schemas']['CreateCustomerArgs'];
        };
      };
    };
  };
  '/customers/{customer_name}': {
    /** Fetch a customer by their unique name. */
    get: {
      parameters: {
        path: {
          customer_name: string;
        };
      };
      responses: {
        /** OK */
        200: {
          content: {
            'application/json': components['schemas']['Customer'];
          };
        };
        default: components['responses']['DEFAULT_ERROR'];
      };
    };
    /** Update a single customer. To update Customer measurement mappings, use the `customers/{customer_name}/mappings` endpoint. */
    put: {
      parameters: {
        path: {
          customer_name: string;
        };
      };
      responses: {
        /** OK */
        200: {
          content: {
            'application/json': components['schemas']['Customer'];
          };
        };
        422: components['responses']['UNPROCESSABLE_ENTITY'];
        default: components['responses']['DEFAULT_ERROR'];
      };
      requestBody: {
        content: {
          'application/json': components['schemas']['UpdateCustomerArgs'];
        };
      };
    };
    /** Delete a customer by their unique name. */
    delete: {
      parameters: {
        path: {
          customer_name: string;
        };
      };
      responses: {
        /** No Content */
        204: never;
        default: components['responses']['DEFAULT_ERROR'];
      };
    };
    parameters: {
      path: {
        customer_name: string;
      };
    };
  };
  '/customers/{customer_name}/mappings': {
    /** Fetch all measurement mappings for a specific customer (by unique customer name). */
    get: {
      parameters: {
        path: {
          customer_name: string;
        };
      };
      responses: {
        /** OK */
        200: {
          content: {
            'application/json': components['schemas']['CustomerMeasurementMapping'][];
          };
        };
        default: components['responses']['DEFAULT_ERROR'];
      };
    };
    /** Create a new measurement mapping for a customer. If no value_regex is passed, label existence is checked instead. */
    post: {
      parameters: {
        path: {
          customer_name: string;
        };
      };
      responses: {
        /** OK */
        200: {
          content: {
            'application/json': components['schemas']['CustomerMeasurementMapping'];
          };
        };
        422: components['responses']['UNPROCESSABLE_ENTITY'];
        default: components['responses']['DEFAULT_ERROR'];
      };
      requestBody: {
        content: {
          'application/json': components['schemas']['CustomerMeasurementMappingInputArgs'];
        };
      };
    };
    parameters: {
      path: {
        customer_name: string;
      };
    };
  };
  '/customers/{customer_name}/payment_method_status': {
    /** Fetch payment method status for a specific customer (by unique customer name). */
    get: {
      parameters: {
        path: {
          customer_name: string;
        };
      };
      responses: {
        /** OK */
        200: {
          content: {
            'application/json': components['schemas']['CustomerPaymentMethodStatus'];
          };
        };
        default: components['responses']['DEFAULT_ERROR'];
      };
    };
    parameters: {
      path: {
        customer_name: string;
      };
    };
  };
  '/customers/{customer_name}/payment_gateway_credentials': {
    /**
     * Get the payment gateway credentials from the vendor's configured payment gateway for the given customer.
     * For example, this endpoint will return a customer's Stripe customer ID, assuming the vendor has integrated with stripe and has configured the given customer with a Stripe customer ID.
     */
    get: {
      parameters: {
        path: {
          customer_name: string;
        };
      };
      responses: {
        /** OK */
        200: {
          content: {
            'application/json': components['schemas']['PaymentGatewayCredential'];
          };
        };
        default: components['responses']['DEFAULT_ERROR'];
      };
    };
    /**
     * Add credentials for a customer's account in the vendor's currently configured payment gateway.
     * For example, this endpoint can be used to associate a customer with a Stripe customer ID.
     */
    post: {
      parameters: {
        path: {
          customer_name: string;
        };
      };
      responses: {
        /** OK */
        200: {
          content: {
            'application/json': components['schemas']['PaymentGatewayCredential'];
          };
        };
        422: components['responses']['UNPROCESSABLE_ENTITY'];
        default: components['responses']['DEFAULT_ERROR'];
      };
      requestBody: {
        content: {
          'application/json': components['schemas']['CustomerPaymentGatewayCredentialInputArgs'];
        };
      };
    };
    parameters: {
      path: {
        customer_name: string;
      };
    };
  };
  '/customers/{customer_name}/billing_settings': {
    /** Fetch the billing settings for a customer. */
    get: {
      parameters: {
        path: {
          customer_name: string;
        };
      };
      responses: {
        /** OK */
        200: {
          content: {
            'application/json': components['schemas']['BillingSettings'];
          };
        };
        default: components['responses']['DEFAULT_ERROR'];
      };
    };
    /** Update billing settings for a customer. */
    put: {
      parameters: {
        path: {
          customer_name: string;
        };
      };
      responses: {
        /** OK */
        200: {
          content: {
            'application/json': components['schemas']['BillingSettings'];
          };
        };
        422: components['responses']['UNPROCESSABLE_ENTITY'];
        default: components['responses']['DEFAULT_ERROR'];
      };
      requestBody: {
        content: {
          'application/json': components['schemas']['CustomerBillingSettingsInputArgs'];
        };
      };
    };
    /** Create billing settings for a customer. */
    post: {
      parameters: {
        path: {
          customer_name: string;
        };
      };
      responses: {
        /** OK */
        200: {
          content: {
            'application/json': components['schemas']['BillingSettings'];
          };
        };
        422: components['responses']['UNPROCESSABLE_ENTITY'];
        default: components['responses']['DEFAULT_ERROR'];
      };
      requestBody: {
        content: {
          'application/json': components['schemas']['CustomerBillingSettingsInputArgs'];
        };
      };
    };
    /** Delete billing settings for a customer. */
    delete: {
      parameters: {
        path: {
          customer_name: string;
        };
      };
      responses: {
        /** No Content */
        204: never;
        default: components['responses']['DEFAULT_ERROR'];
      };
    };
    parameters: {
      path: {
        customer_name: string;
      };
    };
  };
  '/customers/{customer_name}/revenue': {
    /** Fetch revenue of a customer from start_time and end_time. */
    get: {
      parameters: {
        path: {
          customer_name: string;
        };
        query: {
          start_time?: string;
          end_time?: string;
        };
      };
      responses: {
        /** OK */
        200: {
          content: {
            'application/json': components['schemas']['RevenueResponse'];
          };
        };
        422: components['responses']['UNPROCESSABLE_ENTITY'];
        default: components['responses']['DEFAULT_ERROR'];
      };
    };
    parameters: {
      path: {
        customer_name: string;
      };
    };
  };
  '/customers/{customer_name}/invoice/{invoice_id}/{token}': {
    /** Fetch current cycle revenue for a customer and generate an invoice. */
    get: {
      parameters: {
        path: {
          invoice_id: number;
          token: string;
          customer_name: string;
        };
      };
      responses: {
        default: components['responses']['DEFAULT_ERROR'];
      };
    };
    parameters: {
      path: {
        invoice_id: number;
        token: string;
        customer_name: string;
      };
    };
  };
  '/customers/{customer_name}/sample_invoice/{as_of_str}/{token}': {
    /** Fetch current cycle revenue for a customer and generate an invoice. */
    get: {
      parameters: {
        path: {
          as_of_str: string;
          token: string;
          customer_name: string;
        };
      };
      responses: {
        default: components['responses']['DEFAULT_ERROR'];
      };
    };
    parameters: {
      path: {
        as_of_str: string;
        token: string;
        customer_name: string;
      };
    };
  };
  '/customers/{customer_name}/sample_invoice/{token}': {
    /** Fetch current cycle revenue for a customer and generate an invoice. */
    get: {
      parameters: {
        path: {
          token: string;
          customer_name: string;
        };
      };
      responses: {
        default: components['responses']['DEFAULT_ERROR'];
      };
    };
    parameters: {
      path: {
        token: string;
        customer_name: string;
      };
    };
  };
  '/customers/{customer_name}/status': {
    /** Get the current status for a customer. */
    get: {
      parameters: {
        path: {
          customer_name: string;
        };
      };
      responses: {
        /** OK */
        200: {
          content: {
            'application/json': components['schemas']['CustomerStatus'];
          };
        };
        default: components['responses']['DEFAULT_ERROR'];
      };
    };
    parameters: {
      path: {
        customer_name: string;
      };
    };
  };
  '/customers/{customer_name}/usage': {
    /** For the given meter, get a customer's total usage. */
    get: {
      parameters: {
        path: {
          customer_name: string;
        };
        query: {
          /** Starting timestamp to consider usage formatted as ISO-8601. */
          start_time?: string;
          meter_name?: string;
          /** Ending timestamp to consider usage formatted as ISO-8601. */
          end_time?: string;
        };
      };
      responses: {
        /** OK */
        200: {
          content: {
            'application/json': components['schemas']['CustomerUsage'];
          };
        };
        422: components['responses']['UNPROCESSABLE_ENTITY'];
        default: components['responses']['DEFAULT_ERROR'];
      };
    };
    parameters: {
      path: {
        customer_name: string;
      };
    };
  };
  '/customers/{customer_name}/features/{feature_name}': {
    /** Get the details of a feature for a given customer. The feature's status is determined by their subscription first, and by their price plan if no feature overrides are found on the subscription. */
    get: {
      parameters: {
        path: {
          feature_name: string;
          customer_name: string;
        };
      };
      responses: {
        /** OK */
        200: {
          content: {
            'application/json': components['schemas']['CustomerFeature'];
          };
        };
        default: components['responses']['DEFAULT_ERROR'];
      };
    };
    parameters: {
      path: {
        feature_name: string;
        customer_name: string;
      };
    };
  };
  '/customers/{customer_name}/accrued_revenue': {
    /** Get the accrued revenue and invoice line items for the given customer. */
    get: {
      parameters: {
        path: {
          customer_name: string;
        };
      };
      responses: {
        /** OK */
        200: {
          content: {
            'application/json': components['schemas']['RevenueBreakdown'];
          };
        };
        default: components['responses']['DEFAULT_ERROR'];
      };
    };
    parameters: {
      path: {
        customer_name: string;
      };
    };
  };
  '/customers/{customer_name}/total_accrued_revenue': {
    /**
     * Gets the total accrued revenue for a customer broken down by line item until
     * the beginning of the current hour.
     */
    get: {
      parameters: {
        path: {
          customer_name: string;
        };
      };
      responses: {
        /** OK */
        200: {
          content: {
            'application/json': components['schemas']['AccruedRevenue'];
          };
        };
        default: components['responses']['DEFAULT_ERROR'];
      };
    };
    parameters: {
      path: {
        customer_name: string;
      };
    };
  };
  '/customers/{customer_name}/daily_accrued_revenue': {
    /**
     * Gets the daily accrued revenue for a customer broken down by line item until
     * the beginning of the current hour.
     */
    get: {
      parameters: {
        path: {
          customer_name: string;
        };
      };
      responses: {
        /** OK */
        200: {
          content: {
            'application/json': components['schemas']['DailyAccruedRevenue'][];
          };
        };
        default: components['responses']['DEFAULT_ERROR'];
      };
    };
    parameters: {
      path: {
        customer_name: string;
      };
    };
  };
  '/customers/{customer_name}/metadata': {
    /** Get the metadata for a given customer */
    get: {
      parameters: {
        path: {
          customer_name: string;
        };
      };
      responses: {
        /** OK */
        200: {
          content: {
            'application/json': components['schemas']['CustomerMetadata'][];
          };
        };
        default: components['responses']['DEFAULT_ERROR'];
      };
    };
    /** Add metadata to a customer (e.g., a tuple of Region: US for a US based customer) */
    post: {
      parameters: {
        path: {
          customer_name: string;
        };
      };
      responses: {
        /** OK */
        200: unknown;
        422: components['responses']['UNPROCESSABLE_ENTITY'];
        default: components['responses']['DEFAULT_ERROR'];
      };
      requestBody: {
        content: {
          'application/json': components['schemas']['CustomerMetadataInput'][];
        };
      };
    };
    parameters: {
      path: {
        customer_name: string;
      };
    };
  };
  '/customers/{customer_name}/invoices': {
    /** Get a list of invoices and their line items for a customer. */
    get: {
      parameters: {
        path: {
          customer_name: string;
        };
        query: {
          sort_direction?: string;
          /** The sort column offset to start at when paging forwards */
          forward_sort_offset?: string;
          /** The number of items to fetch. Defaults to 10. */
          limit?: number;
          customer_name?: string;
          start_time?: string;
          /** The unique offset to start at when paging forwards */
          forward_secondary_sort_offset?: string;
          sort_column?: string;
          status?: string;
        };
      };
      responses: {
        /** OK */
        200: {
          content: {
            'application/json': components['schemas']['Invoice'][];
          };
        };
        422: components['responses']['UNPROCESSABLE_ENTITY'];
        default: components['responses']['DEFAULT_ERROR'];
      };
    };
    parameters: {
      path: {
        customer_name: string;
      };
    };
  };
  '/customers/{customer_name}/credit_top_off_plan': {
    /** Get a customer's credit top off plan. */
    get: {
      parameters: {
        path: {
          customer_name: string;
        };
      };
      responses: {
        /** OK */
        200: {
          content: {
            'application/json': components['schemas']['CreditTopOffPlan'];
          };
        };
        default: components['responses']['DEFAULT_ERROR'];
      };
    };
    /** Update a customer's current credit top off plan. */
    put: {
      parameters: {
        path: {
          customer_name: string;
        };
      };
      responses: {
        /** OK */
        200: {
          content: {
            'application/json': components['schemas']['CreditTopOffPlan'];
          };
        };
        422: components['responses']['UNPROCESSABLE_ENTITY'];
        default: components['responses']['DEFAULT_ERROR'];
      };
      requestBody: {
        content: {
          'application/json': components['schemas']['UpdateCreditTopOffPlanInputArgs'];
        };
      };
    };
    /** Create a credit top off plan for a customer. */
    post: {
      parameters: {
        path: {
          customer_name: string;
        };
      };
      responses: {
        /** OK */
        200: {
          content: {
            'application/json': components['schemas']['CreditTopOffPlan'];
          };
        };
        422: components['responses']['UNPROCESSABLE_ENTITY'];
        default: components['responses']['DEFAULT_ERROR'];
      };
      requestBody: {
        content: {
          'application/json': components['schemas']['CreateCreditTopOffPlanInputArgs'];
        };
      };
    };
    /** Delete a customer's credit top off plan. */
    delete: {
      parameters: {
        path: {
          customer_name: string;
        };
      };
      responses: {
        /** No Content */
        204: never;
        default: components['responses']['DEFAULT_ERROR'];
      };
    };
    parameters: {
      path: {
        customer_name: string;
      };
    };
  };
  '/customers/{customer_name}/usage_across_meters/{token}': {
    /** Get the usage for a customer across all meters in XLS format for a given time period. */
    get: {
      parameters: {
        path: {
          token: string;
          customer_name: string;
        };
        query: {
          start_time: string;
          end_time: string;
        };
      };
      responses: {
        /** OK */
        200: unknown;
        422: components['responses']['UNPROCESSABLE_ENTITY'];
        default: components['responses']['DEFAULT_ERROR'];
      };
    };
    parameters: {
      path: {
        token: string;
        customer_name: string;
      };
    };
  };
  '/customers/{customer_name}/accounting/generation': {
    /** Create the customer entity tied to your accounting software. */
    post: {
      parameters: {
        path: {
          customer_name: string;
        };
      };
      responses: {
        /** OK */
        200: unknown;
        default: components['responses']['DEFAULT_ERROR'];
      };
    };
    parameters: {
      path: {
        customer_name: string;
      };
    };
  };
  '/customers/{customer_name}/accounting': {
    /** Get the accounting customer ID of a customer that has been connected via an accounting integration. */
    get: {
      parameters: {
        path: {
          customer_name: string;
        };
      };
      responses: {
        /** OK */
        200: {
          content: {
            'application/json': components['schemas']['AccountingCustomer'];
          };
        };
        default: components['responses']['DEFAULT_ERROR'];
      };
    };
    /** Connect an Octane customer to an Accounting customer through the configured Accounting integration. The vendor must have an integration configured. */
    post: {
      parameters: {
        path: {
          customer_name: string;
        };
      };
      responses: {
        /** OK */
        200: unknown;
        422: components['responses']['UNPROCESSABLE_ENTITY'];
        default: components['responses']['DEFAULT_ERROR'];
      };
      requestBody: {
        content: {
          'application/json': components['schemas']['AccountingCustomer'];
        };
      };
    };
    /** Deletes the customer entity tied to your accounting software. */
    delete: {
      parameters: {
        path: {
          customer_name: string;
        };
      };
      responses: {
        /** OK */
        200: unknown;
        default: components['responses']['DEFAULT_ERROR'];
      };
    };
    parameters: {
      path: {
        customer_name: string;
      };
    };
  };
  '/customers/{customer_name}/integration/tax/avalara/settings': {
    /** Returns the customer Avalara settings. */
    get: {
      parameters: {
        path: {
          customer_name: string;
        };
      };
      responses: {
        /** OK */
        200: {
          content: {
            'application/json': components['schemas']['CustomerAvalaraSettings'];
          };
        };
        default: components['responses']['DEFAULT_ERROR'];
      };
    };
    /** Updates the Avalara settings for a specific customer. */
    put: {
      parameters: {
        path: {
          customer_name: string;
        };
      };
      responses: {
        /** OK */
        200: {
          content: {
            'application/json': components['schemas']['CustomerAvalaraSettings'];
          };
        };
        422: components['responses']['UNPROCESSABLE_ENTITY'];
        default: components['responses']['DEFAULT_ERROR'];
      };
      requestBody: {
        content: {
          'application/json': components['schemas']['UpdateCustomerAvalaraSettingsArgs'];
        };
      };
    };
    parameters: {
      path: {
        customer_name: string;
      };
    };
  };
  '/customers/{customer_name}/integration/tax/avalara/address/valid': {
    /** Validates to ensure that customer address is taxable via Avalara. */
    get: {
      parameters: {
        path: {
          customer_name: string;
        };
      };
      responses: {
        /** OK */
        200: {
          content: {
            'application/json': components['schemas']['ValidateAddressResp'];
          };
        };
        default: components['responses']['DEFAULT_ERROR'];
      };
    };
    parameters: {
      path: {
        customer_name: string;
      };
    };
  };
  '/customers/{customer_name}/subscriptions': {
    /** Get all subscriptions for the customer. */
    get: {
      parameters: {
        path: {
          customer_name: string;
        };
      };
      responses: {
        /** OK */
        200: {
          content: {
            'application/json': components['schemas']['Subscription'][];
          };
        };
        default: components['responses']['DEFAULT_ERROR'];
      };
    };
    /** Create a new subscription for a customer / price plan combination (by unique name). */
    post: {
      parameters: {
        path: {
          customer_name: string;
        };
      };
      responses: {
        /** OK */
        200: {
          content: {
            'application/json': components['schemas']['Subscription'];
          };
        };
        422: components['responses']['UNPROCESSABLE_ENTITY'];
        default: components['responses']['DEFAULT_ERROR'];
      };
      requestBody: {
        content: {
          'application/json': components['schemas']['CreateSubscriptionArgs'];
        };
      };
    };
    parameters: {
      path: {
        customer_name: string;
      };
    };
  };
  '/customers/{customer_name}/subscription': {
    /** Update a subscription for a specific customer (by customer name). */
    put: {
      parameters: {
        path: {
          customer_name: string;
        };
      };
      responses: {
        /** OK */
        200: {
          content: {
            'application/json': components['schemas']['Subscription'];
          };
        };
        422: components['responses']['UNPROCESSABLE_ENTITY'];
        default: components['responses']['DEFAULT_ERROR'];
      };
      requestBody: {
        content: {
          'application/json': components['schemas']['UpdateSubscriptionArgs'];
        };
      };
    };
    /** Delete a subscription for a specific customer (by customer name). */
    delete: {
      parameters: {
        path: {
          customer_name: string;
        };
      };
      responses: {
        /** No Content */
        204: never;
        422: components['responses']['UNPROCESSABLE_ENTITY'];
        default: components['responses']['DEFAULT_ERROR'];
      };
      requestBody: {
        content: {
          'application/json': components['schemas']['DeleteSubscriptionArgs'];
        };
      };
    };
    parameters: {
      path: {
        customer_name: string;
      };
    };
  };
  '/customers/{customer_name}/subscription/update_in_place': {
    /** Update a subscription in-place for a specific customer (by customer name). */
    put: {
      parameters: {
        path: {
          customer_name: string;
        };
      };
      responses: {
        /** OK */
        200: {
          content: {
            'application/json': components['schemas']['Subscription'];
          };
        };
        422: components['responses']['UNPROCESSABLE_ENTITY'];
        default: components['responses']['DEFAULT_ERROR'];
      };
      requestBody: {
        content: {
          'application/json': components['schemas']['UpdateSubscriptionInPlaceArgs'];
        };
      };
    };
    parameters: {
      path: {
        customer_name: string;
      };
    };
  };
  '/customers/{customer_name}/active_subscription': {
    /** Get the customer's current active subscription. */
    get: {
      parameters: {
        path: {
          customer_name: string;
        };
      };
      responses: {
        /** OK */
        200: {
          content: {
            'application/json': components['schemas']['ActiveSubscription'];
          };
        };
        default: components['responses']['DEFAULT_ERROR'];
      };
    };
    parameters: {
      path: {
        customer_name: string;
      };
    };
  };
  '/customers/{customer_name}/scheduled_subscriptions': {
    /** Get a list of any subscriptions scheduled to start in the future for the given customer. */
    get: {
      parameters: {
        path: {
          customer_name: string;
        };
      };
      responses: {
        /** OK */
        200: {
          content: {
            'application/json': components['schemas']['Subscription'][];
          };
        };
        default: components['responses']['DEFAULT_ERROR'];
      };
    };
    parameters: {
      path: {
        customer_name: string;
      };
    };
  };
  '/customers/{customer_name}/subscription/add_ons': {
    /** Add or remove add ons from the current customer's subscription. */
    post: {
      parameters: {
        path: {
          customer_name: string;
        };
      };
      responses: {
        /** OK */
        200: unknown;
        422: components['responses']['UNPROCESSABLE_ENTITY'];
        default: components['responses']['DEFAULT_ERROR'];
      };
      requestBody: {
        content: {
          'application/json': components['schemas']['SubscriptionAddOnItem'][];
        };
      };
    };
    parameters: {
      path: {
        customer_name: string;
      };
    };
  };
  '/customers/{customer_name}/discounts': {
    /**
     * Add discounts to the list of discounts on the customer's current subscription. The new discounts will be
     * effective_at of the start of the current billing cycle.
     */
    post: {
      parameters: {
        path: {
          customer_name: string;
        };
      };
      responses: {
        /** OK */
        200: unknown;
        422: components['responses']['UNPROCESSABLE_ENTITY'];
        default: components['responses']['DEFAULT_ERROR'];
      };
      requestBody: {
        content: {
          'application/json': components['schemas']['DiscountInputArgs'][];
        };
      };
    };
    /**
     * Delete a discount from the customer's current subscription. If the discount started before the
     * start of the current billing cycle, we will expire it by setting it's end date to the start of
     * the current billing cycle. Otherwise, we will delete the discount.
     */
    delete: {
      parameters: {
        path: {
          customer_name: string;
        };
      };
      responses: {
        /** No Content */
        204: never;
        422: components['responses']['UNPROCESSABLE_ENTITY'];
        default: components['responses']['DEFAULT_ERROR'];
      };
      requestBody: {
        content: {
          'application/json': components['schemas']['DeleteDiscountInputArgs'];
        };
      };
    };
    parameters: {
      path: {
        customer_name: string;
      };
    };
  };
  '/invoices/{invoice_uuid}': {
    /** Get a specific invoice via it's UUID. */
    get: {
      parameters: {
        path: {
          invoice_uuid: string;
        };
      };
      responses: {
        /** OK */
        200: {
          content: {
            'application/json': components['schemas']['Invoice'];
          };
        };
        default: components['responses']['DEFAULT_ERROR'];
      };
    };
    /** Delete a specific invoice via it's UUID. Invoices can only be deleted if they have not been issued. */
    delete: {
      parameters: {
        path: {
          invoice_uuid: string;
        };
      };
      responses: {
        /** No Content */
        204: never;
        default: components['responses']['DEFAULT_ERROR'];
      };
    };
    parameters: {
      path: {
        invoice_uuid: string;
      };
    };
  };
  '/invoices/{invoice_uuid}/status/': {
    /**
     * Manually change the status of an invoice in Octane. For example,
     * if an invoice was paid outside of Octane's payment providers, you can reflect that in Octane by
     * setting the status to paid.
     */
    post: {
      parameters: {
        path: {
          invoice_uuid: string;
        };
      };
      responses: {
        /** OK */
        200: unknown;
        422: components['responses']['UNPROCESSABLE_ENTITY'];
        default: components['responses']['DEFAULT_ERROR'];
      };
      requestBody: {
        content: {
          'application/json': components['schemas']['UpdateInvoiceStatusArgs'];
        };
      };
    };
    parameters: {
      path: {
        invoice_uuid: string;
      };
    };
  };
  '/invoices/': {
    /** Fetch a list of historical invoices generated by Octane. */
    get: {
      parameters: {
        query: {
          sort_direction?: string;
          /** The sort column offset to start at when paging forwards */
          forward_sort_offset?: string;
          /** The number of items to fetch. Defaults to 10. */
          limit?: number;
          customer_name?: string;
          start_time?: string;
          /** The unique offset to start at when paging forwards */
          forward_secondary_sort_offset?: string;
          sort_column?: string;
          status?: string;
        };
      };
      responses: {
        /** OK */
        200: {
          content: {
            'application/json': components['schemas']['PastInvoices'];
          };
        };
        422: components['responses']['UNPROCESSABLE_ENTITY'];
        default: components['responses']['DEFAULT_ERROR'];
      };
    };
  };
  '/invoices/{invoice_uuid_token}/pdf': {
    /** Return the invoice pdf for the given invoice_uuid, first validating token. */
    get: {
      parameters: {
        path: {
          invoice_uuid_token: string;
        };
      };
      responses: {
        default: components['responses']['DEFAULT_ERROR'];
      };
    };
    parameters: {
      path: {
        invoice_uuid_token: string;
      };
    };
  };
  '/invoices/{invoice_uuid}/retries': {
    /**
     * Moves the invoice into the next logical action. For example, an invoice that is generated gets moved to issued, and
     * an invoice that is in payment error tries payment again. For more information see our docs https://docs.getoctane.io/docs/manual-invoicing-triggers.
     */
    post: {
      parameters: {
        path: {
          invoice_uuid: string;
        };
      };
      responses: {
        /** Accepted */
        202: {
          content: {
            'application/json': components['schemas']['Retry'];
          };
        };
        422: components['responses']['UNPROCESSABLE_ENTITY'];
        default: components['responses']['DEFAULT_ERROR'];
      };
      requestBody: {
        content: {
          'application/json': components['schemas']['CreateRetryArgs'];
        };
      };
    };
    parameters: {
      path: {
        invoice_uuid: string;
      };
    };
  };
  '/price_plans/': {
    /** Get all price plans associated with a vendor. */
    get: {
      responses: {
        /** OK */
        200: {
          content: {
            'application/json': components['schemas']['PricePlan'][];
          };
        };
        default: components['responses']['DEFAULT_ERROR'];
      };
    };
    /** Create a price plan for a vendor. */
    post: {
      responses: {
        /** OK */
        200: {
          content: {
            'application/json': components['schemas']['PricePlan'];
          };
        };
        422: components['responses']['UNPROCESSABLE_ENTITY'];
        default: components['responses']['DEFAULT_ERROR'];
      };
      requestBody: {
        content: {
          'application/json': components['schemas']['CreatePricePlanArgs'];
        };
      };
    };
  };
  '/price_plans/{price_plan_name}/{tag}': {
    /** Get an existing price plan. */
    get: {
      parameters: {
        path: {
          price_plan_name: string;
          tag: string;
        };
      };
      responses: {
        /** OK */
        200: {
          content: {
            'application/json': components['schemas']['PricePlan'];
          };
        };
        default: components['responses']['DEFAULT_ERROR'];
      };
    };
    parameters: {
      path: {
        price_plan_name: string;
        tag: string;
      };
    };
  };
  '/price_plans/paginate': {
    /** List all price plans with pagination. */
    get: {
      parameters: {
        query: {
          sort_direction?: string;
          /** The sort column offset to start at when paging forwards */
          forward_sort_offset?: string;
          /** The number of items to fetch. Defaults to 10. */
          limit?: number;
          /** The unique offset to start at when paging forwards */
          forward_secondary_sort_offset?: string;
          names?: string[];
          sort_column?: string;
          tags?: string[];
        };
      };
      responses: {
        /** OK */
        200: {
          content: {
            'application/json': components['schemas']['ListPricePlans'];
          };
        };
        422: components['responses']['UNPROCESSABLE_ENTITY'];
        default: components['responses']['DEFAULT_ERROR'];
      };
    };
  };
  '/price_plans/{price_plan_name}': {
    /** Fetch an existing price plan. */
    get: {
      parameters: {
        path: {
          price_plan_name: string;
        };
      };
      responses: {
        /** OK */
        200: {
          content: {
            'application/json': components['schemas']['PricePlan'];
          };
        };
        default: components['responses']['DEFAULT_ERROR'];
      };
    };
    /** Update an existing price plan. */
    put: {
      parameters: {
        path: {
          price_plan_name: string;
        };
      };
      responses: {
        /** OK */
        200: {
          content: {
            'application/json': components['schemas']['PricePlan'];
          };
        };
        422: components['responses']['UNPROCESSABLE_ENTITY'];
        default: components['responses']['DEFAULT_ERROR'];
      };
      requestBody: {
        content: {
          'application/json': components['schemas']['UpdatePricePlanArgs'];
        };
      };
    };
    /** Delete an existing Price Plan. Price Plans which map to active Subscriptions must be replaced or removed before deletion can occur. */
    delete: {
      parameters: {
        path: {
          price_plan_name: string;
        };
      };
      responses: {
        /** No Content */
        204: never;
        default: components['responses']['DEFAULT_ERROR'];
      };
    };
    parameters: {
      path: {
        price_plan_name: string;
      };
    };
  };
  '/price_plans/update_in_place/{price_plan_name}/{tag}': {
    /** Edit a price plan without creating a new version. */
    post: {
      parameters: {
        path: {
          price_plan_name: string;
          tag: string;
        };
      };
      responses: {
        /** OK */
        200: {
          content: {
            'application/json': components['schemas']['PricePlan'];
          };
        };
        422: components['responses']['UNPROCESSABLE_ENTITY'];
        default: components['responses']['DEFAULT_ERROR'];
      };
      requestBody: {
        content: {
          'application/json': components['schemas']['UpdatePricePlanInPlaceArgs'];
        };
      };
    };
    parameters: {
      path: {
        price_plan_name: string;
        tag: string;
      };
    };
  };
  '/price_plans/update_in_place/{price_plan_name}': {
    /** Edit a price plan without creating a new version. */
    post: {
      parameters: {
        path: {
          price_plan_name: string;
        };
      };
      responses: {
        /** OK */
        200: {
          content: {
            'application/json': components['schemas']['PricePlan'];
          };
        };
        422: components['responses']['UNPROCESSABLE_ENTITY'];
        default: components['responses']['DEFAULT_ERROR'];
      };
      requestBody: {
        content: {
          'application/json': components['schemas']['UpdatePricePlanInPlaceArgs'];
        };
      };
    };
    parameters: {
      path: {
        price_plan_name: string;
      };
    };
  };
  '/price_plans/{price_plan_name}/archive': {
    /** Archive a price plan that has no active/scheduled subscription. */
    post: {
      parameters: {
        path: {
          price_plan_name: string;
        };
      };
      responses: {
        /** OK */
        200: unknown;
        default: components['responses']['DEFAULT_ERROR'];
      };
    };
    parameters: {
      path: {
        price_plan_name: string;
      };
    };
  };
  '/price_plans/self_serve': {
    /** Get all price plans marked for self serve for this vendor. */
    get: {
      responses: {
        /** OK */
        200: {
          content: {
            'application/json': components['schemas']['PricePlan'][];
          };
        };
        default: components['responses']['DEFAULT_ERROR'];
      };
    };
    /** Set the exhaustive list of price plans that the customer can see and select via self serve. */
    post: {
      responses: {
        /** OK */
        200: unknown;
        422: components['responses']['UNPROCESSABLE_ENTITY'];
        default: components['responses']['DEFAULT_ERROR'];
      };
      requestBody: {
        content: {
          'application/json': components['schemas']['SelfServePricePlansInputArgs'];
        };
      };
    };
  };
  '/price_plans/{uuid}/add_features': {
    /** Add features and(or) limits to a price plan in place */
    post: {
      parameters: {
        path: {
          uuid: string;
        };
      };
      responses: {
        /** OK */
        200: {
          content: {
            'application/json': components['schemas']['PricePlan'];
          };
        };
        422: components['responses']['UNPROCESSABLE_ENTITY'];
        default: components['responses']['DEFAULT_ERROR'];
      };
      requestBody: {
        content: {
          'application/json': components['schemas']['AddFeaturesToPricePlanInput'];
        };
      };
    };
    parameters: {
      path: {
        uuid: string;
      };
    };
  };
  '/price_plans/{uuid}/remove_features': {
    /** Remove features and(or) limits from a price plan in place */
    post: {
      parameters: {
        path: {
          uuid: string;
        };
      };
      responses: {
        /** OK */
        200: {
          content: {
            'application/json': components['schemas']['PricePlan'];
          };
        };
        422: components['responses']['UNPROCESSABLE_ENTITY'];
        default: components['responses']['DEFAULT_ERROR'];
      };
      requestBody: {
        content: {
          'application/json': components['schemas']['RemoveFeaturesFromPricePlanInput'];
        };
      };
    };
    parameters: {
      path: {
        uuid: string;
      };
    };
  };
  '/price_plans/{uuid}/add_add_ons': {
    /** Add add ons to price plan in place */
    post: {
      parameters: {
        path: {
          uuid: string;
        };
      };
      responses: {
        /** OK */
        200: {
          content: {
            'application/json': components['schemas']['PricePlan'];
          };
        };
        422: components['responses']['UNPROCESSABLE_ENTITY'];
        default: components['responses']['DEFAULT_ERROR'];
      };
      requestBody: {
        content: {
          'application/json': components['schemas']['AddAddOnsToPricePlanInput'];
        };
      };
    };
    parameters: {
      path: {
        uuid: string;
      };
    };
  };
  '/price_plans/{uuid}/add_metered_components': {
    /** Add metered components to price plan in place */
    post: {
      parameters: {
        path: {
          uuid: string;
        };
      };
      responses: {
        /** OK */
        200: {
          content: {
            'application/json': components['schemas']['PricePlan'];
          };
        };
        422: components['responses']['UNPROCESSABLE_ENTITY'];
        default: components['responses']['DEFAULT_ERROR'];
      };
      requestBody: {
        content: {
          'application/json': components['schemas']['AddMeteredComponentsToPricePlanInput'];
        };
      };
    };
    parameters: {
      path: {
        uuid: string;
      };
    };
  };
  '/price_plans/metered_components/{uuid}/update_limits': {
    /** Update metered component usage limits in place */
    post: {
      parameters: {
        path: {
          uuid: string;
        };
      };
      responses: {
        /** OK */
        200: {
          content: {
            'application/json': components['schemas']['MeteredComponent'];
          };
        };
        422: components['responses']['UNPROCESSABLE_ENTITY'];
        default: components['responses']['DEFAULT_ERROR'];
      };
      requestBody: {
        content: {
          'application/json': components['schemas']['UpdateMeteredComponentLimitsInput'];
        };
      };
    };
    parameters: {
      path: {
        uuid: string;
      };
    };
  };
  '/payment_gateway_credentials/': {
    /** Returns the payment gateway information for your account (the Paddle or Stripe credentials used to issue and pay invoices) */
    get: {
      responses: {
        /** OK */
        200: {
          content: {
            'application/json': components['schemas']['PaymentGatewayCredential'];
          };
        };
        default: components['responses']['DEFAULT_ERROR'];
      };
    };
    /** Adds the credentials for a payment gateway, to be used to issue and pay invoices to your account. */
    post: {
      responses: {
        /** OK */
        200: {
          content: {
            'application/json': components['schemas']['PaymentGatewayCredential'];
          };
        };
        422: components['responses']['UNPROCESSABLE_ENTITY'];
        default: components['responses']['DEFAULT_ERROR'];
      };
      requestBody: {
        content: {
          'application/json': components['schemas']['PaymentGatewayCredentialInputArgs'];
        };
      };
    };
  };
  '/billing_settings/': {
    /** Get billing settings for a vendor. */
    get: {
      responses: {
        /** OK */
        200: {
          content: {
            'application/json': components['schemas']['BillingSettings'];
          };
        };
        default: components['responses']['DEFAULT_ERROR'];
      };
    };
    /** Update billing settings for a vendor. */
    put: {
      responses: {
        /** OK */
        200: {
          content: {
            'application/json': components['schemas']['BillingSettings'];
          };
        };
        422: components['responses']['UNPROCESSABLE_ENTITY'];
        default: components['responses']['DEFAULT_ERROR'];
      };
      requestBody: {
        content: {
          'application/json': components['schemas']['UpdateBillingSettingsInputArgs'];
        };
      };
    };
    /** Create billing settings for a vendor. */
    post: {
      responses: {
        /** OK */
        200: {
          content: {
            'application/json': components['schemas']['BillingSettings'];
          };
        };
        422: components['responses']['UNPROCESSABLE_ENTITY'];
        default: components['responses']['DEFAULT_ERROR'];
      };
      requestBody: {
        content: {
          'application/json': components['schemas']['CreateBillingSettingsInputArgs'];
        };
      };
    };
    /** Delete billing settings for a vendor. */
    delete: {
      responses: {
        /** No Content */
        204: never;
        default: components['responses']['DEFAULT_ERROR'];
      };
    };
  };
  '/coupons/': {
    /** Gets all coupons for a specific vendor. */
    get: {
      responses: {
        /** OK */
        200: {
          content: {
            'application/json': components['schemas']['Coupon'][];
          };
        };
        default: components['responses']['DEFAULT_ERROR'];
      };
    };
    /** Create a coupon for a vendor. */
    post: {
      responses: {
        /** OK */
        200: {
          content: {
            'application/json': components['schemas']['Coupon'];
          };
        };
        422: components['responses']['UNPROCESSABLE_ENTITY'];
        default: components['responses']['DEFAULT_ERROR'];
      };
      requestBody: {
        content: {
          'application/json': components['schemas']['CouponInputArgs'];
        };
      };
    };
  };
  '/coupons/{coupon_name}': {
    /** Get a specific coupon for a vendor. */
    get: {
      parameters: {
        path: {
          coupon_name: string;
        };
      };
      responses: {
        /** OK */
        200: {
          content: {
            'application/json': components['schemas']['Coupon'];
          };
        };
        default: components['responses']['DEFAULT_ERROR'];
      };
    };
    /** Delete a specific coupon for a vendor. */
    delete: {
      parameters: {
        path: {
          coupon_name: string;
        };
      };
      responses: {
        /** No Content */
        204: never;
        default: components['responses']['DEFAULT_ERROR'];
      };
    };
    parameters: {
      path: {
        coupon_name: string;
      };
    };
  };
  '/coupons/apply_coupon': {
    /** Apply a coupon to the provided customer. */
    post: {
      responses: {
        /** OK */
        200: unknown;
        422: components['responses']['UNPROCESSABLE_ENTITY'];
        default: components['responses']['DEFAULT_ERROR'];
      };
      requestBody: {
        content: {
          'application/json': components['schemas']['ApplyCouponInputArgs'];
        };
      };
    };
  };
  '/refund/': {
    /** Create a refund for a paid invoice. */
    post: {
      responses: {
        /** Accepted */
        202: {
          content: {
            'application/json': components['schemas']['Refund'];
          };
        };
        422: components['responses']['UNPROCESSABLE_ENTITY'];
        default: components['responses']['DEFAULT_ERROR'];
      };
      requestBody: {
        content: {
          'application/json': components['schemas']['CreateRefundArgs'];
        };
      };
    };
  };
  '/customer_portal_settings/': {
    /** Fetch the Customer Portal settings for your account. */
    get: {
      responses: {
        /** OK */
        200: {
          content: {
            'application/json': components['schemas']['CustomerPortalSettings'];
          };
        };
        default: components['responses']['DEFAULT_ERROR'];
      };
    };
    /** Update Customer Portal settings for your account. */
    post: {
      responses: {
        /** OK */
        200: {
          content: {
            'application/json': components['schemas']['CustomerPortalSettings'];
          };
        };
        422: components['responses']['UNPROCESSABLE_ENTITY'];
        default: components['responses']['DEFAULT_ERROR'];
      };
      requestBody: {
        content: {
          'application/json': components['schemas']['UpdateCustomerPortalSettingsInputArgs'];
        };
      };
    };
  };
  '/ecp/token': {
    /** Generate a customer-scoped JWT to authorize access to ECP endpoints. This endpoint expects the vendor API key for authentication. */
    post: {
      responses: {
        /** OK */
        200: {
          content: {
            'application/json': components['schemas']['CustomerPortalToken'];
          };
        };
        422: components['responses']['UNPROCESSABLE_ENTITY'];
        default: components['responses']['DEFAULT_ERROR'];
      };
      requestBody: {
        content: {
          'application/json': components['schemas']['CustomerPortalTokenInputArgs'];
        };
      };
    };
  };
  '/ecp/customer_portal_url': {
    /** Generate the url to the customer portal. This endpoint expects the vendor API key for authentication. */
    post: {
      responses: {
        /** OK */
        200: {
          content: {
            'application/json': components['schemas']['CustomerPortalUrl'];
          };
        };
        422: components['responses']['UNPROCESSABLE_ENTITY'];
        default: components['responses']['DEFAULT_ERROR'];
      };
      requestBody: {
        content: {
          'application/json': components['schemas']['CustomerPortalTokenInputArgs'];
        };
      };
    };
  };
  '/ecp/portal_url': {
    /** Get the url to the customer portal. This endpoint expects the customer-scoped token for authentication. */
    get: {
      responses: {
        /** OK */
        200: {
          content: {
            'application/json': components['schemas']['CustomerPortalUrl'];
          };
        };
        default: components['responses']['DEFAULT_ERROR'];
      };
    };
  };
  '/ecp/vendor': {
    /** Get relevant information about the customer's vendor. This endpoint expects the customer-scoped token for authentication. */
    get: {
      responses: {
        /** OK */
        200: {
          content: {
            'application/json': components['schemas']['CustomerPortalVendor'];
          };
        };
        default: components['responses']['DEFAULT_ERROR'];
      };
    };
  };
  '/ecp/price_plans': {
    /** Get all price plans visible to the given customer for self serve. By default, no price plans are visible. Price plan visibility can be configured by the vendor using the /price_plans/self_serve endpoint. */
    get: {
      responses: {
        /** OK */
        200: {
          content: {
            'application/json': components['schemas']['PricePlan'][];
          };
        };
        default: components['responses']['DEFAULT_ERROR'];
      };
    };
  };
  '/ecp/invoices': {
    /** Get all invoices visible to the given customer. This endpoint expects the customer-scoped token for authentication. */
    get: {
      responses: {
        /** OK */
        200: {
          content: {
            'application/json': components['schemas']['CustomerPortalInvoice'][];
          };
        };
        default: components['responses']['DEFAULT_ERROR'];
      };
    };
  };
  '/ecp/active_subscription': {
    /** Fetch the customer's active subscription and related information if they exists. This endpoint expects the customer-scoped token for authentication. */
    get: {
      responses: {
        /** OK */
        200: {
          content: {
            'application/json': components['schemas']['CustomerPortalActiveSubscription'];
          };
        };
        default: components['responses']['DEFAULT_ERROR'];
      };
    };
    /** Create/update the customer's subscription. This endpoint expects the customer-scoped token for authentication. */
    post: {
      responses: {
        /** OK */
        200: {
          content: {
            'application/json': components['schemas']['CustomerPortalSubscription'];
          };
        };
        422: components['responses']['UNPROCESSABLE_ENTITY'];
        default: components['responses']['DEFAULT_ERROR'];
      };
      requestBody: {
        content: {
          'application/json': components['schemas']['CustomerPortalActiveSubscriptionInputArgs'];
        };
      };
    };
  };
  '/ecp/subscription': {
    /** Fetch the customer's active price plan if it exists. This endpoint expects the customer-scoped token for authentication. */
    get: {
      responses: {
        /** OK */
        200: {
          content: {
            'application/json': components['schemas']['CustomerPortalSubscription'];
          };
        };
        default: components['responses']['DEFAULT_ERROR'];
      };
    };
    /** Create/update the customer's subscription. This endpoint expects the customer-scoped token for authentication. */
    post: {
      responses: {
        /** OK */
        200: {
          content: {
            'application/json': components['schemas']['CustomerPortalSubscription'];
          };
        };
        422: components['responses']['UNPROCESSABLE_ENTITY'];
        default: components['responses']['DEFAULT_ERROR'];
      };
      requestBody: {
        content: {
          'application/json': components['schemas']['CustomerPortalSubscriptionInputArgs'];
        };
      };
    };
    /** Cancel the customer's subscription. This endpoint expects the customer-scoped token for authentication. */
    delete: {
      responses: {
        /** No Content */
        204: never;
        default: components['responses']['DEFAULT_ERROR'];
      };
    };
  };
  '/ecp/setup_intent': {
    /** Attempt to create a Stripe SetupIntent object. This endpoint expects the customer-scoped token for authentication. */
    post: {
      responses: {
        /** OK */
        200: {
          content: {
            'application/json': components['schemas']['CustomerPortalStripeCredential'];
          };
        };
        default: components['responses']['DEFAULT_ERROR'];
      };
    };
  };
  '/ecp/payment_method_status': {
    /** Gets the customer's current payment method status. Returns a 400 if the customer has no configuration or if the current payment provider doesn't have customer-level payment status. This endpoint expects the customer-scoped token for authentication. */
    get: {
      responses: {
        /** OK */
        200: {
          content: {
            'application/json': components['schemas']['CustomerPaymentMethodStatus'];
          };
        };
        default: components['responses']['DEFAULT_ERROR'];
      };
    };
  };
  '/ecp/contact_info': {
    /** Gets the customer's contact info. This endpoint expects the customer-scoped token for authentication. */
    get: {
      responses: {
        /** OK */
        200: {
          content: {
            'application/json': components['schemas']['ContactInfo'];
          };
        };
        default: components['responses']['DEFAULT_ERROR'];
      };
    };
    /** Create/update the customer's contact info. This endpoint expects the customer-scoped token for authentication. */
    put: {
      responses: {
        /** OK */
        200: {
          content: {
            'application/json': components['schemas']['ContactInfo'];
          };
        };
        422: components['responses']['UNPROCESSABLE_ENTITY'];
        default: components['responses']['DEFAULT_ERROR'];
      };
      requestBody: {
        content: {
          'application/json': components['schemas']['ContactInfoInputArgs'];
        };
      };
    };
  };
  '/ecp/meters': {
    /** Get the meters and corresponding primary label keys and values from the customer's active subscription. */
    get: {
      responses: {
        /** OK */
        200: {
          content: {
            'application/json': components['schemas']['CustomerPortalMeter'][];
          };
        };
        default: components['responses']['DEFAULT_ERROR'];
      };
    };
  };
  '/ecp/usage': {
    /**
     * [DEPRECATED] Get the customer's daily usage by meter for current and previous billing cycles. This endpoint expects the customer-scoped token for authentication.
     *
     * Please use /ecp/filtered_usage instead.
     */
    get: {
      responses: {
        /** OK */
        200: {
          content: {
            'application/json': components['schemas']['CustomerPortalUsage'][];
          };
        };
        default: components['responses']['DEFAULT_ERROR'];
      };
    };
  };
  '/ecp/total_accrued_revenue': {
    /**
     * Gets the total accrued revenue for a customer broken down by line item until
     * the beginning of the current hour.
     */
    get: {
      responses: {
        /** OK */
        200: {
          content: {
            'application/json': components['schemas']['CustomerPortalAccruedRevenue'];
          };
        };
        default: components['responses']['DEFAULT_ERROR'];
      };
    };
  };
  '/ecp/daily_accrued_revenue': {
    /**
     * Gets the daily accrued revenue for a customer broken down by line item until
     * the beginning of the current hour.
     */
    get: {
      responses: {
        /** OK */
        200: {
          content: {
            'application/json': components['schemas']['CustomerPortalDailyAccruedRevenue'][];
          };
        };
        default: components['responses']['DEFAULT_ERROR'];
      };
    };
  };
  '/ecp/filtered_usage': {
    /** Get the customer's daily usage filtered by the inputted meter and labels. This endpoint expects the customer-scoped token for authentication. */
    post: {
      responses: {
        /** OK */
        200: {
          content: {
            'application/json': components['schemas']['CustomerPortalUsage'];
          };
        };
        422: components['responses']['UNPROCESSABLE_ENTITY'];
        default: components['responses']['DEFAULT_ERROR'];
      };
      requestBody: {
        content: {
          'application/json': components['schemas']['CustomerPortalMeterLabelFilter'];
        };
      };
    };
  };
  '/ecp/payment_method': {
    /** Get the customer's current payment method if it exists in their payment gateway. This endpoint expects the customer-scoped token for authentication. */
    get: {
      responses: {
        /** OK */
        200: {
          content: {
            'application/json': components['schemas']['CustomerPortalPaymentMethod'];
          };
        };
        default: components['responses']['DEFAULT_ERROR'];
      };
    };
  };
  '/ecp/self_serve_settings': {
    /** Get the customer's self serve settings. This endpoint expects the customer-scoped token for authentication. */
    get: {
      responses: {
        /** OK */
        200: {
          content: {
            'application/json': components['schemas']['SelfServeSettings'];
          };
        };
        default: components['responses']['DEFAULT_ERROR'];
      };
    };
  };
  '/ecp/self_serve_customization': {
    /** Get the customer's self serve customization. This endpoint expects the customer-scoped token for authentication. */
    get: {
      responses: {
        /** OK */
        200: {
          content: {
            'application/json': components['schemas']['SelfServeCustomization'];
          };
        };
        default: components['responses']['DEFAULT_ERROR'];
      };
    };
  };
  '/ecp/credit/ledger': {
    /** Returns the customer entire credit ledger. This can be used to compute the current and available credit balance. This endpoint expects the customer-scoped token for authentication. */
    get: {
      responses: {
        /** OK */
        200: {
          content: {
            'application/json': components['schemas']['CreditLedger'][];
          };
        };
        default: components['responses']['DEFAULT_ERROR'];
      };
    };
  };
  '/ecp/credit/purchase': {
    /** Purchase the provided amount of credits at the default expiration and price set by the vendor. This endpoint expects the customer-scoped token for authentication. */
    post: {
      responses: {
        /** OK */
        200: {
          content: {
            'application/json': components['schemas']['CreditGrant'];
          };
        };
        422: components['responses']['UNPROCESSABLE_ENTITY'];
        default: components['responses']['DEFAULT_ERROR'];
      };
      requestBody: {
        content: {
          'application/json': components['schemas']['CustomerPortalCreditPurchase'];
        };
      };
    };
  };
  '/webhooks/': {
    /** Get all Webhooks for a given Vendor. */
    get: {
      responses: {
        /** OK */
        200: {
          content: {
            'application/json': components['schemas']['Webhook'][];
          };
        };
        default: components['responses']['DEFAULT_ERROR'];
      };
    };
    /** Add an endpoint to use with Octane's Webhook API. */
    post: {
      responses: {
        /** OK */
        200: {
          content: {
            'application/json': components['schemas']['Webhook'];
          };
        };
        422: components['responses']['UNPROCESSABLE_ENTITY'];
        default: components['responses']['DEFAULT_ERROR'];
      };
      requestBody: {
        content: {
          'application/json': components['schemas']['CreateWebhookArgs'];
        };
      };
    };
  };
  '/webhooks/{uuid}': {
    /** Retrieve a webhook given its UUID. */
    get: {
      parameters: {
        path: {
          uuid: string;
        };
      };
      responses: {
        /** OK */
        200: {
          content: {
            'application/json': components['schemas']['Webhook'];
          };
        };
        default: components['responses']['DEFAULT_ERROR'];
      };
    };
    /** Delete and unregister a webhook URL given its UUID. */
    delete: {
      parameters: {
        path: {
          uuid: string;
        };
      };
      responses: {
        /** No Content */
        204: never;
        default: components['responses']['DEFAULT_ERROR'];
      };
    };
    parameters: {
      path: {
        uuid: string;
      };
    };
  };
  '/credits/grant/': {
    /** Returns all the credit grants under your account. */
    get: {
      responses: {
        /** OK */
        200: {
          content: {
            'application/json': components['schemas']['ListCreditGrants'];
          };
        };
        422: components['responses']['UNPROCESSABLE_ENTITY'];
        default: components['responses']['DEFAULT_ERROR'];
      };
      requestBody: {
        content: {
          'application/json': components['schemas']['ListCreditGrantsArgs'];
        };
      };
    };
    /** Creates a credit grant for one of your customers. */
    post: {
      responses: {
        /** OK */
        200: {
          content: {
            'application/json': components['schemas']['CreditGrant'];
          };
        };
        422: components['responses']['UNPROCESSABLE_ENTITY'];
        default: components['responses']['DEFAULT_ERROR'];
      };
      requestBody: {
        content: {
          'application/json': components['schemas']['CreateCreditGrantArgs'];
        };
      };
    };
  };
  '/credits/grant/{grant_uuid}/void': {
    /** Deactivates a credit grant with the given grant UUID. */
    post: {
      parameters: {
        path: {
          grant_uuid: string;
        };
      };
      responses: {
        /** OK */
        200: unknown;
        default: components['responses']['DEFAULT_ERROR'];
      };
    };
    parameters: {
      path: {
        grant_uuid: string;
      };
    };
  };
  '/credits/ledger/{customer_name}/{as_of_str}': {
    /** Returns the credit ledger for one of your customers. */
    get: {
      parameters: {
        path: {
          as_of_str: string;
          customer_name: string;
        };
      };
      responses: {
        /** OK */
        200: {
          content: {
            'application/json': components['schemas']['CreditLedger'][];
          };
        };
        default: components['responses']['DEFAULT_ERROR'];
      };
    };
    parameters: {
      path: {
        as_of_str: string;
        customer_name: string;
      };
    };
  };
  '/credits/ledger/{customer_name}/': {
    /** Returns the credit ledger for one of your customers. */
    get: {
      parameters: {
        path: {
          customer_name: string;
        };
      };
      responses: {
        /** OK */
        200: {
          content: {
            'application/json': components['schemas']['CreditLedger'][];
          };
        };
        default: components['responses']['DEFAULT_ERROR'];
      };
    };
    parameters: {
      path: {
        customer_name: string;
      };
    };
  };
  '/admin/api_key/roll': {
    /** Expires the specified API key and creates a new one. */
    post: {
      responses: {
        /** OK */
        200: {
          content: {
            'application/json': components['schemas']['RollApiKeys'];
          };
        };
        422: components['responses']['UNPROCESSABLE_ENTITY'];
        default: components['responses']['DEFAULT_ERROR'];
      };
      requestBody: {
        content: {
          'application/json': components['schemas']['RollApiKeyArgs'];
        };
      };
    };
  };
  '/self_serve_settings/': {
    /** Get self serve settings for a vendor. */
    get: {
      responses: {
        /** OK */
        200: {
          content: {
            'application/json': components['schemas']['SelfServeSettings'];
          };
        };
        default: components['responses']['DEFAULT_ERROR'];
      };
    };
    /**
     * Update the self serve settings for a vendor. If partial fields
     * are given, we will only update the provided fields.
     */
    put: {
      responses: {
        /** OK */
        200: {
          content: {
            'application/json': components['schemas']['SelfServeSettings'];
          };
        };
        422: components['responses']['UNPROCESSABLE_ENTITY'];
        default: components['responses']['DEFAULT_ERROR'];
      };
      requestBody: {
        content: {
          'application/json': components['schemas']['UpdateSelfServeSettingsArgs'];
        };
      };
    };
    /**
     * Create the self serve settings for a vendor. If partial fields
     * are given, we will fallback on default values.
     */
    post: {
      responses: {
        /** OK */
        200: {
          content: {
            'application/json': components['schemas']['SelfServeSettings'];
          };
        };
        422: components['responses']['UNPROCESSABLE_ENTITY'];
        default: components['responses']['DEFAULT_ERROR'];
      };
      requestBody: {
        content: {
          'application/json': components['schemas']['UpdateSelfServeSettingsArgs'];
        };
      };
    };
  };
  '/self_serve_settings/customization': {
    /** Get the customization settings for the vendor's customer portal. */
    get: {
      responses: {
        /** OK */
        200: {
          content: {
            'application/json': components['schemas']['SelfServeCustomization'];
          };
        };
        default: components['responses']['DEFAULT_ERROR'];
      };
    };
    /** Update the customization settings for the vendor's customer portal. */
    put: {
      responses: {
        /** OK */
        200: {
          content: {
            'application/json': components['schemas']['SelfServeCustomization'];
          };
        };
        422: components['responses']['UNPROCESSABLE_ENTITY'];
        default: components['responses']['DEFAULT_ERROR'];
      };
      requestBody: {
        content: {
          'application/json': components['schemas']['SelfServeCustomization'];
        };
      };
    };
    /** Create the customization settings for the vendor's customer portal. */
    post: {
      responses: {
        /** OK */
        200: {
          content: {
            'application/json': components['schemas']['SelfServeCustomization'];
          };
        };
        422: components['responses']['UNPROCESSABLE_ENTITY'];
        default: components['responses']['DEFAULT_ERROR'];
      };
      requestBody: {
        content: {
          'application/json': components['schemas']['SelfServeCustomization'];
        };
      };
    };
  };
  '/integration/tax/avalara/settings': {
    /** Returns the vendor Avalara settings. */
    get: {
      responses: {
        /** OK */
        200: {
          content: {
            'application/json': components['schemas']['VendorAvalaraSettings'];
          };
        };
        default: components['responses']['DEFAULT_ERROR'];
      };
    };
    /** Updates the Avalara settings for you vendor. */
    put: {
      responses: {
        /** OK */
        200: {
          content: {
            'application/json': components['schemas']['VendorAvalaraSettings'];
          };
        };
        422: components['responses']['UNPROCESSABLE_ENTITY'];
        default: components['responses']['DEFAULT_ERROR'];
      };
      requestBody: {
        content: {
          'application/json': components['schemas']['UpdateVendorAvalaraSettingsArgs'];
        };
      };
    };
    /** Creates the Avalara settings for you vendor. */
    post: {
      responses: {
        /** OK */
        200: {
          content: {
            'application/json': components['schemas']['VendorAvalaraSettings'];
          };
        };
        422: components['responses']['UNPROCESSABLE_ENTITY'];
        default: components['responses']['DEFAULT_ERROR'];
      };
      requestBody: {
        content: {
          'application/json': components['schemas']['CreateVendorAvalaraSettingsArgs'];
        };
      };
    };
  };
  '/integration/tax/avalara/credentials/valid': {
    /** Validates the Avalara credentials for you vendor. */
    post: {
      responses: {
        /** OK */
        200: {
          content: {
            'application/json': components['schemas']['ValidateCredentialsResp'];
          };
        };
        422: components['responses']['UNPROCESSABLE_ENTITY'];
        default: components['responses']['DEFAULT_ERROR'];
      };
      requestBody: {
        content: {
          'application/json': components['schemas']['ValidateCredentialsArgs'];
        };
      };
    };
  };
  '/integration/tax/avalara/tax_code': {
    /** Lists the Avalara Tax codes associated for a specific company. */
    get: {
      responses: {
        /** OK */
        200: {
          content: {
            'application/json': components['schemas']['TaxCode'][];
          };
        };
        default: components['responses']['DEFAULT_ERROR'];
      };
    };
  };
  '/integration/tax/avalara/company': {
    /** Lists the companies found in your Avalara account. */
    get: {
      responses: {
        /** OK */
        200: {
          content: {
            'application/json': components['schemas']['Company'][];
          };
        };
        default: components['responses']['DEFAULT_ERROR'];
      };
    };
  };
  '/integration/tax/avalara/entity_use_code': {
    /** Lists the entity codes available in avalara. */
    get: {
      responses: {
        /** OK */
        200: {
          content: {
            'application/json': components['schemas']['EntityUseCode'][];
          };
        };
        default: components['responses']['DEFAULT_ERROR'];
      };
    };
  };
  '/recognized_revenue/': {
    /** Compute monthly recognized revenue */
    post: {
      responses: {
        /** OK */
        200: {
          content: {
            'application/json': components['schemas']['RevenueRecognitionEntry'][];
          };
        };
        422: components['responses']['UNPROCESSABLE_ENTITY'];
        default: components['responses']['DEFAULT_ERROR'];
      };
      requestBody: {
        content: {
          'application/json': components['schemas']['RevenueRecognitionInput'];
        };
      };
    };
  };
  '/features/': {
    /** Gets all existing features for a specific vendor. */
    get: {
      responses: {
        /** OK */
        200: {
          content: {
            'application/json': components['schemas']['Feature'][];
          };
        };
        default: components['responses']['DEFAULT_ERROR'];
      };
    };
  };
}

export interface components {
  schemas: {
    Error: {
      /** Error name */
      status?: string;
      /** Error code */
      code?: number;
      /** Error message */
      message?: string;
      /** Errors */
      errors?: { [key: string]: unknown };
    };
    Meter: {
      /** Unique name identifier */
      name: string;
      /** Name used for display in UI */
      display_name?: string;
      description?: string | null;
      /** Name of the event associated with this meter */
      event_name: string;
      /** One of `COUNTER`, `GAUGE`. */
      meter_type: string;
      /** One of `CONTINUOUS`, `DISCRETE`. */
      data_type: string;
      /** The aggregation applied to the measurement values. One of `TIME_WEIGHTED_SUM`, `MAX`, `SUM`. */
      aggregation: string;
      /** The reporting unit for the meter */
      unit_name?: string | null;
      /** Whether measurement values are to be considered incremental (versus a running total) */
      is_incremental: boolean;
      /** Whether measurement values are to be considered to be the incremental change or the running total. One of `DELTA`, `TOTAL`. */
      reporting_method: string;
      expected_labels?: unknown[];
      primary_labels?: unknown[];
    };
    CreateMeterArgs: {
      /** DEPRECATED: List of expected label keys */
      expected_labels?: string[];
      /** COMING SOON: We are replacing meter_type with data_type and aggregation fields to allow more flexible metering. The aggregation type to apply to measurements. One of `TIME_WEIGHTED_SUM`, `MAX`, `SUM`. */
      aggregation?:
        | 'SUM'
        | 'MAX'
        | 'MIN'
        | 'AVG'
        | 'COUNT'
        | 'TIME_WEIGHTED_SUM'
        | 'LATEST';
      /** COMING SOON: We are replacing is_incremental with reporting_method field. Whether measurement values are reporting the incremental change or the total. One of `DELTA`, `TOTAL`. */
      reporting_method?: 'DELTA' | 'TOTAL';
      /** Unique name identifier */
      name?: string;
      /** Name of the events to associate with this meter. Defaults to meter name. */
      event_name?: string;
      /** COMING SOON: We are replacing meter_type with data_type and aggregation fields to allow more flexible metering. The type of data represented by the meter. One of `CONTINUOUS`, `DISCRETE`. */
      data_type?: 'CONTINUOUS' | 'DISCRETE';
      /** The unit that the measurement values are reported in. */
      unit_name?: string;
      /** Type of meter. One of `COUNTER`, `GAUGE` */
      meter_type?: 'COUNTER' | 'GAUGE';
      /** Description of the meter */
      description?: string;
      /** List of primary label keys */
      primary_labels?: string[];
      /** Whether measurement values are to be considered to be the incremental change or the total. */
      is_incremental?: boolean;
      /** Human-friendly name used for display in UI */
      display_name?: string;
    };
    UpdateMeterArgs: {
      description?: string;
      display_name?: string;
    };
    Measurement: {
      /** The name of the customer to associate the measurement with. */
      customer_name?: string;
      /** Applies to incremental meters and resets the total current value to this new value. */
      reset_total?: boolean;
      /** The name of the event associated with this measurement. Events allow for a 1 to many relationship between measurement and meters. */
      event_name?: string;
      /** All times are parsed as `ISO-8601` formatted, UTC-based timestamps */
      time?: string;
      /** A set of key:value label pairs to supplement a measurement. Each meter defines its own set of primary and/or expected labels. */
      labels?: { [key: string]: string };
      /** The raw value of the measurement */
      value: number;
      /** An ID that is unique for the set of labels and meter_name */
      id?: string;
      /** The unique name of the meter associated with this measurement */
      meter_name?: string;
    };
    ContactInfo: {
      address_line_1?: string | null;
      address_line_2?: string | null;
      city?: string | null;
      state?: string | null;
      country?: string | null;
      zipcode?: string | null;
      url?: string | null;
      logo_url?: string | null;
      email?: string | null;
      secondary_emails?: string | null;
      phone?: string | null;
      legal_name?: string | null;
      vat_id?: string | null;
    };
    CustomerTag: {
      /** Supplementary tag that is associated with a customer */
      tag: string;
    };
    Customer: {
      /** Unique name identifier of a customer */
      name: string;
      display_name?: string;
      contact_info?: components['schemas']['ContactInfo'] | null;
      created_at?: string;
      measurement_mappings?: unknown[];
      tags?: components['schemas']['CustomerTag'][];
    };
    CustomerMetadataInput: {
      property?: string;
      value?: string | null;
    };
    CustomerMeasurementMappingInputArgs: {
      /** A regex used to match the value of the associated label key. */
      value_regex: string;
      /** The label key used to map measurements to customers. */
      label: string;
    };
    ContactInfoInputArgs: {
      city?: string | null;
      phone?: string | null;
      zipcode?: string | null;
      country?: string | null;
      /** List of secondary contact emails (all email communication will also be sent to these emails). */
      secondary_emails?: string[] | null;
      address_line_1?: string | null;
      address_line_2?: string | null;
      logo_url?: string | null;
      vat_id?: string | null;
      url?: string | null;
      state?: string | null;
      email?: string | null;
      legal_name?: string | null;
    };
    CreateCustomerArgs: {
      customer_metadata?: components['schemas']['CustomerMetadataInput'][];
      measurement_mappings?: components['schemas']['CustomerMeasurementMappingInputArgs'][];
      price_plan_name?: string;
      autogenerate_accounting_customer?: boolean;
      price_plan_tag?: string;
      name?: string;
      created_at?: string;
      autogenerate_payment_gateway_customer?: boolean;
      contact_info?: components['schemas']['ContactInfoInputArgs'];
      vendor_id?: number;
      display_name?: string;
      tags?: string[] | null;
    };
    UpdateCustomerArgs: {
      measurement_mappings?: components['schemas']['CustomerMeasurementMappingInputArgs'][];
      name?: string;
      created_at?: string;
      contact_info?: components['schemas']['ContactInfoInputArgs'];
      vendor_id?: number;
      display_name?: string;
      tags?: string[] | null;
    };
    CustomerMeasurementMapping: {
      /** The label key used to map measurements to customers. */
      label: string;
      /** A regex used to match the value of the associated label key. */
      value_regex?: string | null;
    };
    CustomerPaymentMethodStatus: {
      /** The status of the customer's current payment method. Can be one of: NO_PAYMENT_GATEWAY_CREDENTIAL, NO_PAYMENT_METHOD, EXPIRED_PAYMENT_METHOD, VALID_PAYMENT_METHOD */
      status?: string;
    };
    PaymentGatewayCredential: {
      payment_gateway?: unknown;
      /** Payment gateway account id associated with customer */
      account_id: string;
      /** Unique name identifier of a customer */
      auth_token?: string | null;
    };
    CustomerPaymentGatewayCredentialInputArgs: {
      account_id?: string;
    };
    BillingSettings: {
      /** Time length of the grace period between the end of a billing cycle and invoice generation in days. */
      invoice_grace_period_length?: number | null;
      /** Time length unit of the grace period between the end of a billing cycle and invoice generation. Must be `day`. */
      invoice_grace_period_unit?: string | null;
      /** Time length of the grace period between the end of invoice generation and the actual charge. *NOTE*: The specified length is unitless. Unit is designated with the `payment_grace_period_unit` field. */
      payment_grace_period_length?: number | null;
      /** Time length unit of the grace period between the end of invoice generation and actual charge. One of `minute`, `hour`, `day`. */
      payment_grace_period_unit?: string | null;
      /** Flag that controls whether or not invoices should be sent to customers. */
      should_send_invoice_to_customers?: boolean | null;
      /** Flag that controls whether to invoice through Octane or through payment provider */
      invoice_via_octane?: boolean | null;
      /** Flag that controls whether invoices are auto-approved or require manual approval */
      auto_approve_invoices?: boolean | null;
      customer_invoice_detail_level?: unknown;
      /** Flag that controls whether or not to auto-charge the customer based on the invoice. */
      charges_enabled?: boolean | null;
      /** Flag that controls whether or not to invoice/charge the base rate, add ons and other fixed price plan components at the beginning of the billing cycle. */
      invoice_fixed_components_at_start?: boolean | null;
      /** Flag that controls the number of retry attempts for invoicing/payments. */
      retry_attempts?: number | null;
      /** Time length after which to attempt invoice/payment retry. */
      retry_frequency_length?: number | null;
      /** Time length unit after which to attempt invoice/payment retry. */
      retry_frequency_unit?: string | null;
      /** The percentage tax rate to apply to invoices. */
      tax_rate?: number | null;
      /** Flag that controls whether to do automated taxes via payment provider */
      tax_via_payment_provider?: boolean | null;
      /** Flag that controls whether or not to invoice/charge gauge meters upfront according to their value at start of cycle. Only applies if invoice_fixed_components_at_start is enabled. */
      invoice_metered_components_at_start?: boolean | null;
      /** Flag that controls whether or not to invoice/charge a true up for a billing cycle on the following invoice. Only applies if invoice_fixed_components_at_start is enabled. */
      invoice_overages?: boolean | null;
      /** Optional description attached to the invoice */
      invoice_memo?: string | null;
      /** Sets the due date on invoices to the number of days after the invoice is sent */
      days_until_due?: number | null;
      /** If using stripe, this field can be used to configure whether invoices should be auto advanced for collection */
      stripe_auto_advance?: boolean | null;
      /** Default value for whether to align billing cycles to calendar on subscriptions */
      align_billing_cycles_to_calendar?: boolean | null;
      /** Optional url of a custom image to include on invoices. */
      invoice_logo_url?: string | null;
      /** Flag determining whether ACH/Wire instructions should be included on invoices. */
      include_ach_instructions?: boolean | null;
      /** Account name for ACH/Wire transfer instructions */
      ach_account_name?: string | null;
      /** ABA/Routing number for ACH/Wire transfer instructions */
      ach_routing_number?: string | null;
      /** Account number for ACH/Wire transfer instructions */
      ach_account_number?: string | null;
      /** Swift code for ACH/Wire transfer instructions */
      ach_swift_code?: string | null;
      /** Bank name for ACH/Wire transfer instructions */
      ach_bank_name?: string | null;
      /** First line of bank address for ACH/Wire transfer instructions */
      ach_bank_address_1?: string | null;
      /** Second line of bank address for ACH/Wire transfer instructions */
      ach_bank_address_2?: string | null;
      /** True if customer updates should be synced to Stripe. */
      sync_customer_data_to_payment_gateway?: boolean | null;
      /** If using Stripe, this field can be used to configure whether invoices should be finalized immediately when they are created. */
      stripe_immediate_finalization?: boolean | null;
      /** If set, we will use this template id for our emails instead of our default one */
      alternate_sendgrid_template_id?: string | null;
      /** If set, a minimum charge line item will override any line items that contribute to the minimum (i.e., the minimum charge line item would be the only line item). */
      should_minimum_charge_override_line_items?: boolean | null;
    };
    CustomerBillingSettingsInputArgs: {
      /** Swift code for ACH/Wire transfer instructions */
      ach_swift_code?: string | null;
      /** Flag that controls whether or not invoices should be sent to customers. */
      should_send_invoice_to_customers?: boolean | null;
      /** Flag that controls whether or not to invoice/charge a true up for a billing cycle on the following invoice. Only applies if invoice_fixed_components_at_start is enabled. */
      invoice_overages?: boolean | null;
      /** The percentage tax rate to apply to invoices. */
      tax_rate?: number | null;
      /** Bank name for ACH/Wire transfer instructions */
      ach_bank_name?: string | null;
      /** Flag determining whether ACH/Wire instructions should be included on invoices. */
      include_ach_instructions?: boolean | null;
      /** Optional description attached to the invoice */
      invoice_memo?: string | null;
      /** Account number for ACH/Wire transfer instructions */
      ach_account_number?: string | null;
      /** Default value for whether to align billing cycles to calendar on subscriptions */
      align_billing_cycles_to_calendar?: boolean | null;
      /** Flag that controls whether to do automated taxes via payment provider */
      tax_via_payment_provider?: boolean | null;
      /** Time length of the grace period between the end of a billing cycle and invoice generation in days. */
      invoice_grace_period_length?: number | null;
      /** Flag that controls whether to invoice through Octane or through payment provider */
      invoice_via_octane?: boolean | null;
      /** True if customer updates should be synced to Stripe. */
      sync_customer_data_to_payment_gateway?: boolean | null;
      /** Flag that controls the number of retry attempts for invoicing/payments. */
      retry_attempts?: number | null;
      /** If using stripe, this field can be used to configure whether invoices should be auto advanced for collection */
      stripe_auto_advance?: boolean | null;
      /** Account name for ACH/Wire transfer instructions */
      ach_account_name?: string | null;
      /** Sets the due date on invoices to the number of days after the invoice is sent */
      days_until_due?: number | null;
      /** Time length of the grace period between the end of invoice generation and the actual charge. *NOTE*: The specified length is unitless. Unit is designated with the `payment_grace_period_unit` field. */
      payment_grace_period_length?: number | null;
      /** Optional url of a custom image to include on invoices. */
      invoice_logo_url?: string | null;
      customer_invoice_detail_level?: string;
      /** Flag that controls whether or not to auto-charge the customer based on the invoice. */
      charges_enabled?: boolean | null;
      /** Flag that controls whether or not to invoice/charge gauge meters upfront according to their value at start of cycle. Only applies if invoice_fixed_components_at_start is enabled. */
      invoice_metered_components_at_start?: boolean | null;
      /** Time length unit of the grace period between the end of a billing cycle and invoice generation. Must be `day`. */
      invoice_grace_period_unit?: 'day' | null;
      /** Second line of bank address for ACH/Wire transfer instructions */
      ach_bank_address_2?: string | null;
      /** Flag that controls whether invoices are auto-approved or require manual approval */
      auto_approve_invoices?: boolean | null;
      /** If set, a minimum charge line item will override any line items that contribute to the minimum (i.e., the minimum charge line item would be the only line item). */
      should_minimum_charge_override_line_items?: boolean | null;
      /** Flag that controls whether or not to invoice/charge the base rate, add ons and other fixed price plan components at the beginning of the billing cycle. */
      invoice_fixed_components_at_start?: boolean | null;
      /** Time length after which to attempt invoice/payment retry. */
      retry_frequency_length?: number | null;
      /** First line of bank address for ACH/Wire transfer instructions */
      ach_bank_address_1?: string | null;
      /** ABA/Routing number for ACH/Wire transfer instructions */
      ach_routing_number?: string | null;
      /** Time length unit of the grace period between the end of invoice generation and actual charge. One of `minute`, `hour`, `day`. */
      payment_grace_period_unit?: string | null;
      /** If using Stripe, this field can be used to configure whether invoices should be finalized immediately when they are created. */
      stripe_immediate_finalization?: boolean | null;
      /** Time length unit after which to attempt invoice/payment retry. */
      retry_frequency_unit?: string | null;
    };
    RevenueResponse: {
      revenue?: number;
    };
    CustomerStatus: {
      status?: string;
    };
    CustomerUsage: {
      usage?: number;
    };
    CustomerLabelLimit: {
      labels?: { [key: string]: string };
      limit?: number;
    };
    CustomerFeature: {
      enabled?: boolean;
      limit?: number;
      feature_name?: string;
      label_limits?: components['schemas']['CustomerLabelLimit'][];
      quantity?: number;
    };
    LineItems: {
      price?: string;
      start_time?: string;
      price_int?: number;
      end_time?: string;
      name?: string;
      description?: string;
      metadata?: { [key: string]: string };
      id?: string;
      quantity_unit?: string;
      quantity?: number;
    };
    RevenueBreakdown: {
      total_revenue?: number;
      line_items?: components['schemas']['LineItems'][];
    };
    AccruedRevenueLineItem: {
      /**
       * The identifier of the item being returned.
       *         For metered component will be meter name,
       *         for add_ons will be feature name,
       *         for base price will be price plan name,
       *         for minimum charge will be price plan name,
       *         for metered component minimum charge will be meter name
       */
      item_identifier?: string;
      /** Accrued revenue for this line item in cents */
      revenue?: number;
      /** Type of item. One of: METERED_COMPONENT, BASE_PRICE, DISCOUNT, ADD_ON, MINIMUM_CHARGE, METERED_COMPONENT_MINIMUM_CHARGE */
      item_type?: string;
      /**
       * Any extra metadata associated with the item.
       *         Will include the labels for metered components and metered component minimum charges when applicable
       */
      metadata?: { [key: string]: string };
    };
    AccruedRevenue: {
      /** Total accrued revenue for the period in cents */
      total_accrued_revenue?: number;
      /** The cycle start of the billing cycle for which the accrued revenue is computed */
      start_time?: string;
      /** The end time within the billing cycle for which this accrued revenue is computed */
      end_time?: string;
      line_items?: components['schemas']['AccruedRevenueLineItem'][];
    };
    DailyAccruedRevenue: {
      /** The date for which this accrued revenue is computed */
      date?: string;
      /** The start time of the billing cycle for which the accrued revenue is computed */
      start_time?: string;
      /** The end time till when the accured revenue is computed */
      end_time?: string;
      line_items?: components['schemas']['AccruedRevenueLineItem'][];
      /** Total accrued revenue for the day in cents */
      total_accrued_revenue?: number;
    };
    CustomerMetadata: {
      /** Property name */
      property?: string;
      /** Value of property for customer */
      value?: string;
    };
    Invoice: {
      /** Earliest start time of line items covered by the invoice */
      min_item_start_time?: string;
      /** [DEPRECATED] Start time of the cycle in which the invoice was generated */
      start_time?: string;
      line_items?: components['schemas']['LineItems'][];
      /** External unique 'uuid' identifier for this Invoice. */
      id?: string;
      /** If there is an error processing this invoice, this field contains the error message. */
      status_error?: string;
      pdf_url?: string;
      /** Name of the customer this invoice is for. */
      customer_name?: string;
      /** Non-empty string if there was an error while sending out invoice */
      invoicing_error?: string;
      latest_payment_attempt_at?: string;
      /** The date the invoice will be issued to the end customer or forwarded to the payment processor. */
      issue_date?: string;
      /** The number of retries done to send the invoice */
      invoice_retry_attempt?: number;
      /** The potentially permanent state this invoice can live in (e.g., ISSUED if the invoice has been issued to the customer) */
      status?: string;
      /** False if not approved */
      is_approved?: boolean;
      /** The number of retries done to process the payment */
      payment_retry_attempt?: number;
      /** [DEPRECATED] End time of the cycle in which the invoice was generated */
      end_time?: string;
      /** Total amount due */
      amount_due?: number;
      /** Amount due before any credits are applied */
      sub_total?: number;
      /** Latest end time of line items covered by the invoice */
      max_item_end_time?: string;
      /** Tax amount applied to subtotal */
      tax_amount?: number;
      /** False if invoice has not been sent to the customer */
      is_invoiced?: boolean;
      latest_invoice_attempt_at?: string;
      /** False if not paid yet */
      is_paid?: boolean;
      /** Non-empty string if there was an error while processing payment */
      payment_error?: string;
      /** Any discount credits applied to the invoice */
      discount_credit?: number;
      due_date?: string;
    };
    CreditTopOffPlan: {
      /** Unique identifier of this top off plan. */
      uuid?: string;
      /** The threshold in amount of credits at which the balance will be topped off. */
      trigger_amount: number;
      /** Amount of credits that are granted in a single top off. */
      grant_amount: number;
      /** Price for the grant, in lowest denomination (i.e cents). */
      price: number;
      /** Time length of the default expiration for credits granted in a top off. */
      expiration_length?: number | null;
      /** Time length unit for the default expiration for credits granted in a top off. */
      expiration_unit?: string | null;
      /** A description that will be used on the invoice line items. */
      description?: string | null;
    };
    CreateCreditTopOffPlanInputArgs: {
      /** Time length unit for the default expiration for credits granted in a top off. */
      expiration_unit?: string;
      /** Amount of credits that are granted in a single top off. */
      grant_amount: number;
      /** A description that will be used on the invoice line items. */
      description?: string | null;
      /** Price for the grant, in lowest denomination (i.e cents). */
      price: number;
      /** Time length of the default expiration for credits granted in a top off. */
      expiration_length?: number;
      /** The threshold in amount of credits at which the balance will be topped off. */
      trigger_amount: number;
    };
    UpdateCreditTopOffPlanInputArgs: {
      /** Time length unit for the default expiration for credits granted in a top off. */
      expiration_unit?: string;
      /** Amount of credits that are granted in a single top off. */
      grant_amount?: number;
      /** A description that will be used on the invoice line items. */
      description?: string | null;
      /** Price for the grant, in lowest denomination (i.e cents). */
      price?: number;
      /** Time length of the default expiration for credits granted in a top off. */
      expiration_length?: number;
      /** The threshold in amount of credits at which the balance will be topped off. */
      trigger_amount?: number;
    };
    AccountingCustomer: {
      /** ID of the customer in the target accounting platform */
      accounting_customer_id?: string;
    };
    CustomerAvalaraSettings: {
      /** Entity code describing this customer. */
      entity_use_code?: string;
      /** Tax exemption number specific to this customer */
      exemption_number?: string;
      /** True if Avalara integration should be enabled for this customer, False otherwise. */
      enable_integration?: boolean;
    };
    UpdateCustomerAvalaraSettingsArgs: {
      /** Entity code describing this customer. */
      entity_use_code?: string;
      /** Tax exemption number specific to this customer */
      exemption_number?: string;
      /** True if Avalara integration should be enabled for this customer, False otherwise. */
      enable_integration?: boolean;
    };
    ValidateAddressResp: {
      /** Set if 'success' is True. The resolution quality of the geospatial coordinates. */
      resolution_quality?: string;
      /** Set if 'sucess' is True. Geospatial latitude measurement, in Decimal Degrees (string). */
      longitude?: string;
      /** Set if 'success' is False. Contains the details of why the address is invalid. */
      invalid_address_error?: string;
      /** True if validation was successful, False address is invalid. */
      success?: boolean;
      /** Set if 'success' is True. Geospatial latitude measurement, in Decimal Degrees (string). */
      latitude?: string;
    };
    PriceTier: {
      /** Cap of the tier, meaning that any subsequent usage will be bucketed into the following tier. If cap is undefined, it is effectively treated as Infinity. */
      cap?: number;
      /** The price (in lowest currency denomination by which to charge, given that the usage is within the cap range. */
      price: number;
      /** The line item description to use if usage falls in this tier. */
      description?: string;
    };
    PriceScheme: {
      display_name?: string | null;
      name?: string | null;
      scheme_type?: unknown;
      /** Size of the unit batch to use for the prices. Can only be set if scheme_type='FLAT' or 'TIERED'. E.g. To charge $10 per 100 API Requests, set batch_size to 100. */
      batch_size?: number | null;
      /** Array of price tiers, each of which consists of `price` and `cap` key:value pairs */
      prices?: components['schemas']['PriceTier'][];
      /** Array of (key, value) meter labels to price on & the price tiers that should be used against those labels */
      price_list?: { [key: string]: unknown }[];
      time_unit_name?: string | null;
      unit_name?: string | null;
      /** The % increase/decrease in price after the minimum charge is reached. */
      post_minimum_charge_percentage_change?: number | null;
    };
    MeteredComponentLabelLimit: {
      /** Dictionary of labels (key: value) to which the limit applies. A value of 'any' will apply the limit to any single value of the field. */
      labels: unknown;
      /** Numeric limit set on the labels. */
      limit: number;
    };
    MeteredComponent: {
      meter_name: string;
      meter_display_name: string;
      price_scheme: components['schemas']['PriceScheme'];
      /** Limit on the usage for the meter. */
      limit?: number | null;
      label_limits: components['schemas']['MeteredComponentLabelLimit'][];
      /** Name to be used on invoice. */
      display_name?: string | null;
      /** External facing unique identifier of a metered component */
      external_uuid?: string;
      /** Minimum charge for the metered component */
      minimum_charge?: number | null;
      /** Minimum charge frequency (as a multiple of the price plan period) for the metered component */
      minimum_charge_frequency?: number | null;
    };
    Feature: {
      description?: string | null;
      /** Unique name of a feature */
      name: string;
      display_name?: string;
    };
    AddOn: {
      feature: components['schemas']['Feature'];
      /** Price of the add on */
      price: number;
      /** If true, customer is just charged once in the first billing cycle. */
      single_use: boolean;
      quantity_enabled: boolean;
      /** If true, immediately invoice the customer for this add on. */
      immediately_charge?: boolean;
      /** The maximum number of add-ons that an end-customer can apply to their subscription. */
      limit?: number;
    };
    Limit: {
      feature: components['schemas']['Feature'];
      /** Limit on feature */
      limit: number;
    };
    PricePlanTag: {
      /** Supplementary tag label that is associated with a specific version of a price plan */
      tag: string;
    };
    Trial: {
      time_length?: number | null;
      time_unit_name?: string | null;
      credit?: number | null;
    };
    PricePlan: {
      /** External facing unique identifier of a price plan */
      external_uuid?: string;
      /** Unique name indentifier of a price plan */
      name: string;
      /** UI-friendly name used for data display. Defaults to `name`. */
      display_name?: string;
      description?: string | null;
      /** Lowest denomination of currency. e.g. USD is represented as cents. */
      base_price?: number | null;
      base_price_frequency?: number | null;
      /** Custom invoice description for the base price line item. */
      base_price_description?: string | null;
      /** Time period that defines the length of a price plan cycle. One of `month`, `quarter`, or `year`. */
      period: string;
      metered_components: components['schemas']['MeteredComponent'][];
      /** Minimum amount to charge every 'period' */
      minimum_charge?: number | null;
      /** The frequency (as a an integer multiple of the period) at which to charge the minimum charge. */
      minimum_charge_frequency?: number | null;
      features?: components['schemas']['Feature'][];
      add_ons?: components['schemas']['AddOn'][];
      limits?: components['schemas']['Limit'][];
      tags?: components['schemas']['PricePlanTag'][];
      trial?: components['schemas']['Trial'];
      /** ISO-8601 formatted creation timestamp of price plan version */
      created_at?: string;
    };
    Discount: {
      discount_type?: unknown;
      amount?: number | null;
      /** The date when the discount is applied from. */
      start_date?: string | null;
      /** The date when the discount ends. */
      end_date?: string | null;
      /** Offset in number of billing cycles for when this discount will apply. For example, if set to 1, the discount will apply from the start of the next billing cycle. */
      billing_cycle_start_offset?: number;
      /** Duration of this discount in number of billing cycles. */
      billing_cycle_duration?: number | null;
      /** The id of coupon associated with this discount, none if discount does not originate from coupon */
      coupon_id?: number | null;
      /** External facing unique identifier of a price plan */
      external_uuid?: string;
      /** The scope that this discount covers. One of 'INVOICE_TOTAL', 'ADD_ON', 'METERED_COMPONENT'. */
      scope: string;
      /** Add-on this discount covers if scope is ADD_ON. */
      add_on?: components['schemas']['AddOn'];
      /** Metered Component this discount covers if scope is METERED_COMPONENT. */
      metered_component?: components['schemas']['MeteredComponent'];
      /** Dictionary of labels (key: value) to which the discount applies if scope is METERED_COMPONENT. */
      labels?: { [key: string]: string };
    };
    Subscription: {
      uuid: string;
      /** Unique name identifier of a customer */
      customer_name: unknown;
      /** Unique name indentifier of a price plan */
      price_plan_name: unknown;
      /** External facing unique identifier of a price plan */
      price_plan_uuid: unknown;
      /** Price plan associated with this subscription. */
      price_plan?: components['schemas']['PricePlan'];
      /** Align billing cycles to a calendar unit if true. For example if the period is month, cycles will end on the first of every month. */
      align_to_calendar?: boolean;
      discounts?: (components['schemas']['Discount'] | null)[];
      add_ons?: unknown;
      /** Optional trial override for the associated subscription. */
      trial_override?: components['schemas']['Trial'];
      /** Optional base price override for the associated subscription. */
      base_price_override?: number | null;
      features_override?: components['schemas']['Feature'][];
      limits_override?: components['schemas']['Limit'][];
      /** ISO-8601 formatted timestamp that defines when the subscription should take effect. If this field is omitted, the subscription is effective upon creation. */
      effective_at?: string;
      /** ISO-8601 formatted timestamp that defines when the subscription will expire. */
      expired_at?: string | null;
    };
    TrialInputArgs: {
      time_length?: number;
      time_unit_name?: string;
      credit?: number;
    };
    FeatureInputArgs: {
      description?: string;
      display_name?: string;
      name: string;
    };
    LimitInputArgs: {
      feature: components['schemas']['FeatureInputArgs'];
      limit?: number;
    };
    SubscriptionAddOnInput: {
      /** Override for the add-on price on this subscription. */
      price?: number;
      quantity?: number;
      name: string;
    };
    DiscountInputArgs: {
      amount?: number;
      discount_type?: 'FLAT' | 'PERCENT';
      /** Length, in billing cycles, that this discount will be active. */
      billing_cycle_duration?: number;
      /** Offset, in number of billing cycles, for when this discount will apply. If set to 0, the discount will start applying from the current billing cycle. If set to 1, the discount will start applying from the next billing cycle, etc. For scheduled subscriptions, the offset starts from the initial billing cycle. */
      billing_cycle_start_offset?: number;
      /** For METERED_COMPONENT scoped discounts: the UUID of the metered component that the discount covers. */
      metered_component_uuid?: string;
      /** For METERED_COMPONENT scoped discounts: Dictionary of labels (key: value) that the discount covers. The entire set of labels must be provided. */
      labels?: { [key: string]: string };
      /** For ADD_ON scoped discounts: the name of the add on that the discount covers. */
      add_on_name?: string;
      /** The scope that this discount covers. One of 'INVOICE_TOTAL', 'ADD_ON', 'METERED_COMPONENT'. */
      scope?: 'INVOICE_TOTAL' | 'ADD_ON' | 'METERED_COMPONENT';
    };
    CreateSubscriptionArgs: {
      trial_override?: components['schemas']['TrialInputArgs'];
      coupon_override_name?: string;
      limits_override?: components['schemas']['LimitInputArgs'][];
      add_ons?: components['schemas']['SubscriptionAddOnInput'][];
      /** The tag of the specific price plan version for the given price_plan_name. Should only be set if identifying price plan by name. */
      price_plan_tag?: string;
      /** The UUID of the specific price plan version to subscribe customer to. Either provide price plan UUID or name/tag but not both. */
      price_plan_uuid?: string;
      effective_at?: string;
      discounts?: components['schemas']['DiscountInputArgs'][];
      /** The name of the price plan to subscribe customer to. Either provide price plan UUID or name/tag but not both. */
      price_plan_name?: string;
      /** Whether to align this subscripton's billing cycles to calendar boundaries (e.g., begining of every month). If the subscripiton is effective as of the middle of the month, the first cycle will be prorated appropriately. */
      align_to_calendar?: boolean;
      /** DEPRECATED - use discounts field */
      discount_override?: components['schemas']['DiscountInputArgs'];
      features_override?: components['schemas']['FeatureInputArgs'][];
    };
    UpdateSubscriptionArgs: {
      trial_override?: components['schemas']['TrialInputArgs'] | null;
      coupon_override_name?: string;
      /** Boolean that indicates whether to update the subscription at the end of the billing cycle. If 'true' and either of `effective_at` or `at_cycle_start` are set, will return an error. */
      at_cycle_end?: boolean;
      limits_override?: components['schemas']['LimitInputArgs'][] | null;
      add_ons?: components['schemas']['SubscriptionAddOnInput'][] | null;
      /** The tag of the specific price plan version for the given price_plan_name. Should only be set if identifying price plan by name. */
      price_plan_tag?: string;
      /** The UUID of the specific price plan version to subscribe customer to. Either provide price plan UUID or name/tag but not both. */
      price_plan_uuid?: string;
      effective_at?: string;
      discounts?: components['schemas']['DiscountInputArgs'][];
      /** Boolean that indicates whether to update the subscription at the start of the billing cycle. If 'true' and either of `effective_at` or `at_cycle_end` are set, will return an error. */
      at_cycle_start?: boolean;
      /** The name of the price plan to subscribe customer to. Either provide price plan UUID or name/tag but not both. */
      price_plan_name?: string;
      /** Whether to align this subscripton's billing cycles to calendar boundaries (e.g., begining of every month). If the subscripiton is effective as of the middle of the month, the first cycle will be prorated appropriately. */
      align_to_calendar?: boolean;
      /** DEPRECATED - use discounts field */
      discount_override?: components['schemas']['DiscountInputArgs'] | null;
      features_override?: components['schemas']['FeatureInputArgs'][] | null;
    };
    DeleteSubscriptionArgs: {
      vendor_id?: number;
      customer_id?: number;
      expire_at?: string;
      /** Boolean that indicates whether to expire the subscription at the end of thebilling cycle. If 'true' and `expire_at` is set, will return an error. */
      at_cycle_end?: boolean;
    };
    UpdateSubscriptionInPlaceArgs: {
      coupon_override_name?: string;
      discounts?: components['schemas']['DiscountInputArgs'][];
      /** DEPRECATED - use discounts field */
      discount_override?: components['schemas']['DiscountInputArgs'] | null;
      add_ons?: components['schemas']['SubscriptionAddOnInput'][] | null;
    };
    BillingCycleDate: {
      cycle_end: string;
      cycle_start: string;
    };
    ActiveSubscription: {
      uuid: string;
      /** Unique name identifier of a customer */
      customer_name: unknown;
      /** Unique name indentifier of a price plan */
      price_plan_name: unknown;
      /** External facing unique identifier of a price plan */
      price_plan_uuid: unknown;
      /** Price plan associated with this subscription. */
      price_plan?: components['schemas']['PricePlan'];
      discounts?: (components['schemas']['Discount'] | null)[];
      add_ons?: unknown;
      /** Optional trial override for the associated subscription. */
      trial_override?: components['schemas']['Trial'];
      features_override?: components['schemas']['Feature'][];
      limits_override?: components['schemas']['Limit'][];
      /** ISO-8601 formatted timestamp that defines when the subscription should take effect. If this field is omitted, the subscription is effective upon creation. */
      effective_at?: string;
      /** ISO-8601 formatted timestamp that defines when the subscription will expire. */
      expired_at?: string | null;
      /** Align billing cycles to a calendar unit if true. For example if the period is month, cycles will end on the first of every month. */
      align_to_calendar?: boolean;
      /** Optional base price override for the associated subscription. */
      base_price_override?: number | null;
      current_billing_cycle?: components['schemas']['BillingCycleDate'];
      total_fixed_price?: number;
      discounted_fixed_price?: number;
    };
    SubscriptionAddOnItem: {
      /** Boolean that indicates whether to update the subscription add on at the end of the billing cycle. If 'true' and either of `effective_at` or `at_cycle_start` are set, will return an error. */
      at_cycle_end?: boolean;
      effective_at?: string;
      feature_name?: string;
      /** Boolean that indicates whether to update the subscription add on at the start of the billing cycle. If 'true' and either of `effective_at` or `at_cycle_end` are set, will return an error. */
      at_cycle_start?: boolean;
      /** Quantity represents how many of this add on you want to attach to the subscription. Can be positive forincreasing the number of this add on or negative for decreasing. */
      quantity?: number;
    };
    DeleteDiscountInputArgs: {
      /** Number of billing cycles that the discount should expire in. Defaults to 0 (start of current billing cycle). If the inputted discount is scheduled, it is the number of billing cycles relative to the scheduled start. You can only shorten a discount, it is not possible to extend it. */
      billing_cycle_duration?: number;
      /** External UUID representing the discount to be deleted. */
      discount_uuid: string;
    };
    UpdateInvoiceStatusArgs: {
      /** The target status of the invoice. Valid values are INVOICE_PAID and INVOICE_VOIDED. Default is INVOICE_PAID if no status is provided. */
      status?: 'INVOICE_PAID' | 'INVOICE_VOIDED';
    };
    PastInvoice: {
      status_description?: string;
      customer_name?: string;
      issue_date?: string;
      amount_due?: number;
      due_date?: string;
      status?: string;
      export_url?: string;
      /** External unique 'uuid' identifier for this Invoice. */
      id?: string;
    };
    PastInvoices: {
      sort_direction?: string;
      /** The sort column offset to start at when paging forwards */
      forward_sort_offset?: string;
      /** The number of items to fetch. Defaults to 10. */
      limit?: number;
      /** The unique offset to start at when paging forwards */
      forward_secondary_sort_offset?: string;
      invoices?: components['schemas']['PastInvoice'][];
      sort_column?: string;
    };
    CreateRetryArgs: { [key: string]: unknown };
    Retry: {
      success?: boolean;
    };
    PriceInputArgs: {
      price?: number;
      cap?: number;
      description?: string;
    };
    PriceSchemeInputArgs: {
      /** The time unit for the metered component (e.g., month or hour) */
      time_unit_name?: string;
      /** The name of the unit used for this metered component (e.g., gigabyte) */
      unit_name?: string;
      /** Array of price tiers, each of which consists of `price` and `cap` key:value pairs */
      prices?: components['schemas']['PriceInputArgs'][];
      /** Array of (key, value) meter labels to price on & the price tiers that should be used against those labels */
      price_list?: { [key: string]: unknown }[];
      /** Size of the unit batch to use for the prices. Can only be set if scheme_type='FLAT' or 'TIERED'. E.g. To charge $10 per 100 API Requests, set batch_size to 100. */
      batch_size?: number;
      /** The % increase/decrease in price after the minimum charge is reached (e.g., 25.5 -> 25.5% increase). */
      post_minimum_charge_percentage_change?: number;
      /** One of 'FLAT', 'TIERED', or 'STAIRSTEP' */
      scheme_type: string;
    };
    MeteredComponentLabelLimitInputArgs: {
      /** Dictionary of labels (key: value) to which the limit applies. A value of 'any' will apply the limit to any single value of the field. */
      labels: { [key: string]: string };
      /** Numeric limit to set on customer usage for the meter with the given labels. */
      limit: number;
    };
    MeteredComponentInputArgs: {
      /** Numeric limit to set on customer usage for the meter. */
      limit?: number;
      /** Minimum charge for the metered component */
      minimum_charge?: number | null;
      /** Name to be used on invoice. */
      display_name?: string;
      price_scheme?: components['schemas']['PriceSchemeInputArgs'];
      label_limits?: components['schemas']['MeteredComponentLabelLimitInputArgs'][];
      id?: number;
      meter_id?: number;
      /** Codename of the meter. */
      meter_name?: string;
      /** Minimum charge frequency (as a multiple of the price plan period) for the metered component */
      minimum_charge_frequency?: number | null;
    };
    AddOnInputArgs: {
      limit?: number;
      price?: number;
      quantity_enabled?: boolean;
      /** This field indicates whether or not we should cut an invoice immediately upon attaching this add on to a price plan. */
      immediately_charge?: boolean;
      /** Whether this add on can only be used & charged once. */
      single_use?: boolean;
      feature: components['schemas']['FeatureInputArgs'];
    };
    CreatePricePlanArgs: {
      metered_components?: components['schemas']['MeteredComponentInputArgs'][];
      limits?: components['schemas']['LimitInputArgs'][];
      base_price?: number;
      tags?: string[];
      period?: string;
      add_ons?: components['schemas']['AddOnInputArgs'][];
      name?: string;
      /** Minimum amount (in cents) to charge every price plan period. */
      minimum_charge?: number | null;
      /** The frequency (as a an integer multiple of the period) at which to charge the base price. */
      base_price_frequency?: number;
      /** Custom invoice description for the base price line item. */
      base_price_description?: string | null;
      trial?: components['schemas']['TrialInputArgs'];
      features?: components['schemas']['FeatureInputArgs'][];
      description?: string;
      vendor_id?: number;
      display_name?: string;
      /** The frequency (as a an integer multiple of the period) at which to charge the minimum charge. */
      minimum_charge_frequency?: number | null;
    };
    ListPricePlans: {
      price_plans?: components['schemas']['PricePlan'][];
      sort_direction?: string;
      /** The sort column offset to start at when paging forwards */
      forward_sort_offset?: string;
      /** The number of items to fetch. Defaults to 10. */
      limit?: number;
      /** The unique offset to start at when paging forwards */
      forward_secondary_sort_offset?: string;
      sort_column?: string;
    };
    UpdatePricePlanArgs: {
      metered_components?: components['schemas']['MeteredComponentInputArgs'][];
      limits?: components['schemas']['LimitInputArgs'][];
      base_price?: number;
      tags?: string[];
      period?: string;
      add_ons?: components['schemas']['AddOnInputArgs'][];
      name?: string;
      /** Minimum amount (in cents) to charge every price plan period. */
      minimum_charge?: number | null;
      /** The frequency (as a an integer multiple of the period) at which to charge the base price. */
      base_price_frequency?: number;
      /** Custom invoice description for the base price line item. */
      base_price_description?: string | null;
      trial?: components['schemas']['TrialInputArgs'];
      features?: components['schemas']['FeatureInputArgs'][];
      description?: string;
      vendor_id?: number;
      display_name?: string;
      /** The frequency (as a an integer multiple of the period) at which to charge the minimum charge. */
      minimum_charge_frequency?: number | null;
    };
    UpdatePricePlanInPlaceArgs: {
      metered_components?: components['schemas']['MeteredComponentInputArgs'][];
      limits?: components['schemas']['LimitInputArgs'][];
      add_ons?: components['schemas']['AddOnInputArgs'][];
      /** Custom invoice description for the base price line item. */
      base_price_description?: string | null;
      features?: components['schemas']['FeatureInputArgs'][];
      description?: string;
      display_name?: string;
    };
    SelfServePricePlansInputArgs: {
      price_plan_uuids?: string[];
    };
    AddFeaturesToPricePlanInput: {
      /** List of new limits to add */
      limits?: components['schemas']['LimitInputArgs'][];
      /** List of new features to add */
      features?: components['schemas']['FeatureInputArgs'][];
    };
    RemoveFeaturesFromPricePlanInput: {
      /** List of feature names to remove */
      feature_names: string[];
    };
    AddAddOnsToPricePlanInput: {
      /** List of add ons to add */
      add_ons: components['schemas']['AddOnInputArgs'][];
    };
    AddMeteredComponentsToPricePlanInput: {
      /** List of metered components to add */
      metered_components: components['schemas']['MeteredComponentInputArgs'][];
    };
    UpdateMeteredComponentLimitsInput: {
      label_limits?: components['schemas']['MeteredComponentLabelLimitInputArgs'][];
      /** Numeric limit to set on customer usage for the meter. */
      limit?: number | null;
    };
    PaymentGatewayCredentialInputArgs: {
      payment_gateway?: string;
      account_id?: string;
      auth_token?: string;
    };
    CreateBillingSettingsInputArgs: {
      /** Swift code for ACH/Wire transfer instructions */
      ach_swift_code?: string | null;
      /** Flag that controls whether or not invoices should be sent to customers. */
      should_send_invoice_to_customers?: boolean;
      /** Flag that controls whether or not to invoice/charge a true up for a billing cycle on the following invoice. Only applies if invoice_fixed_components_at_start is enabled. */
      invoice_overages?: boolean;
      /** The percentage tax rate to apply to invoices. */
      tax_rate?: number | null;
      /** Bank name for ACH/Wire transfer instructions */
      ach_bank_name?: string | null;
      /** Flag determining whether ACH/Wire instructions should be included on invoices. */
      include_ach_instructions?: boolean | null;
      /** Optional description attached to the invoice */
      invoice_memo?: string | null;
      /** Account number for ACH/Wire transfer instructions */
      ach_account_number?: string | null;
      /** Default value for whether to align billing cycles to calendar on subscriptions */
      align_billing_cycles_to_calendar?: boolean;
      /** Flag that controls whether to do automated taxes via payment provider */
      tax_via_payment_provider?: boolean;
      /** Time length of the grace period between the end of a billing cycle and invoice generation in days. */
      invoice_grace_period_length?: number;
      /** Flag that controls whether to invoice through Octane or through payment provider */
      invoice_via_octane?: boolean;
      /** True if customer updates should be synced to Stripe. */
      sync_customer_data_to_payment_gateway?: boolean | null;
      /** Flag that controls the number of retry attempts for invoicing/payments. */
      retry_attempts?: number;
      /** If using stripe, this field can be used to configure whether invoices should be auto advanced for collection */
      stripe_auto_advance?: boolean;
      /** Account name for ACH/Wire transfer instructions */
      ach_account_name?: string | null;
      /** Sets the due date on invoices to the number of days after the invoice is sent */
      days_until_due?: number | null;
      /** Time length of the grace period between the end of invoice generation and the actual charge. *NOTE*: The specified length is unitless. Unit is designated with the `payment_grace_period_unit` field. */
      payment_grace_period_length?: number;
      /** Optional url of a custom image to include on invoices. */
      invoice_logo_url?: string | null;
      customer_invoice_detail_level?: string;
      /** Flag that controls whether or not to auto-charge the customer based on the invoice. */
      charges_enabled?: boolean;
      /** Flag that controls whether or not to invoice/charge gauge meters upfront according to their value at start of cycle. Only applies if invoice_fixed_components_at_start is enabled. */
      invoice_metered_components_at_start?: boolean;
      /** Time length unit of the grace period between the end of a billing cycle and invoice generation. Must be `day`. */
      invoice_grace_period_unit?: 'day';
      /** Second line of bank address for ACH/Wire transfer instructions */
      ach_bank_address_2?: string | null;
      /** Flag that controls whether invoices are auto-approved or require manual approval */
      auto_approve_invoices?: boolean;
      /** If set, a minimum charge line item will override any line items that contribute to the minimum (i.e., the minimum charge line item would be the only line item). */
      should_minimum_charge_override_line_items?: boolean | null;
      /** Flag that controls whether or not to invoice/charge the base rate, add ons and other fixed price plan components at the beginning of the billing cycle. */
      invoice_fixed_components_at_start?: boolean;
      /** Time length after which to attempt invoice/payment retry. */
      retry_frequency_length?: number;
      /** First line of bank address for ACH/Wire transfer instructions */
      ach_bank_address_1?: string | null;
      /** ABA/Routing number for ACH/Wire transfer instructions */
      ach_routing_number?: string | null;
      /** Time length unit of the grace period between the end of invoice generation and actual charge. One of `minute`, `hour`, `day`. */
      payment_grace_period_unit?: string;
      /** If using Stripe, this field can be used to configure whether invoices should be finalized immediately when they are created. */
      stripe_immediate_finalization?: boolean | null;
      /** Time length unit after which to attempt invoice/payment retry. */
      retry_frequency_unit?: string;
    };
    UpdateBillingSettingsInputArgs: {
      /** Swift code for ACH/Wire transfer instructions */
      ach_swift_code?: string | null;
      /** Flag that controls whether or not invoices should be sent to customers. */
      should_send_invoice_to_customers?: boolean;
      /** Flag that controls whether or not to invoice/charge a true up for a billing cycle on the following invoice. Only applies if invoice_fixed_components_at_start is enabled. */
      invoice_overages?: boolean;
      /** The percentage tax rate to apply to invoices. */
      tax_rate?: number | null;
      /** Bank name for ACH/Wire transfer instructions */
      ach_bank_name?: string | null;
      /** Flag determining whether ACH/Wire instructions should be included on invoices. */
      include_ach_instructions?: boolean | null;
      /** Optional description attached to the invoice */
      invoice_memo?: string | null;
      /** Account number for ACH/Wire transfer instructions */
      ach_account_number?: string | null;
      /** Default value for whether to align billing cycles to calendar on subscriptions */
      align_billing_cycles_to_calendar?: boolean;
      /** Flag that controls whether to do automated taxes via payment provider */
      tax_via_payment_provider?: boolean;
      /** Time length of the grace period between the end of a billing cycle and invoice generation in days. */
      invoice_grace_period_length?: number;
      /** Flag that controls whether to invoice through Octane or through payment provider */
      invoice_via_octane?: boolean;
      /** True if customer updates should be synced to Stripe. */
      sync_customer_data_to_payment_gateway?: boolean | null;
      /** Flag that controls the number of retry attempts for invoicing/payments. */
      retry_attempts?: number;
      /** If using stripe, this field can be used to configure whether invoices should be auto advanced for collection */
      stripe_auto_advance?: boolean;
      /** Account name for ACH/Wire transfer instructions */
      ach_account_name?: string | null;
      /** Sets the due date on invoices to the number of days after the invoice is sent */
      days_until_due?: number | null;
      /** Time length of the grace period between the end of invoice generation and the actual charge. *NOTE*: The specified length is unitless. Unit is designated with the `payment_grace_period_unit` field. */
      payment_grace_period_length?: number;
      /** Optional url of a custom image to include on invoices. */
      invoice_logo_url?: string | null;
      customer_invoice_detail_level?: string;
      /** Flag that controls whether or not to auto-charge the customer based on the invoice. */
      charges_enabled?: boolean;
      /** Flag that controls whether or not to invoice/charge gauge meters upfront according to their value at start of cycle. Only applies if invoice_fixed_components_at_start is enabled. */
      invoice_metered_components_at_start?: boolean;
      /** Time length unit of the grace period between the end of a billing cycle and invoice generation. Must be `day`. */
      invoice_grace_period_unit?: 'day';
      /** Second line of bank address for ACH/Wire transfer instructions */
      ach_bank_address_2?: string | null;
      /** Flag that controls whether invoices are auto-approved or require manual approval */
      auto_approve_invoices?: boolean;
      /** If set, a minimum charge line item will override any line items that contribute to the minimum (i.e., the minimum charge line item would be the only line item). */
      should_minimum_charge_override_line_items?: boolean | null;
      /** Flag that controls whether or not to invoice/charge the base rate, add ons and other fixed price plan components at the beginning of the billing cycle. */
      invoice_fixed_components_at_start?: boolean;
      /** Time length after which to attempt invoice/payment retry. */
      retry_frequency_length?: number;
      /** First line of bank address for ACH/Wire transfer instructions */
      ach_bank_address_1?: string | null;
      /** ABA/Routing number for ACH/Wire transfer instructions */
      ach_routing_number?: string | null;
      /** Time length unit of the grace period between the end of invoice generation and actual charge. One of `minute`, `hour`, `day`. */
      payment_grace_period_unit?: string;
      /** If using Stripe, this field can be used to configure whether invoices should be finalized immediately when they are created. */
      stripe_immediate_finalization?: boolean | null;
      /** Time length unit after which to attempt invoice/payment retry. */
      retry_frequency_unit?: string;
    };
    Customer1: {
      /** Unique name identifier of a customer */
      name: string;
    };
    PricePlan1: {
      /** Unique name indentifier of a price plan */
      name: string;
    };
    Coupon: {
      /** Unique name identifier. */
      name: string;
      /** UI-friendly name used for data display. Defaults to `name`. */
      display_name?: string;
      /** The time when the coupon will stop being effective one its applied. */
      duration_length?: number | null;
      /** The unit time unit to apply to the specified duration length. */
      duration_unit?: string | null;
      /** ISO-8601 formatted timestamp that defines after what timestamp this coupon cannot be applied. */
      expiration_time?: string | null;
      frequency?: unknown;
      /** The maximum number of times this coupon can be used. */
      max_uses?: number | null;
      /** Customer facing code that can be used to apply coupon. */
      code?: string | null;
      discount_type?: unknown;
      /** The amount of discount to give based on discount_type */
      discount_amount: number;
      excluded_customers?: components['schemas']['Customer1'][];
      excluded_price_plans?: components['schemas']['PricePlan1'][];
    };
    CouponInputArgs: {
      vendor_id?: number;
      name: string;
      display_name?: string;
      expiration_time?: string;
      frequency: 'ONCE' | 'RECURRING';
      duration_length?: number;
      duration_unit?: string;
      max_uses?: number;
      code?: string;
      excluded_customers?: string[];
      excluded_price_plans?: string[];
      discount_type: 'FLAT' | 'PERCENT';
      discount_amount: number;
    };
    ApplyCouponInputArgs: {
      customer_id?: number;
      customer_name?: string;
      name?: string;
      code?: string;
      vendor_id?: number;
    };
    CreateRefundArgs: {
      /** Amount to be refunded */
      amount?: number;
      /** Invoice that the refund should be against */
      invoice_id?: number;
      /** Invoice that the refund should be against */
      invoice_uuid?: string;
    };
    Refund: {
      success?: boolean;
    };
    CustomerPortalSettings: {
      /** Comma-separated list of names to filter visible price plans by. */
      price_plan_names_filter?: string | null;
      /** Comma-separated list of tags to filter visible price plans by. */
      price_plan_tags_filter?: string | null;
    };
    UpdateCustomerPortalSettingsInputArgs: {
      vendor_id?: number;
      price_plan_names_filter?: string;
      price_plan_tags_filter?: string;
    };
    CustomerPortalTokenInputArgs: {
      customer_name?: string;
    };
    CustomerPortalToken: {
      token?: string;
    };
    CustomerPortalUrl: {
      url?: string;
    };
    CustomerPortalVendor: {
      /** Vendor's current payment gateway. */
      payment_gateway?: string;
      /** Unique name identifier of a Vendor */
      name?: string;
      /** Currency preference of the Vendor. */
      currency?: string;
      /** Full contact info for the Vendor */
      contact_info?: components['schemas']['ContactInfo'];
      /** Display name for the Vendor */
      display_name?: string;
    };
    CustomerPortalInvoiceStatus: {
      /** Time the invoice status was last updated. */
      updated_at?: string;
      /** The timestamp that the action will be performed at. */
      pending_action_time?: string;
      /** The current upcoming action associated with this invoice status, if any. */
      action?: string;
      update_source?: string;
      error?: string;
      /** The current processing state for this invoice. */
      status?: string;
      /** Creation time of this invoice status. */
      created_at?: string;
    };
    CustomerPortalInvoice: {
      /** Earliest start time of line items covered by the invoice */
      min_item_start_time?: string;
      /** Url pointing to the pdf of this invoice. */
      pdf_url?: string;
      /** [DEPRECATED] Start time of the cycle in which the invoice was generated */
      start_time?: string;
      /** False if not paid yet */
      is_paid?: boolean;
      /** [DEPRECATED] End time of the cycle in which the invoice was generated */
      end_time?: string;
      /** The date the invoice will be issued to the end customer or forwarded to the payment processor. */
      issue_date?: string;
      /** Any discount credits applied to the invoice */
      discount_credit?: number;
      /** Total amount due */
      amount_due?: number;
      due_date?: string;
      /** Amount due before any credits are applied */
      sub_total?: number;
      /** Latest end time of line items covered by the invoice */
      max_item_end_time?: string;
      /** Tax amount applied to subtotal */
      tax_amount?: number;
      line_items?: components['schemas']['LineItems'][];
      /** Information related to the current status of this invoice. */
      status?: components['schemas']['CustomerPortalInvoiceStatus'];
      id?: string;
    };
    CustomerPortalActiveSubscription: {
      /** Customer's current active biling cycle. */
      billing_cycle: components['schemas']['BillingCycleDate'];
      /** The date that the customer will be invoiced for their current billing cycle. */
      invoicing_date?: string;
      /** The total fixed price with all discounts applied. */
      discounted_fixed_price?: number;
      /** The total fixed price the customer will be charged for this billing cycle. Includes the base price and any add ons. */
      total_fixed_price?: number;
      /** Customer's current active subscription. Includes the price plan and overrides they are subscribed to. */
      subscription?: components['schemas']['Subscription'];
    };
    CustomerPortalActiveSubscriptionInputArgs: {
      price_plan_uuid?: string;
      add_ons?: components['schemas']['SubscriptionAddOnInput'][] | null;
    };
    CustomerPortalSubscription: {
      price_plan?: components['schemas']['PricePlan'];
    };
    CustomerPortalSubscriptionInputArgs: {
      price_plan_name?: string;
    };
    CustomerPortalStripeCredential: {
      account_id?: string;
      client_secret?: string;
      publishable_key?: string;
    };
    CustomerPortalMeterLabels: {
      /** Primary label values associated with the key */
      values?: string[];
      key?: string;
    };
    CustomerPortalLabelDisplayName: {
      display_name?: string;
      /** The raw value of the label data */
      name?: string;
    };
    CustomerPortalMeterLabelsWithDisplayName: {
      /** Primary label values associated with the key */
      values?: components['schemas']['CustomerPortalLabelDisplayName'][];
      /** Primary label key and prettified version of the key */
      key?: components['schemas']['CustomerPortalLabelDisplayName'];
    };
    CustomerPortalMeter: {
      /** Display name of the meter. */
      meter_display_name?: string;
      /** Aggregation of meter. E.g. SUM, TIME_WEIGHTED_SUM, MAX, or LATEST. */
      aggregation?: string;
      /** Type of meter data. E.g. DISCRETE or CONTINUOUS. */
      data_type?: string;
      /** Name of the unit the meter uses. */
      unit_name?: string;
      /** Primary labels with keys and values */
      labels?: components['schemas']['CustomerPortalMeterLabels'][];
      /** Type of the meter. E.g. COUNTER or GAUGE. */
      meter_type?: string;
      /** The raw and prettified label keys and values */
      labels_with_display_names?: components['schemas']['CustomerPortalMeterLabelsWithDisplayName'][];
      /** Name of the meter. */
      meter_name?: string;
    };
    DailyUsage: {
      /** Total usage during this window. */
      usage?: number;
      /** Start of the 24 hour time window in UTC. */
      time?: string;
      /** Label key. Only present if label_group_by is provided. */
      label_key?: string;
      /** Label value. Only present if label_group_by is provided. */
      label_value?: string;
    };
    CycleUsage: {
      /** The end of the billing cycle in UTC. */
      cycle_end?: string;
      /** Total usage in the cycle. */
      total_usage?: number;
      usage_by_time?: components['schemas']['DailyUsage'][];
      /** The start of the billing cycle in UTC. */
      cycle_start?: string;
    };
    CustomerPortalUsage: {
      /** Display name of the meter. */
      meter_display_name?: string;
      /** Daily usage across the current billing cycle. */
      current_cycle_usage?: components['schemas']['CycleUsage'];
      /** Name of the unit the meter uses. */
      unit_name?: string;
      /** Type of the meter. E.g. COUNTER or GAUGE. */
      meter_type?: string;
      /** Name of the meter. */
      meter_name?: string;
      /** Daily usage across the previous billing cycle. */
      previous_cycle_usage?: components['schemas']['CycleUsage'];
    };
    CustomerPortalAccruedRevenueLineItem: {
      /**
       * The identifier of the item being returned.
       *         For metered component will be meter name,
       *         for add_ons will be feature name,
       *         for base price will be price plan name,
       *         for minimum charge will be price plan name,
       *         for metered component minimum charge will be meter name
       */
      item_identifier?: string;
      /** Accrued revenue for this line item in cents */
      revenue?: number;
      /** Type of item. One of: METERED_COMPONENT, BASE_PRICE, DISCOUNT, ADD_ON, MINIMUM_CHARGE, METERED_COMPONENT_MINIMUM_CHARGE */
      item_type?: string;
      /**
       * Any extra metadata associated with the item.
       *         Will include the labels for metered components and metered component minimum charges when applicable
       */
      metadata?: { [key: string]: string };
    };
    CustomerPortalAccruedRevenue: {
      /** Total accrued revenue for the period in cents */
      total_accrued_revenue?: number;
      /** The cycle start of the billing cycle for which the accrued revenue is computed */
      start_time?: string;
      /** The end time within the billing cycle for which this accrued revenue is computed */
      end_time?: string;
      line_items?: components['schemas']['CustomerPortalAccruedRevenueLineItem'][];
    };
    CustomerPortalDailyAccruedRevenue: {
      /** The date for which this accrued revenue is computed */
      date?: string;
      /** The start time of the billing cycle for which the accrued revenue is computed */
      start_time?: string;
      /** The end time till when the accured revenue is computed */
      end_time?: string;
      line_items?: components['schemas']['CustomerPortalAccruedRevenueLineItem'][];
      /** Total accrued revenue for the day in cents */
      total_accrued_revenue?: number;
    };
    CustomerPortalLabelFilter: {
      key?: string;
      /** Primary label value associated with the key */
      value?: string;
    };
    CustomerPortalMeterLabelFilter: {
      /** The label key to group results by. */
      label_group_by?: string;
      /** Name of the meter. */
      meter_name: string;
      /** The aggregate function to use for the meter. */
      aggregate?: 'sum' | 'time_weighted' | 'latest' | 'max';
      /** Primary labels with keys and values */
      label_filters?: components['schemas']['CustomerPortalLabelFilter'][];
    };
    BankAccountInfo: {
      /** Routing number for the bank accopunt */
      routing_number?: number;
      /** Name of the bank */
      bank_name?: string;
      /** Country the bank account is in. */
      country?: string;
      /** Bank account type. E.g. Savings/Checking */
      account_type?: string;
      /** Last 4 digits of the bank account number. */
      last4?: string;
      external_id?: string;
    };
    CardInfo: {
      /** Country of the card */
      country?: string;
      /** Month the card expires */
      exp_month?: number;
      /** Brand of card. E.g. Amex, Visa, etc. */
      brand?: string;
      /** Year the card expires */
      exp_year?: number;
      /** Last 4 digits of the card. */
      last4?: string;
      external_id?: string;
    };
    CustomerPortalPaymentMethod: {
      /** Info about the customer's US bank account, if that is their payment method. */
      bank_account_info?: components['schemas']['BankAccountInfo'];
      /** Type of payment method for the customer. */
      payment_method_type?: string;
      /** Info about the customer's card, if that is their payment method. */
      card_info?: components['schemas']['CardInfo'];
    };
    SelfServeSettings: {
      /** True if the customer can purchase credits via self serve. Defaults to False. */
      purchase_credits: boolean;
      /** Time length of the default expiration for credits bought in the customer portal. */
      credits_expiration_length?: number | null;
      /** Time length unit for the default expiration for credits bought in the customer portal. */
      credits_expiration_unit?: string | null;
      /** Price per credit, in cents, that the customer is charged for buying credits through the customer portal */
      price_per_credit_cents?: number | null;
      /** True if the customer can switch their current price plan via self serve. Defaults to False. */
      switch_price_plans: boolean;
      /** True if the vendor has enabled customization for their customer portal. */
      customization?: boolean;
    };
    SelfServeCustomization: {
      /** Dictionary of customization settings as key value pairs. */
      settings: { [key: string]: string };
    };
    CreditLedger: {
      /** The change in numer of credits */
      amount?: number;
      /** Credit balance as of this change */
      balance?: number;
      /** The time at which this credit balance change occurred. */
      timestamp?: string;
      pending?: boolean;
    };
    CustomerPortalCreditPurchase: {
      /** Number of credits to purchase. */
      amount: number;
    };
    CreditGrant: {
      /** Number of credits granted */
      amount?: number;
      /** The date at which this grant expires */
      expires_at?: string;
      /** The source of the grant. */
      source?: string;
      /** Name of the customer who received the grant */
      customer_name?: string;
      /** Total price paid for the credits, in cents */
      price?: number;
      /** The date at which this grant is effective */
      effective_at?: string;
      /** Optional description. This is only viewable internally */
      description?: string;
      /** A unique identifier for this grant */
      uuid?: string;
    };
    Webhook: {
      /** The url to send the webhooks to. */
      url: string;
      /** Unique string identifier representing this webhook configuration. */
      uuid?: string;
      /** Determines whether Octane will sign the outgoing webhook */
      enable_signature: boolean;
    };
    CreateWebhookArgs: {
      url?: string;
      enable_signature?: boolean;
    };
    ListCreditGrantsArgs: {
      sort_direction?: string;
      /** The sort column offset to start at when paging forwards */
      forward_sort_offset?: string;
      /** The number of items to fetch. Defaults to 10. */
      limit?: number;
      /** Customer to filter the results to */
      customer_name?: string;
      /** The unique offset to start at when paging forwards */
      forward_secondary_sort_offset?: string;
      sort_column?: string;
    };
    ListCreditGrants: {
      sort_direction?: string;
      /** The sort column offset to start at when paging forwards */
      forward_sort_offset?: string;
      /** The number of items to fetch. Defaults to 10. */
      limit?: number;
      /** The unique offset to start at when paging forwards */
      forward_secondary_sort_offset?: string;
      credit_grants?: components['schemas']['CreditGrant'][];
      sort_column?: string;
    };
    CreateCreditGrantArgs: {
      /** Number of credits to grant */
      amount: number;
      /** The date at which this grant expires */
      expires_at?: string;
      /** Name of the customer receving the grant */
      customer_name: string;
      /** Total price paid for the credits in cents. Defaults to $1 (100 cents) per credit if not specified */
      price?: number;
      /** The date at which the grant is effective */
      effective_at?: string;
      /** Optional description. This is only viewable internally */
      description?: string;
    };
    RollApiKeyArgs: {
      /** The date at which this API key will expire. Will default to 7 days. */
      expires_at?: string;
      /** The API key you want to roll. */
      api_key: string;
    };
    RollApiKeys: {
      success?: boolean;
      /** The newly generated API Key. */
      api_key?: string;
    };
    UpdateSelfServeSettingsArgs: {
      /** True if the vendor has enabled customization for their customer portal. */
      enabled?: boolean;
      /** True if the customer can switch their current price plan via self serve. Defaults to False. */
      switch_price_plans?: boolean;
      /** True if the vendor has enabled customization for their customer portal. */
      customization?: boolean;
      /** Time length unit for the default expiration for credits bought in the customer portal. */
      credits_expiration_unit?: string;
      /** True if the customer can purchase credits via self serve. Defaults to False. */
      purchase_credits?: boolean;
      /** Time length of the default expiration for credits bought in the customer portal. */
      credits_expiration_length?: number;
      /** Price per credit, in cents, that the customer is charged for buying credits through the customer portal */
      price_per_credit_cents?: number;
    };
    VendorAvalaraSettings: {
      /** True if the documents generated in Avalara should be committed, false otherwise. */
      commit_documents?: boolean;
      /** he tax code to associate with the item that is representing the Octane invoice. */
      tax_code?: string;
      /** The Avalara item code to use to represent all the line items on the Octane invoice. */
      item_code?: string;
      /** Password of the Avalara account. */
      password?: string;
      /** Username of the Avalara account. */
      username?: string;
      /** The Avalara company code string to associate the Octane vendor with. */
      company_code?: string;
      /** True if connecting to Avalara sandbox account, false otherwise. */
      sandbox_mode?: boolean;
      /** Enable/Disable the Avalara integration. */
      enable_integration?: boolean;
      /** True if enabling logging for Avalara calls, false otherwise. */
      enable_logging?: boolean;
      /** The item description to use to represent all the lines on the Octane invoice. */
      item_description?: string;
    };
    CreateVendorAvalaraSettingsArgs: {
      /** True if the documents generated in Avalara should be committed, false otherwise. Defaults to False. */
      commit_documents?: boolean;
      /** The tax code to associate with the item that is representing the Octane invoice. */
      tax_code?: string;
      /** The Avalara item code to use to represent all the line items on the Octane invoice. */
      item_code?: string;
      /** Password of the Avalara account. */
      password: string;
      /** Username of the Avalara account. */
      username: string;
      /** The Avalara company code string to associate the Octane vendor with. */
      company_code?: string;
      /** True if connecting to Avalara sandbox account, false otherwise. */
      sandbox_mode: boolean;
      /** Enable/Disable the Avalara integration. */
      enable_integration: boolean;
      /** True if enabling logging for Avalara calls, false otherwise. Defaults to False. */
      enable_logging?: boolean;
      /** The item description to use to represent all the lines on the Octane invoice. */
      item_description?: string;
    };
    UpdateVendorAvalaraSettingsArgs: {
      /** True if the documents generated in Avalara should be committed, false otherwise. */
      commit_documents?: boolean;
      /** he tax code to associate with the item that is representing the Octane invoice. */
      tax_code?: string;
      /** The Avalara item code to use to represent all the line items on the Octane invoice. */
      item_code?: string;
      /** The Avalara company code string to associate the Octane vendor with. */
      company_code?: string;
      /** Enable/Disable the Avalara integration. */
      enable_integration?: boolean;
      /** True if enabling logging for Avalara calls, false otherwise. */
      enable_logging?: boolean;
      /** The item description to use to represent all the lines on the Octane invoice. */
      item_description?: string;
    };
    ValidateCredentialsArgs: {
      /** True if using a Avalara sandbox account, False otherwise */
      sandbox_mode: boolean;
      /** Password of the Avalara account */
      password: string;
      /** Username of the Avalara account */
      username: string;
    };
    ValidateCredentialsResp: {
      /** Indicates whether the ping to Avalara was successful and the credentials were validated. */
      success?: boolean;
    };
    TaxCode: {
      /** A code string that identifies this tax code. */
      tax_code?: string;
      /** A friendly description of this tax code. */
      description?: string;
      /** The unique ID number of this tax code. */
      id?: string;
      /** The type of this tax code. */
      tax_code_type_id?: string;
      /** The Avalara Entity Use Code represented by this tax code. */
      entity_use_code?: string;
    };
    Company: {
      /** This flag indicates whether tax activity can occur for this company. */
      is_active?: boolean;
      /** The name of this company, as shown to customers. */
      company_name?: string;
      /** A unique code that references this company within your account. */
      company_code?: string;
      /** This flag is true if this company is the default company for this account. */
      is_default?: boolean;
      /** The unique ID number of this company. */
      id?: string;
    };
    EntityUseCode: {
      /** Text describing the meaning of this use code. */
      description?: string;
      /** A list of countries where this use code is valid. */
      valid_countries?: string[];
      /** The Avalara-recognized entity use code for this definition. */
      code?: string;
      /** The name of this entity use code. */
      name?: string;
    };
    RevenueRecognitionInput: {
      /** List of customer names for which to compute booked/recognized revenue. */
      customer_names?: string[];
    };
    RevenueRecognitionEntry: {
      /** The newly booked amount in this month (in cents). */
      booked?: number;
      /** The month in which the revenue is booked and(or) recognized. */
      month?: string;
      /** The change in deferred revenue this month (in cents). */
      deferred?: number;
      /** The change in recognized revenue this month (in cents). */
      recognized?: number;
    };
  };
  responses: {
    /** Default error response */
    DEFAULT_ERROR: {
      content: {
        'application/json': components['schemas']['Error'];
      };
    };
    /** Unprocessable Entity */
    UNPROCESSABLE_ENTITY: {
      content: {
        'application/json': components['schemas']['Error'];
      };
    };
  };
}

export interface operations {}

export interface external {}
