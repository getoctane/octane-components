/**
 * This file was auto-generated by openapi-typescript.
 * Do not make direct changes to the file.
 */

export interface paths {
  '/live_measurements/': {
    /** Get a list of most recent measurements (maximum of 5000) for a vendor. Optionally filter by customer name. */
    get: {
      responses: {
        /** OK */
        200: unknown;
        default: components['responses']['DEFAULT_ERROR'];
      };
    };
  };
  '/meters/': {
    /** Get all meters for a given vendor. */
    get: {
      responses: {
        /** OK */
        200: {
          content: {
            'application/json': components['schemas']['Meter'][];
          };
        };
        default: components['responses']['DEFAULT_ERROR'];
      };
    };
    /** Create a new meter for a given vendor. */
    post: {
      responses: {
        /** OK */
        200: {
          content: {
            'application/json': components['schemas']['Meter'];
          };
        };
        422: components['responses']['UNPROCESSABLE_ENTITY'];
        default: components['responses']['DEFAULT_ERROR'];
      };
      requestBody: {
        content: {
          'application/json': components['schemas']['MeterInputArgs'];
        };
      };
    };
  };
  '/meters/{meter_name}': {
    /** Get a meter by its unique name. */
    get: {
      parameters: {
        path: {
          meter_name: string;
        };
      };
      responses: {
        /** OK */
        200: {
          content: {
            'application/json': components['schemas']['Meter'];
          };
        };
        default: components['responses']['DEFAULT_ERROR'];
      };
    };
    /** Update a meter by its unique name. */
    put: {
      parameters: {
        path: {
          meter_name: string;
        };
      };
      responses: {
        /** OK */
        200: {
          content: {
            'application/json': components['schemas']['Meter'];
          };
        };
        422: components['responses']['UNPROCESSABLE_ENTITY'];
        default: components['responses']['DEFAULT_ERROR'];
      };
      requestBody: {
        content: {
          'application/json': components['schemas']['UpdateMeterArgs'];
        };
      };
    };
    /** Delete a meter by its unique name. Meters can only be deleted if not in-use by a price plan. */
    delete: {
      parameters: {
        path: {
          meter_name: string;
        };
      };
      responses: {
        /** No Content */
        204: never;
        default: components['responses']['DEFAULT_ERROR'];
      };
    };
    parameters: {
      path: {
        meter_name: string;
      };
    };
  };
  '/meters/{meter_name}/archive': {
    /** Update a meter by its unique name. */
    post: {
      parameters: {
        path: {
          meter_name: string;
        };
      };
      responses: {
        /** OK */
        200: unknown;
        default: components['responses']['DEFAULT_ERROR'];
      };
    };
    parameters: {
      path: {
        meter_name: string;
      };
    };
  };
  '/measurements/': {
    post: {
      responses: {
        /** OK */
        200: {
          content: {
            'application/json': components['schemas']['Measurement'];
          };
        };
        422: components['responses']['UNPROCESSABLE_ENTITY'];
        default: components['responses']['DEFAULT_ERROR'];
      };
      requestBody: {
        content: {
          'application/json': components['schemas']['Measurement'];
        };
      };
    };
  };
  '/measurements/multi': {
    post: {
      responses: {
        /** OK */
        200: {
          content: {
            'application/json': components['schemas']['Measurement'][];
          };
        };
        422: components['responses']['UNPROCESSABLE_ENTITY'];
        default: components['responses']['DEFAULT_ERROR'];
      };
      requestBody: {
        content: {
          'application/json': components['schemas']['Measurement'][];
        };
      };
    };
  };
  '/customers/': {
    /** Retrieve all customers for a given vendor. */
    get: {
      responses: {
        /** OK */
        200: {
          content: {
            'application/json': components['schemas']['Customer'][];
          };
        };
        default: components['responses']['DEFAULT_ERROR'];
      };
    };
    /** Create a new customer. */
    post: {
      responses: {
        /** OK */
        200: {
          content: {
            'application/json': components['schemas']['Customer'];
          };
        };
        422: components['responses']['UNPROCESSABLE_ENTITY'];
        default: components['responses']['DEFAULT_ERROR'];
      };
      requestBody: {
        content: {
          'application/json': components['schemas']['CreateCustomerArgs'];
        };
      };
    };
  };
  '/customers/{customer_name}': {
    /** Fetch a customer by their unique name. */
    get: {
      parameters: {
        path: {
          customer_name: string;
        };
      };
      responses: {
        /** OK */
        200: {
          content: {
            'application/json': components['schemas']['Customer'];
          };
        };
        default: components['responses']['DEFAULT_ERROR'];
      };
    };
    /** Update a single customer. To update Customer measurement mappings, use the `customers/{customer_name}/mappings` endpoint. */
    put: {
      parameters: {
        path: {
          customer_name: string;
        };
      };
      responses: {
        /** OK */
        200: {
          content: {
            'application/json': components['schemas']['Customer'];
          };
        };
        422: components['responses']['UNPROCESSABLE_ENTITY'];
        default: components['responses']['DEFAULT_ERROR'];
      };
      requestBody: {
        content: {
          'application/json': components['schemas']['UpdateCustomerArgs'];
        };
      };
    };
    /** Delete a customer by their unique name. */
    delete: {
      parameters: {
        path: {
          customer_name: string;
        };
      };
      responses: {
        /** No Content */
        204: never;
        default: components['responses']['DEFAULT_ERROR'];
      };
    };
    parameters: {
      path: {
        customer_name: string;
      };
    };
  };
  '/customers/{customer_name}/mappings': {
    /** Fetch all measurement mappings for a specific customer (by unique customer name). */
    get: {
      parameters: {
        path: {
          customer_name: string;
        };
      };
      responses: {
        /** OK */
        200: {
          content: {
            'application/json': components['schemas']['CustomerMeasurementMapping'][];
          };
        };
        default: components['responses']['DEFAULT_ERROR'];
      };
    };
    /** Create a new measurement mapping for a customer. If no value_regex is passed, label existence is checked instead. */
    post: {
      parameters: {
        path: {
          customer_name: string;
        };
      };
      responses: {
        /** OK */
        200: {
          content: {
            'application/json': components['schemas']['CustomerMeasurementMapping'];
          };
        };
        422: components['responses']['UNPROCESSABLE_ENTITY'];
        default: components['responses']['DEFAULT_ERROR'];
      };
      requestBody: {
        content: {
          'application/json': components['schemas']['CustomerMeasurementMappingInputArgs'];
        };
      };
    };
    parameters: {
      path: {
        customer_name: string;
      };
    };
  };
  '/customers/{customer_name}/payment_method_status': {
    /** Fetch payment method status for a specific customer (by unique customer name). */
    get: {
      parameters: {
        path: {
          customer_name: string;
        };
      };
      responses: {
        /** OK */
        200: {
          content: {
            'application/json': components['schemas']['CustomerPaymentMethodStatus'];
          };
        };
        default: components['responses']['DEFAULT_ERROR'];
      };
    };
    parameters: {
      path: {
        customer_name: string;
      };
    };
  };
  '/customers/{customer_name}/payment_gateway_credentials': {
    /**
     * Get the payment gateway credentials from the vendor's configured payment gateway for the given customer.
     * For example, this endpoint will return a customer's Stripe customer ID, assuming the vendor has integrated with stripe and has configured the given customer with a Stripe customer ID.
     */
    get: {
      parameters: {
        path: {
          customer_name: string;
        };
      };
      responses: {
        /** OK */
        200: {
          content: {
            'application/json': components['schemas']['PaymentGatewayCredential'];
          };
        };
        default: components['responses']['DEFAULT_ERROR'];
      };
    };
    /**
     * Add credentials for a customer's account in the vendor's currently configured payment gateway.
     * For example, this endpoint can be used to associate a customer with a Stripe customer ID.
     */
    post: {
      parameters: {
        path: {
          customer_name: string;
        };
      };
      responses: {
        /** OK */
        200: {
          content: {
            'application/json': components['schemas']['PaymentGatewayCredential'];
          };
        };
        422: components['responses']['UNPROCESSABLE_ENTITY'];
        default: components['responses']['DEFAULT_ERROR'];
      };
      requestBody: {
        content: {
          'application/json': components['schemas']['CustomerPaymentGatewayCredentialInputArgs'];
        };
      };
    };
    parameters: {
      path: {
        customer_name: string;
      };
    };
  };
  '/customers/{customer_name}/billing_settings': {
    /** Fetch the billing settings for a customer. */
    get: {
      parameters: {
        path: {
          customer_name: string;
        };
      };
      responses: {
        /** OK */
        200: {
          content: {
            'application/json': components['schemas']['BillingSettings'];
          };
        };
        default: components['responses']['DEFAULT_ERROR'];
      };
    };
    /** Update billing settings for a customer. */
    put: {
      parameters: {
        path: {
          customer_name: string;
        };
      };
      responses: {
        /** OK */
        200: {
          content: {
            'application/json': components['schemas']['BillingSettings'];
          };
        };
        422: components['responses']['UNPROCESSABLE_ENTITY'];
        default: components['responses']['DEFAULT_ERROR'];
      };
      requestBody: {
        content: {
          'application/json': components['schemas']['CustomerBillingSettingsInputArgs'];
        };
      };
    };
    /** Create billing settings for a customer. */
    post: {
      parameters: {
        path: {
          customer_name: string;
        };
      };
      responses: {
        /** OK */
        200: {
          content: {
            'application/json': components['schemas']['BillingSettings'];
          };
        };
        422: components['responses']['UNPROCESSABLE_ENTITY'];
        default: components['responses']['DEFAULT_ERROR'];
      };
      requestBody: {
        content: {
          'application/json': components['schemas']['CustomerBillingSettingsInputArgs'];
        };
      };
    };
    /** Delete billing settings for a customer. */
    delete: {
      parameters: {
        path: {
          customer_name: string;
        };
      };
      responses: {
        /** No Content */
        204: never;
        default: components['responses']['DEFAULT_ERROR'];
      };
    };
    parameters: {
      path: {
        customer_name: string;
      };
    };
  };
  '/customers/{customer_name}/revenue': {
    /** Fetch revenue of a customer from start_time and end_time. */
    get: {
      parameters: {
        path: {
          customer_name: string;
        };
        query: {
          start_time?: string;
          end_time?: string;
        };
      };
      responses: {
        /** OK */
        200: {
          content: {
            'application/json': components['schemas']['RevenueResponse'];
          };
        };
        422: components['responses']['UNPROCESSABLE_ENTITY'];
        default: components['responses']['DEFAULT_ERROR'];
      };
    };
    parameters: {
      path: {
        customer_name: string;
      };
    };
  };
  '/customers/{customer_name}/invoice/{invoice_id}/{token}': {
    /** Fetch current cycle revenue for a customer and generate an invoice. */
    get: {
      parameters: {
        path: {
          token: string;
          invoice_id: number;
          customer_name: string;
        };
      };
      responses: {
        default: components['responses']['DEFAULT_ERROR'];
      };
    };
    parameters: {
      path: {
        token: string;
        invoice_id: number;
        customer_name: string;
      };
    };
  };
  '/customers/{customer_name}/sample_invoice/{as_of_str}/{token}': {
    /** Fetch current cycle revenue for a customer and generate an invoice. */
    get: {
      parameters: {
        path: {
          token: string;
          as_of_str: string;
          customer_name: string;
        };
      };
      responses: {
        default: components['responses']['DEFAULT_ERROR'];
      };
    };
    parameters: {
      path: {
        token: string;
        as_of_str: string;
        customer_name: string;
      };
    };
  };
  '/customers/{customer_name}/sample_invoice/{token}': {
    /** Fetch current cycle revenue for a customer and generate an invoice. */
    get: {
      parameters: {
        path: {
          token: string;
          customer_name: string;
        };
      };
      responses: {
        default: components['responses']['DEFAULT_ERROR'];
      };
    };
    parameters: {
      path: {
        token: string;
        customer_name: string;
      };
    };
  };
  '/customers/{customer_name}/status': {
    /** Get the current status for a customer. */
    get: {
      parameters: {
        path: {
          customer_name: string;
        };
      };
      responses: {
        /** OK */
        200: {
          content: {
            'application/json': components['schemas']['CustomerStatus'];
          };
        };
        default: components['responses']['DEFAULT_ERROR'];
      };
    };
    parameters: {
      path: {
        customer_name: string;
      };
    };
  };
  '/customers/{customer_name}/usage': {
    /** For the given meter, get a customer's total usage. */
    get: {
      parameters: {
        path: {
          customer_name: string;
        };
        query: {
          /** Ending timestamp to consider usage formatted as ISO-8601. */
          end_time?: string;
          /** Starting timestamp to consider usage formatted as ISO-8601. */
          start_time?: string;
          meter_name?: string;
        };
      };
      responses: {
        /** OK */
        200: {
          content: {
            'application/json': components['schemas']['CustomerUsage'];
          };
        };
        422: components['responses']['UNPROCESSABLE_ENTITY'];
        default: components['responses']['DEFAULT_ERROR'];
      };
    };
    parameters: {
      path: {
        customer_name: string;
      };
    };
  };
  '/customers/{customer_name}/features/{feature_name}': {
    /** Get the details of a feature for a given customer. The feature's status is determined by their subscription first, and by their price plan if no feature overrides are found on the subscription. */
    get: {
      parameters: {
        path: {
          feature_name: string;
          customer_name: string;
        };
      };
      responses: {
        /** OK */
        200: {
          content: {
            'application/json': components['schemas']['CustomerFeature'];
          };
        };
        default: components['responses']['DEFAULT_ERROR'];
      };
    };
    parameters: {
      path: {
        feature_name: string;
        customer_name: string;
      };
    };
  };
  '/customers/{customer_name}/accrued_revenue': {
    /** Get the accrued revenue and invoice line items for the given customer. */
    get: {
      parameters: {
        path: {
          customer_name: string;
        };
      };
      responses: {
        /** OK */
        200: {
          content: {
            'application/json': components['schemas']['RevenueBreakdown'];
          };
        };
        default: components['responses']['DEFAULT_ERROR'];
      };
    };
    parameters: {
      path: {
        customer_name: string;
      };
    };
  };
  '/customers/{customer_name}/metadata': {
    /** Get the metadata for a given customer */
    get: {
      parameters: {
        path: {
          customer_name: string;
        };
      };
      responses: {
        /** OK */
        200: {
          content: {
            'application/json': components['schemas']['CustomerMetadata'][];
          };
        };
        default: components['responses']['DEFAULT_ERROR'];
      };
    };
    /** Add metadata to a customer (e.g., a tuple of Region: US for a US based customer) */
    post: {
      parameters: {
        path: {
          customer_name: string;
        };
      };
      responses: {
        /** OK */
        200: unknown;
        422: components['responses']['UNPROCESSABLE_ENTITY'];
        default: components['responses']['DEFAULT_ERROR'];
      };
      requestBody: {
        content: {
          'application/json': components['schemas']['CustomerMetadataInput'][];
        };
      };
    };
    parameters: {
      path: {
        customer_name: string;
      };
    };
  };
  '/customers/{customer_name}/invoices': {
    /** Get a list of invoices and their line items for a customer. */
    get: {
      parameters: {
        path: {
          customer_name: string;
        };
        query: {
          /** The sort column offset to start at when paging forwards */
          forward_sort_offset?: string;
          sort_direction?: string;
          sort_column?: string;
          /** The unique offset to start at when paging forwards */
          forward_secondary_sort_offset?: string;
          start_time?: string;
          customer_name?: string;
          /** The number of items to fetch. Defaults to 10. */
          limit?: number;
          status?: string;
        };
      };
      responses: {
        /** OK */
        200: {
          content: {
            'application/json': components['schemas']['Invoice'][];
          };
        };
        422: components['responses']['UNPROCESSABLE_ENTITY'];
        default: components['responses']['DEFAULT_ERROR'];
      };
    };
    parameters: {
      path: {
        customer_name: string;
      };
    };
  };
  '/customers/{customer_name}/credit_top_off_plan': {
    /** Get a customer's credit top off plan. */
    get: {
      parameters: {
        path: {
          customer_name: string;
        };
      };
      responses: {
        /** OK */
        200: {
          content: {
            'application/json': components['schemas']['CreditTopOffPlan'];
          };
        };
        default: components['responses']['DEFAULT_ERROR'];
      };
    };
    /** Update a customer's current credit top off plan. */
    put: {
      parameters: {
        path: {
          customer_name: string;
        };
      };
      responses: {
        /** OK */
        200: {
          content: {
            'application/json': components['schemas']['CreditTopOffPlan'];
          };
        };
        422: components['responses']['UNPROCESSABLE_ENTITY'];
        default: components['responses']['DEFAULT_ERROR'];
      };
      requestBody: {
        content: {
          'application/json': components['schemas']['UpdateCreditTopOffPlanInputArgs'];
        };
      };
    };
    /** Create a credit top off plan for a customer. */
    post: {
      parameters: {
        path: {
          customer_name: string;
        };
      };
      responses: {
        /** OK */
        200: {
          content: {
            'application/json': components['schemas']['CreditTopOffPlan'];
          };
        };
        422: components['responses']['UNPROCESSABLE_ENTITY'];
        default: components['responses']['DEFAULT_ERROR'];
      };
      requestBody: {
        content: {
          'application/json': components['schemas']['CreateCreditTopOffPlanInputArgs'];
        };
      };
    };
    /** Delete a customer's credit top off plan. */
    delete: {
      parameters: {
        path: {
          customer_name: string;
        };
      };
      responses: {
        /** No Content */
        204: never;
        default: components['responses']['DEFAULT_ERROR'];
      };
    };
    parameters: {
      path: {
        customer_name: string;
      };
    };
  };
  '/customers/{customer_name}/usage_across_meters/{token}': {
    /** Get the usage for a customer across all meters in XLS format for a given time period. */
    get: {
      parameters: {
        path: {
          token: string;
          customer_name: string;
        };
        query: {
          start_time: string;
          end_time: string;
        };
      };
      responses: {
        /** OK */
        200: unknown;
        422: components['responses']['UNPROCESSABLE_ENTITY'];
        default: components['responses']['DEFAULT_ERROR'];
      };
    };
    parameters: {
      path: {
        token: string;
        customer_name: string;
      };
    };
  };
  '/customers/{customer_name}/accounting/generation': {
    /** Create the customer entity tied to your accounting software. */
    post: {
      parameters: {
        path: {
          customer_name: string;
        };
      };
      responses: {
        /** OK */
        200: unknown;
        default: components['responses']['DEFAULT_ERROR'];
      };
    };
    parameters: {
      path: {
        customer_name: string;
      };
    };
  };
  '/customers/{customer_name}/accounting': {
    /** Get the accounting customer ID of a customer that has been connected via an accounting integration. */
    get: {
      parameters: {
        path: {
          customer_name: string;
        };
      };
      responses: {
        /** OK */
        200: {
          content: {
            'application/json': components['schemas']['AccountingCustomer'];
          };
        };
        default: components['responses']['DEFAULT_ERROR'];
      };
    };
    /** Connect an Octane customer to an Accounting customer through the configured Accounting integration. The vendor must have an integration configured. */
    post: {
      parameters: {
        path: {
          customer_name: string;
        };
      };
      responses: {
        /** OK */
        200: unknown;
        422: components['responses']['UNPROCESSABLE_ENTITY'];
        default: components['responses']['DEFAULT_ERROR'];
      };
      requestBody: {
        content: {
          'application/json': components['schemas']['AccountingCustomer'];
        };
      };
    };
    /** Deletes the customer entity tied to your accounting software. */
    delete: {
      parameters: {
        path: {
          customer_name: string;
        };
      };
      responses: {
        /** OK */
        200: unknown;
        default: components['responses']['DEFAULT_ERROR'];
      };
    };
    parameters: {
      path: {
        customer_name: string;
      };
    };
  };
  '/customers/{customer_name}/integration/tax/avalara/settings': {
    /** Returns the customer Avalara settings. */
    get: {
      parameters: {
        path: {
          customer_name: string;
        };
      };
      responses: {
        /** OK */
        200: {
          content: {
            'application/json': components['schemas']['CustomerAvalaraSettings'];
          };
        };
        default: components['responses']['DEFAULT_ERROR'];
      };
    };
    /** Updates the Avalara settings for a specific customer. */
    put: {
      parameters: {
        path: {
          customer_name: string;
        };
      };
      responses: {
        /** OK */
        200: {
          content: {
            'application/json': components['schemas']['CustomerAvalaraSettings'];
          };
        };
        422: components['responses']['UNPROCESSABLE_ENTITY'];
        default: components['responses']['DEFAULT_ERROR'];
      };
      requestBody: {
        content: {
          'application/json': components['schemas']['UpdateCustomerAvalaraSettingsArgs'];
        };
      };
    };
    parameters: {
      path: {
        customer_name: string;
      };
    };
  };
  '/customers/{customer_name}/integration/tax/avalara/address/valid': {
    /** Validates to ensure that customer address is taxable via Avalara. */
    get: {
      parameters: {
        path: {
          customer_name: string;
        };
      };
      responses: {
        /** OK */
        200: {
          content: {
            'application/json': components['schemas']['ValidateAddressResp'];
          };
        };
        default: components['responses']['DEFAULT_ERROR'];
      };
    };
    parameters: {
      path: {
        customer_name: string;
      };
    };
  };
  '/customers/{customer_name}/subscriptions': {
    /** Get all subscriptions for the customer. */
    get: {
      parameters: {
        path: {
          customer_name: string;
        };
      };
      responses: {
        /** OK */
        200: {
          content: {
            'application/json': components['schemas']['Subscription'][];
          };
        };
        default: components['responses']['DEFAULT_ERROR'];
      };
    };
    /** Create a new subscription for a customer / price plan combination (by unique name). */
    post: {
      parameters: {
        path: {
          customer_name: string;
        };
      };
      responses: {
        /** OK */
        200: {
          content: {
            'application/json': components['schemas']['Subscription'];
          };
        };
        422: components['responses']['UNPROCESSABLE_ENTITY'];
        default: components['responses']['DEFAULT_ERROR'];
      };
      requestBody: {
        content: {
          'application/json': components['schemas']['CreateSubscriptionArgs'];
        };
      };
    };
    parameters: {
      path: {
        customer_name: string;
      };
    };
  };
  '/customers/{customer_name}/subscription': {
    /** Update a subscription for a specific customer (by customer name). */
    put: {
      parameters: {
        path: {
          customer_name: string;
        };
      };
      responses: {
        /** OK */
        200: {
          content: {
            'application/json': components['schemas']['Subscription'];
          };
        };
        422: components['responses']['UNPROCESSABLE_ENTITY'];
        default: components['responses']['DEFAULT_ERROR'];
      };
      requestBody: {
        content: {
          'application/json': components['schemas']['UpdateSubscriptionArgs'];
        };
      };
    };
    /** Delete a subscription for a specific customer (by customer name). */
    delete: {
      parameters: {
        path: {
          customer_name: string;
        };
      };
      responses: {
        /** No Content */
        204: never;
        422: components['responses']['UNPROCESSABLE_ENTITY'];
        default: components['responses']['DEFAULT_ERROR'];
      };
      requestBody: {
        content: {
          'application/json': components['schemas']['DeleteSubscriptionArgs'];
        };
      };
    };
    parameters: {
      path: {
        customer_name: string;
      };
    };
  };
  '/customers/{customer_name}/subscription/update_in_place': {
    /** Update a subscription in-place for a specific customer (by customer name). */
    put: {
      parameters: {
        path: {
          customer_name: string;
        };
      };
      responses: {
        /** OK */
        200: {
          content: {
            'application/json': components['schemas']['Subscription'];
          };
        };
        422: components['responses']['UNPROCESSABLE_ENTITY'];
        default: components['responses']['DEFAULT_ERROR'];
      };
      requestBody: {
        content: {
          'application/json': components['schemas']['UpdateSubscriptionInPlaceArgs'];
        };
      };
    };
    parameters: {
      path: {
        customer_name: string;
      };
    };
  };
  '/customers/{customer_name}/active_subscription': {
    /** Get the customer's current active subscription. */
    get: {
      parameters: {
        path: {
          customer_name: string;
        };
      };
      responses: {
        /** OK */
        200: {
          content: {
            'application/json': components['schemas']['ActiveSubscription'];
          };
        };
        default: components['responses']['DEFAULT_ERROR'];
      };
    };
    parameters: {
      path: {
        customer_name: string;
      };
    };
  };
  '/customers/{customer_name}/scheduled_subscriptions': {
    /** Get a list of any subscriptions scheduled to start in the future for the given customer. */
    get: {
      parameters: {
        path: {
          customer_name: string;
        };
      };
      responses: {
        /** OK */
        200: {
          content: {
            'application/json': components['schemas']['Subscription'][];
          };
        };
        default: components['responses']['DEFAULT_ERROR'];
      };
    };
    parameters: {
      path: {
        customer_name: string;
      };
    };
  };
  '/customers/{customer_name}/subscription/add_ons': {
    /** Add or remove add ons from the current customer's subscription. */
    post: {
      parameters: {
        path: {
          customer_name: string;
        };
      };
      responses: {
        /** OK */
        200: unknown;
        422: components['responses']['UNPROCESSABLE_ENTITY'];
        default: components['responses']['DEFAULT_ERROR'];
      };
      requestBody: {
        content: {
          'application/json': components['schemas']['SubscriptionAddOnItem'][];
        };
      };
    };
    parameters: {
      path: {
        customer_name: string;
      };
    };
  };
  '/customers/{customer_name}/discounts': {
    /**
     * Add discounts to the list of discounts on the customer's current subscription. The new discounts will be
     * effective_at of the start of the current billing cycle.
     */
    post: {
      parameters: {
        path: {
          customer_name: string;
        };
      };
      responses: {
        /** OK */
        200: unknown;
        422: components['responses']['UNPROCESSABLE_ENTITY'];
        default: components['responses']['DEFAULT_ERROR'];
      };
      requestBody: {
        content: {
          'application/json': components['schemas']['DiscountInputArgs'][];
        };
      };
    };
    /**
     * Delete a discount from the customer's current subscription. If the discount started before the
     * start of the current billing cycle, we will expire it by setting it's end date to the start of
     * the current billing cycle. Otherwise, we will delete the discount.
     */
    delete: {
      parameters: {
        path: {
          customer_name: string;
        };
      };
      responses: {
        /** No Content */
        204: never;
        422: components['responses']['UNPROCESSABLE_ENTITY'];
        default: components['responses']['DEFAULT_ERROR'];
      };
      requestBody: {
        content: {
          'application/json': components['schemas']['DeleteDiscountInputArgs'];
        };
      };
    };
    parameters: {
      path: {
        customer_name: string;
      };
    };
  };
  '/invoices/{invoice_uuid}': {
    /** Get a specific invoice via it's UUID. */
    get: {
      parameters: {
        path: {
          invoice_uuid: string;
        };
      };
      responses: {
        /** OK */
        200: {
          content: {
            'application/json': components['schemas']['Invoice'];
          };
        };
        default: components['responses']['DEFAULT_ERROR'];
      };
    };
    /** Delete a specific invoice via it's UUID. Invoices can only be deleted if they have not been issued. */
    delete: {
      parameters: {
        path: {
          invoice_uuid: string;
        };
      };
      responses: {
        /** No Content */
        204: never;
        default: components['responses']['DEFAULT_ERROR'];
      };
    };
    parameters: {
      path: {
        invoice_uuid: string;
      };
    };
  };
  '/invoices/{invoice_uuid}/status/': {
    /**
     * Manually change the status of an invoice in Octane. For example,
     * if an invoice was paid outside of Octane's payment providers, you can reflect that in Octane by
     * setting the status to paid.
     */
    post: {
      parameters: {
        path: {
          invoice_uuid: string;
        };
      };
      responses: {
        /** OK */
        200: unknown;
        default: components['responses']['DEFAULT_ERROR'];
      };
    };
    parameters: {
      path: {
        invoice_uuid: string;
      };
    };
  };
  '/invoices/': {
    /** Fetch a list of historical invoices generated by Octane. */
    get: {
      parameters: {
        query: {
          /** The sort column offset to start at when paging forwards */
          forward_sort_offset?: string;
          sort_direction?: string;
          sort_column?: string;
          /** The unique offset to start at when paging forwards */
          forward_secondary_sort_offset?: string;
          start_time?: string;
          customer_name?: string;
          /** The number of items to fetch. Defaults to 10. */
          limit?: number;
          status?: string;
        };
      };
      responses: {
        /** OK */
        200: {
          content: {
            'application/json': components['schemas']['PastInvoices'];
          };
        };
        422: components['responses']['UNPROCESSABLE_ENTITY'];
        default: components['responses']['DEFAULT_ERROR'];
      };
    };
  };
  '/invoices/{invoice_uuid_token}/pdf': {
    /** Return the invoice pdf for the given invoice_uuid, first validating token. */
    get: {
      parameters: {
        path: {
          invoice_uuid_token: string;
        };
      };
      responses: {
        default: components['responses']['DEFAULT_ERROR'];
      };
    };
    parameters: {
      path: {
        invoice_uuid_token: string;
      };
    };
  };
  '/invoices/{invoice_uuid}/retries': {
    /**
     * Moves the invoice into the next logical action. For example, an invoice that is generated gets moved to issued, and
     * an invoice that is in payment error tries payment again. For more information see our docs https://docs.getoctane.io/docs/manual-invoicing-triggers.
     */
    post: {
      parameters: {
        path: {
          invoice_uuid: string;
        };
      };
      responses: {
        /** Accepted */
        202: {
          content: {
            'application/json': components['schemas']['Retry'];
          };
        };
        422: components['responses']['UNPROCESSABLE_ENTITY'];
        default: components['responses']['DEFAULT_ERROR'];
      };
      requestBody: {
        content: {
          'application/json': components['schemas']['CreateRetryArgs'];
        };
      };
    };
    parameters: {
      path: {
        invoice_uuid: string;
      };
    };
  };
  '/price_plans/': {
    /** Get all price plans associated with a vendor. */
    get: {
      responses: {
        /** OK */
        200: {
          content: {
            'application/json': components['schemas']['PricePlan'][];
          };
        };
        default: components['responses']['DEFAULT_ERROR'];
      };
    };
    /** Create a price plan for a vendor. */
    post: {
      responses: {
        /** OK */
        200: {
          content: {
            'application/json': components['schemas']['PricePlan'];
          };
        };
        422: components['responses']['UNPROCESSABLE_ENTITY'];
        default: components['responses']['DEFAULT_ERROR'];
      };
      requestBody: {
        content: {
          'application/json': components['schemas']['CreatePricePlanArgs'];
        };
      };
    };
  };
  '/price_plans/{price_plan_name}/{tag}': {
    /** Get an existing price plan. */
    get: {
      parameters: {
        path: {
          tag: string;
          price_plan_name: string;
        };
      };
      responses: {
        /** OK */
        200: {
          content: {
            'application/json': components['schemas']['PricePlan'];
          };
        };
        default: components['responses']['DEFAULT_ERROR'];
      };
    };
    parameters: {
      path: {
        tag: string;
        price_plan_name: string;
      };
    };
  };
  '/price_plans/paginate': {
    /** List all price plans with pagination. */
    get: {
      parameters: {
        query: {
          tags?: string[];
          /** The sort column offset to start at when paging forwards */
          forward_sort_offset?: string;
          sort_direction?: string;
          sort_column?: string;
          /** The unique offset to start at when paging forwards */
          forward_secondary_sort_offset?: string;
          names?: string[];
          /** The number of items to fetch. Defaults to 10. */
          limit?: number;
        };
      };
      responses: {
        /** OK */
        200: {
          content: {
            'application/json': components['schemas']['ListPricePlans'];
          };
        };
        422: components['responses']['UNPROCESSABLE_ENTITY'];
        default: components['responses']['DEFAULT_ERROR'];
      };
    };
  };
  '/price_plans/{price_plan_name}': {
    /** Fetch an existing price plan. */
    get: {
      parameters: {
        path: {
          price_plan_name: string;
        };
      };
      responses: {
        /** OK */
        200: {
          content: {
            'application/json': components['schemas']['PricePlan'];
          };
        };
        default: components['responses']['DEFAULT_ERROR'];
      };
    };
    /** Update an existing price plan. */
    put: {
      parameters: {
        path: {
          price_plan_name: string;
        };
      };
      responses: {
        /** OK */
        200: {
          content: {
            'application/json': components['schemas']['PricePlan'];
          };
        };
        422: components['responses']['UNPROCESSABLE_ENTITY'];
        default: components['responses']['DEFAULT_ERROR'];
      };
      requestBody: {
        content: {
          'application/json': components['schemas']['UpdatePricePlanArgs'];
        };
      };
    };
    /** Delete an existing Price Plan. Price Plans which map to active Subscriptions must be replaced or removed before deletion can occur. */
    delete: {
      parameters: {
        path: {
          price_plan_name: string;
        };
      };
      responses: {
        /** No Content */
        204: never;
        default: components['responses']['DEFAULT_ERROR'];
      };
    };
    parameters: {
      path: {
        price_plan_name: string;
      };
    };
  };
  '/price_plans/update_in_place/{price_plan_name}/{tag}': {
    /** Edit a price plan without creating a new version. */
    post: {
      parameters: {
        path: {
          tag: string;
          price_plan_name: string;
        };
      };
      responses: {
        /** OK */
        200: {
          content: {
            'application/json': components['schemas']['PricePlan'];
          };
        };
        422: components['responses']['UNPROCESSABLE_ENTITY'];
        default: components['responses']['DEFAULT_ERROR'];
      };
      requestBody: {
        content: {
          'application/json': components['schemas']['UpdatePricePlanInPlaceArgs'];
        };
      };
    };
    parameters: {
      path: {
        tag: string;
        price_plan_name: string;
      };
    };
  };
  '/price_plans/update_in_place/{price_plan_name}': {
    /** Edit a price plan without creating a new version. */
    post: {
      parameters: {
        path: {
          price_plan_name: string;
        };
      };
      responses: {
        /** OK */
        200: {
          content: {
            'application/json': components['schemas']['PricePlan'];
          };
        };
        422: components['responses']['UNPROCESSABLE_ENTITY'];
        default: components['responses']['DEFAULT_ERROR'];
      };
      requestBody: {
        content: {
          'application/json': components['schemas']['UpdatePricePlanInPlaceArgs'];
        };
      };
    };
    parameters: {
      path: {
        price_plan_name: string;
      };
    };
  };
  '/price_plans/{price_plan_name}/archive': {
    /** Archive a price plan that has no active/scheduled subscription. */
    post: {
      parameters: {
        path: {
          price_plan_name: string;
        };
      };
      responses: {
        /** OK */
        200: unknown;
        default: components['responses']['DEFAULT_ERROR'];
      };
    };
    parameters: {
      path: {
        price_plan_name: string;
      };
    };
  };
  '/price_plans/self_serve': {
    /** Get all price plans marked for self serve for this vendor. */
    get: {
      responses: {
        /** OK */
        200: {
          content: {
            'application/json': components['schemas']['PricePlan'][];
          };
        };
        default: components['responses']['DEFAULT_ERROR'];
      };
    };
    /** Set the exhaustive list of price plans that the customer can see and select via self serve. */
    post: {
      responses: {
        /** OK */
        200: unknown;
        422: components['responses']['UNPROCESSABLE_ENTITY'];
        default: components['responses']['DEFAULT_ERROR'];
      };
      requestBody: {
        content: {
          'application/json': components['schemas']['SelfServePricePlansInputArgs'];
        };
      };
    };
  };
  '/price_plans/{uuid}/add_features': {
    /** Add features and(or) limits to a price plan in place */
    post: {
      parameters: {
        path: {
          uuid: string;
        };
      };
      responses: {
        /** OK */
        200: {
          content: {
            'application/json': components['schemas']['PricePlan'];
          };
        };
        422: components['responses']['UNPROCESSABLE_ENTITY'];
        default: components['responses']['DEFAULT_ERROR'];
      };
      requestBody: {
        content: {
          'application/json': components['schemas']['AddFeaturesToPricePlanInput'];
        };
      };
    };
    parameters: {
      path: {
        uuid: string;
      };
    };
  };
  '/price_plans/{uuid}/remove_features': {
    /** Remove features and(or) limits from a price plan in place */
    post: {
      parameters: {
        path: {
          uuid: string;
        };
      };
      responses: {
        /** OK */
        200: {
          content: {
            'application/json': components['schemas']['PricePlan'];
          };
        };
        422: components['responses']['UNPROCESSABLE_ENTITY'];
        default: components['responses']['DEFAULT_ERROR'];
      };
      requestBody: {
        content: {
          'application/json': components['schemas']['RemoveFeaturesFromPricePlanInput'];
        };
      };
    };
    parameters: {
      path: {
        uuid: string;
      };
    };
  };
  '/price_plans/{uuid}/add_add_ons': {
    /** Add add ons to price plan in place */
    post: {
      parameters: {
        path: {
          uuid: string;
        };
      };
      responses: {
        /** OK */
        200: {
          content: {
            'application/json': components['schemas']['PricePlan'];
          };
        };
        422: components['responses']['UNPROCESSABLE_ENTITY'];
        default: components['responses']['DEFAULT_ERROR'];
      };
      requestBody: {
        content: {
          'application/json': components['schemas']['AddAddOnsToPricePlanInput'];
        };
      };
    };
    parameters: {
      path: {
        uuid: string;
      };
    };
  };
  '/price_plans/{uuid}/add_metered_components': {
    /** Add metered components to price plan in place */
    post: {
      parameters: {
        path: {
          uuid: string;
        };
      };
      responses: {
        /** OK */
        200: {
          content: {
            'application/json': components['schemas']['PricePlan'];
          };
        };
        422: components['responses']['UNPROCESSABLE_ENTITY'];
        default: components['responses']['DEFAULT_ERROR'];
      };
      requestBody: {
        content: {
          'application/json': components['schemas']['AddMeteredComponentsToPricePlanInput'];
        };
      };
    };
    parameters: {
      path: {
        uuid: string;
      };
    };
  };
  '/price_plans/metered_components/{uuid}/update_limits': {
    /** Update metered component usage limits in place */
    post: {
      parameters: {
        path: {
          uuid: string;
        };
      };
      responses: {
        /** OK */
        200: {
          content: {
            'application/json': components['schemas']['MeteredComponent'];
          };
        };
        422: components['responses']['UNPROCESSABLE_ENTITY'];
        default: components['responses']['DEFAULT_ERROR'];
      };
      requestBody: {
        content: {
          'application/json': components['schemas']['UpdateMeteredComponentLimitsInput'];
        };
      };
    };
    parameters: {
      path: {
        uuid: string;
      };
    };
  };
  '/payment_gateway_credentials/': {
    /** Returns the payment gateway information for your account (the Paddle or Stripe credentials used to issue and pay invoices) */
    get: {
      responses: {
        /** OK */
        200: {
          content: {
            'application/json': components['schemas']['PaymentGatewayCredential'];
          };
        };
        default: components['responses']['DEFAULT_ERROR'];
      };
    };
    /** Adds the credentials for a payment gateway, to be used to issue and pay invoices to your account. */
    post: {
      responses: {
        /** OK */
        200: {
          content: {
            'application/json': components['schemas']['PaymentGatewayCredential'];
          };
        };
        422: components['responses']['UNPROCESSABLE_ENTITY'];
        default: components['responses']['DEFAULT_ERROR'];
      };
      requestBody: {
        content: {
          'application/json': components['schemas']['PaymentGatewayCredentialInputArgs'];
        };
      };
    };
  };
  '/billing_settings/': {
    /** Get billing settings for a vendor. */
    get: {
      responses: {
        /** OK */
        200: {
          content: {
            'application/json': components['schemas']['BillingSettings'];
          };
        };
        default: components['responses']['DEFAULT_ERROR'];
      };
    };
    /** Update billing settings for a vendor. */
    put: {
      responses: {
        /** OK */
        200: {
          content: {
            'application/json': components['schemas']['BillingSettings'];
          };
        };
        422: components['responses']['UNPROCESSABLE_ENTITY'];
        default: components['responses']['DEFAULT_ERROR'];
      };
      requestBody: {
        content: {
          'application/json': components['schemas']['UpdateBillingSettingsInputArgs'];
        };
      };
    };
    /** Create billing settings for a vendor. */
    post: {
      responses: {
        /** OK */
        200: {
          content: {
            'application/json': components['schemas']['BillingSettings'];
          };
        };
        422: components['responses']['UNPROCESSABLE_ENTITY'];
        default: components['responses']['DEFAULT_ERROR'];
      };
      requestBody: {
        content: {
          'application/json': components['schemas']['CreateBillingSettingsInputArgs'];
        };
      };
    };
    /** Delete billing settings for a vendor. */
    delete: {
      responses: {
        /** No Content */
        204: never;
        default: components['responses']['DEFAULT_ERROR'];
      };
    };
  };
  '/coupons/': {
    /** Gets all coupons for a specific vendor. */
    get: {
      responses: {
        /** OK */
        200: {
          content: {
            'application/json': components['schemas']['Coupon'][];
          };
        };
        default: components['responses']['DEFAULT_ERROR'];
      };
    };
    /** Create a coupon for a vendor. */
    post: {
      responses: {
        /** OK */
        200: {
          content: {
            'application/json': components['schemas']['Coupon'];
          };
        };
        422: components['responses']['UNPROCESSABLE_ENTITY'];
        default: components['responses']['DEFAULT_ERROR'];
      };
      requestBody: {
        content: {
          'application/json': components['schemas']['CouponInputArgs'];
        };
      };
    };
  };
  '/coupons/{coupon_name}': {
    /** Get a specific coupon for a vendor. */
    get: {
      parameters: {
        path: {
          coupon_name: string;
        };
      };
      responses: {
        /** OK */
        200: {
          content: {
            'application/json': components['schemas']['Coupon'];
          };
        };
        default: components['responses']['DEFAULT_ERROR'];
      };
    };
    /** Delete a specific coupon for a vendor. */
    delete: {
      parameters: {
        path: {
          coupon_name: string;
        };
      };
      responses: {
        /** No Content */
        204: never;
        default: components['responses']['DEFAULT_ERROR'];
      };
    };
    parameters: {
      path: {
        coupon_name: string;
      };
    };
  };
  '/coupons/apply_coupon': {
    /** Apply a coupon to the provided customer. */
    post: {
      responses: {
        /** OK */
        200: unknown;
        422: components['responses']['UNPROCESSABLE_ENTITY'];
        default: components['responses']['DEFAULT_ERROR'];
      };
      requestBody: {
        content: {
          'application/json': components['schemas']['ApplyCouponInputArgs'];
        };
      };
    };
  };
  '/refund/': {
    /** Create a refund for a paid invoice. */
    post: {
      responses: {
        /** Accepted */
        202: {
          content: {
            'application/json': components['schemas']['Refund'];
          };
        };
        422: components['responses']['UNPROCESSABLE_ENTITY'];
        default: components['responses']['DEFAULT_ERROR'];
      };
      requestBody: {
        content: {
          'application/json': components['schemas']['CreateRefundArgs'];
        };
      };
    };
  };
  '/customer_portal_settings/': {
    /** Fetch the Customer Portal settings for your account. */
    get: {
      responses: {
        /** OK */
        200: {
          content: {
            'application/json': components['schemas']['CustomerPortalSettings'];
          };
        };
        default: components['responses']['DEFAULT_ERROR'];
      };
    };
    /** Update Customer Portal settings for your account. */
    post: {
      responses: {
        /** OK */
        200: {
          content: {
            'application/json': components['schemas']['CustomerPortalSettings'];
          };
        };
        422: components['responses']['UNPROCESSABLE_ENTITY'];
        default: components['responses']['DEFAULT_ERROR'];
      };
      requestBody: {
        content: {
          'application/json': components['schemas']['UpdateCustomerPortalSettingsInputArgs'];
        };
      };
    };
  };
  '/ecp/token': {
    /** Generate a customer-scoped JWT to authorize access to ECP endpoints. This endpoint expects the vendor API key for authentication. */
    post: {
      responses: {
        /** OK */
        200: {
          content: {
            'application/json': components['schemas']['CustomerPortalToken'];
          };
        };
        422: components['responses']['UNPROCESSABLE_ENTITY'];
        default: components['responses']['DEFAULT_ERROR'];
      };
      requestBody: {
        content: {
          'application/json': components['schemas']['CustomerPortalTokenInputArgs'];
        };
      };
    };
  };
  '/ecp/customer_portal_url': {
    /** Generate the url to the customer portal. This endpoint expects the vendor API key for authentication. */
    post: {
      responses: {
        /** OK */
        200: {
          content: {
            'application/json': components['schemas']['CustomerPortalUrl'];
          };
        };
        422: components['responses']['UNPROCESSABLE_ENTITY'];
        default: components['responses']['DEFAULT_ERROR'];
      };
      requestBody: {
        content: {
          'application/json': components['schemas']['CustomerPortalTokenInputArgs'];
        };
      };
    };
  };
  '/ecp/portal_url': {
    /** Get the url to the customer portal. This endpoint expects the customer-scoped token for authentication. */
    get: {
      responses: {
        /** OK */
        200: {
          content: {
            'application/json': components['schemas']['CustomerPortalUrl'];
          };
        };
        default: components['responses']['DEFAULT_ERROR'];
      };
    };
  };
  '/ecp/vendor': {
    /** Get relevant information about the customer's vendor. This endpoint expects the customer-scoped token for authentication. */
    get: {
      responses: {
        /** OK */
        200: {
          content: {
            'application/json': components['schemas']['CustomerPortalVendor'];
          };
        };
        default: components['responses']['DEFAULT_ERROR'];
      };
    };
  };
  '/ecp/price_plans': {
    /** Get all price plans visible to the given customer for self serve. By default, no price plans are visible. Price plan visibility can be configured by the vendor using the /price_plans/self_serve endpoint. */
    get: {
      responses: {
        /** OK */
        200: {
          content: {
            'application/json': components['schemas']['PricePlan'][];
          };
        };
        default: components['responses']['DEFAULT_ERROR'];
      };
    };
  };
  '/ecp/invoices': {
    /** Get all invoices visible to the given customer. This endpoint expects the customer-scoped token for authentication. */
    get: {
      responses: {
        /** OK */
        200: {
          content: {
            'application/json': components['schemas']['CustomerPortalInvoice'][];
          };
        };
        default: components['responses']['DEFAULT_ERROR'];
      };
    };
  };
  '/ecp/active_subscription': {
    /** Fetch the customer's active subscription and related information if they exists. This endpoint expects the customer-scoped token for authentication. */
    get: {
      responses: {
        /** OK */
        200: {
          content: {
            'application/json': components['schemas']['CustomerPortalActiveSubscription'];
          };
        };
        default: components['responses']['DEFAULT_ERROR'];
      };
    };
    /** Create/update the customer's subscription. This endpoint expects the customer-scoped token for authentication. */
    post: {
      responses: {
        /** OK */
        200: {
          content: {
            'application/json': components['schemas']['CustomerPortalSubscription'];
          };
        };
        422: components['responses']['UNPROCESSABLE_ENTITY'];
        default: components['responses']['DEFAULT_ERROR'];
      };
      requestBody: {
        content: {
          'application/json': components['schemas']['CustomerPortalActiveSubscriptionInputArgs'];
        };
      };
    };
  };
  '/ecp/subscription': {
    /** Fetch the customer's active price plan if it exists. This endpoint expects the customer-scoped token for authentication. */
    get: {
      responses: {
        /** OK */
        200: {
          content: {
            'application/json': components['schemas']['CustomerPortalSubscription'];
          };
        };
        default: components['responses']['DEFAULT_ERROR'];
      };
    };
    /** Create/update the customer's subscription. This endpoint expects the customer-scoped token for authentication. */
    post: {
      responses: {
        /** OK */
        200: {
          content: {
            'application/json': components['schemas']['CustomerPortalSubscription'];
          };
        };
        422: components['responses']['UNPROCESSABLE_ENTITY'];
        default: components['responses']['DEFAULT_ERROR'];
      };
      requestBody: {
        content: {
          'application/json': components['schemas']['CustomerPortalSubscriptionInputArgs'];
        };
      };
    };
    /** Cancel the customer's subscription. This endpoint expects the customer-scoped token for authentication. */
    delete: {
      responses: {
        /** No Content */
        204: never;
        default: components['responses']['DEFAULT_ERROR'];
      };
    };
  };
  '/ecp/setup_intent': {
    /** Attempt to create a Stripe SetupIntent object. This endpoint expects the customer-scoped token for authentication. */
    post: {
      responses: {
        /** OK */
        200: {
          content: {
            'application/json': components['schemas']['CustomerPortalStripeCredential'];
          };
        };
        default: components['responses']['DEFAULT_ERROR'];
      };
    };
  };
  '/ecp/payment_method_status': {
    /** Gets the customer's current payment method status. Returns a 400 if the customer has no configuration or if the current payment provider doesn't have customer-level payment status. This endpoint expects the customer-scoped token for authentication. */
    get: {
      responses: {
        /** OK */
        200: {
          content: {
            'application/json': components['schemas']['CustomerPaymentMethodStatus'];
          };
        };
        default: components['responses']['DEFAULT_ERROR'];
      };
    };
  };
  '/ecp/contact_info': {
    /** Gets the customer's contact info. This endpoint expects the customer-scoped token for authentication. */
    get: {
      responses: {
        /** OK */
        200: {
          content: {
            'application/json': components['schemas']['ContactInfo'];
          };
        };
        default: components['responses']['DEFAULT_ERROR'];
      };
    };
    /** Create/update the customer's contact info. This endpoint expects the customer-scoped token for authentication. */
    put: {
      responses: {
        /** OK */
        200: {
          content: {
            'application/json': components['schemas']['ContactInfo'];
          };
        };
        422: components['responses']['UNPROCESSABLE_ENTITY'];
        default: components['responses']['DEFAULT_ERROR'];
      };
      requestBody: {
        content: {
          'application/json': components['schemas']['ContactInfoInputArgs'];
        };
      };
    };
  };
  '/ecp/meters': {
    /** Get the meters and corresponding primary label keys and values from the customer's active subscription. */
    get: {
      responses: {
        /** OK */
        200: {
          content: {
            'application/json': components['schemas']['CustomerPortalMeter'][];
          };
        };
        default: components['responses']['DEFAULT_ERROR'];
      };
    };
  };
  '/ecp/usage': {
    /**
     * [DEPRECATED] Get the customer's daily usage by meter for current and previous billing cycles. This endpoint expects the customer-scoped token for authentication.
     *
     * Please use /ecp/filtered_usage instead.
     */
    get: {
      responses: {
        /** OK */
        200: {
          content: {
            'application/json': components['schemas']['CustomerPortalUsage'][];
          };
        };
        default: components['responses']['DEFAULT_ERROR'];
      };
    };
  };
  '/ecp/filtered_usage': {
    /** Get the customer's daily usage filtered by the inputted meter and labels. This endpoint expects the customer-scoped token for authentication. */
    post: {
      responses: {
        /** OK */
        200: {
          content: {
            'application/json': components['schemas']['CustomerPortalUsage'];
          };
        };
        422: components['responses']['UNPROCESSABLE_ENTITY'];
        default: components['responses']['DEFAULT_ERROR'];
      };
      requestBody: {
        content: {
          'application/json': components['schemas']['CustomerPortalMeterLabelFilter'];
        };
      };
    };
  };
  '/ecp/payment_method': {
    /** Get the customer's current payment method if it exists in their payment gateway. This endpoint expects the customer-scoped token for authentication. */
    get: {
      responses: {
        /** OK */
        200: {
          content: {
            'application/json': components['schemas']['CustomerPortalPaymentMethod'];
          };
        };
        default: components['responses']['DEFAULT_ERROR'];
      };
    };
  };
  '/ecp/self_serve_settings': {
    /** Get the customer's self serve settings. This endpoint expects the customer-scoped token for authentication. */
    get: {
      responses: {
        /** OK */
        200: {
          content: {
            'application/json': components['schemas']['SelfServeSettings'];
          };
        };
        default: components['responses']['DEFAULT_ERROR'];
      };
    };
  };
  '/ecp/self_serve_customization': {
    /** Get the customer's self serve customization. This endpoint expects the customer-scoped token for authentication. */
    get: {
      responses: {
        /** OK */
        200: {
          content: {
            'application/json': components['schemas']['SelfServeCustomization'];
          };
        };
        default: components['responses']['DEFAULT_ERROR'];
      };
    };
  };
  '/ecp/credit/ledger': {
    /** Returns the customer entire credit ledger. This can be used to compute the current and available credit balance. This endpoint expects the customer-scoped token for authentication. */
    get: {
      responses: {
        /** OK */
        200: {
          content: {
            'application/json': components['schemas']['CreditLedger'][];
          };
        };
        default: components['responses']['DEFAULT_ERROR'];
      };
    };
  };
  '/ecp/credit/purchase': {
    /** Purchase the provided amount of credits at the default expiration and price set by the vendor. This endpoint expects the customer-scoped token for authentication. */
    post: {
      responses: {
        /** OK */
        200: {
          content: {
            'application/json': components['schemas']['CreditGrant'];
          };
        };
        422: components['responses']['UNPROCESSABLE_ENTITY'];
        default: components['responses']['DEFAULT_ERROR'];
      };
      requestBody: {
        content: {
          'application/json': components['schemas']['CustomerPortalCreditPurchase'];
        };
      };
    };
  };
  '/webhooks/': {
    /** Get all Webhooks for a given Vendor. */
    get: {
      responses: {
        /** OK */
        200: {
          content: {
            'application/json': components['schemas']['Webhook'][];
          };
        };
        default: components['responses']['DEFAULT_ERROR'];
      };
    };
    /** Add an endpoint to use with Octane's Webhook API. */
    post: {
      responses: {
        /** OK */
        200: {
          content: {
            'application/json': components['schemas']['Webhook'];
          };
        };
        422: components['responses']['UNPROCESSABLE_ENTITY'];
        default: components['responses']['DEFAULT_ERROR'];
      };
      requestBody: {
        content: {
          'application/json': components['schemas']['CreateWebhookArgs'];
        };
      };
    };
  };
  '/webhooks/{uuid}': {
    /** Retrieve a webhook given its UUID. */
    get: {
      parameters: {
        path: {
          uuid: string;
        };
      };
      responses: {
        /** OK */
        200: {
          content: {
            'application/json': components['schemas']['Webhook'];
          };
        };
        default: components['responses']['DEFAULT_ERROR'];
      };
    };
    /** Delete and unregister a webhook URL given its UUID. */
    delete: {
      parameters: {
        path: {
          uuid: string;
        };
      };
      responses: {
        /** No Content */
        204: never;
        default: components['responses']['DEFAULT_ERROR'];
      };
    };
    parameters: {
      path: {
        uuid: string;
      };
    };
  };
  '/credits/grant/': {
    /** Returns all the credit grants under your account. */
    get: {
      responses: {
        /** OK */
        200: {
          content: {
            'application/json': components['schemas']['ListCreditGrants'];
          };
        };
        422: components['responses']['UNPROCESSABLE_ENTITY'];
        default: components['responses']['DEFAULT_ERROR'];
      };
      requestBody: {
        content: {
          'application/json': components['schemas']['ListCreditGrantsArgs'];
        };
      };
    };
    /** Creates a credit grant for one of your customers. */
    post: {
      responses: {
        /** OK */
        200: {
          content: {
            'application/json': components['schemas']['CreditGrant'];
          };
        };
        422: components['responses']['UNPROCESSABLE_ENTITY'];
        default: components['responses']['DEFAULT_ERROR'];
      };
      requestBody: {
        content: {
          'application/json': components['schemas']['CreateCreditGrantArgs'];
        };
      };
    };
  };
  '/credits/grant/{grant_uuid}/void': {
    /** Deactivates a credit grant with the given grant UUID. */
    post: {
      parameters: {
        path: {
          grant_uuid: string;
        };
      };
      responses: {
        /** OK */
        200: unknown;
        default: components['responses']['DEFAULT_ERROR'];
      };
    };
    parameters: {
      path: {
        grant_uuid: string;
      };
    };
  };
  '/credits/ledger/{customer_name}/{as_of_str}': {
    /** Returns the credit ledger for one of your customers. */
    get: {
      parameters: {
        path: {
          as_of_str: string;
          customer_name: string;
        };
      };
      responses: {
        /** OK */
        200: {
          content: {
            'application/json': components['schemas']['CreditLedger'][];
          };
        };
        default: components['responses']['DEFAULT_ERROR'];
      };
    };
    parameters: {
      path: {
        as_of_str: string;
        customer_name: string;
      };
    };
  };
  '/credits/ledger/{customer_name}/': {
    /** Returns the credit ledger for one of your customers. */
    get: {
      parameters: {
        path: {
          customer_name: string;
        };
      };
      responses: {
        /** OK */
        200: {
          content: {
            'application/json': components['schemas']['CreditLedger'][];
          };
        };
        default: components['responses']['DEFAULT_ERROR'];
      };
    };
    parameters: {
      path: {
        customer_name: string;
      };
    };
  };
  '/admin/api_key/roll': {
    /** Expires the specified API key and creates a new one. */
    post: {
      responses: {
        /** OK */
        200: {
          content: {
            'application/json': components['schemas']['RollApiKeys'];
          };
        };
        422: components['responses']['UNPROCESSABLE_ENTITY'];
        default: components['responses']['DEFAULT_ERROR'];
      };
      requestBody: {
        content: {
          'application/json': components['schemas']['RollApiKeyArgs'];
        };
      };
    };
  };
  '/self_serve_settings/': {
    /** Get self serve settings for a vendor. */
    get: {
      responses: {
        /** OK */
        200: {
          content: {
            'application/json': components['schemas']['SelfServeSettings'];
          };
        };
        default: components['responses']['DEFAULT_ERROR'];
      };
    };
    /**
     * Update the self serve settings for a vendor. If partial fields
     * are given, we will only update the provided fields.
     */
    put: {
      responses: {
        /** OK */
        200: {
          content: {
            'application/json': components['schemas']['SelfServeSettings'];
          };
        };
        422: components['responses']['UNPROCESSABLE_ENTITY'];
        default: components['responses']['DEFAULT_ERROR'];
      };
      requestBody: {
        content: {
          'application/json': components['schemas']['UpdateSelfServeSettingsArgs'];
        };
      };
    };
    /**
     * Create the self serve settings for a vendor. If partial fields
     * are given, we will fallback on default values.
     */
    post: {
      responses: {
        /** OK */
        200: {
          content: {
            'application/json': components['schemas']['SelfServeSettings'];
          };
        };
        422: components['responses']['UNPROCESSABLE_ENTITY'];
        default: components['responses']['DEFAULT_ERROR'];
      };
      requestBody: {
        content: {
          'application/json': components['schemas']['UpdateSelfServeSettingsArgs'];
        };
      };
    };
  };
  '/self_serve_settings/customization': {
    /** Get the customization settings for the vendor's customer portal. */
    get: {
      responses: {
        /** OK */
        200: {
          content: {
            'application/json': components['schemas']['SelfServeCustomization'];
          };
        };
        default: components['responses']['DEFAULT_ERROR'];
      };
    };
    /** Update the customization settings for the vendor's customer portal. */
    put: {
      responses: {
        /** OK */
        200: {
          content: {
            'application/json': components['schemas']['SelfServeCustomization'];
          };
        };
        422: components['responses']['UNPROCESSABLE_ENTITY'];
        default: components['responses']['DEFAULT_ERROR'];
      };
      requestBody: {
        content: {
          'application/json': components['schemas']['SelfServeCustomization'];
        };
      };
    };
    /** Create the customization settings for the vendor's customer portal. */
    post: {
      responses: {
        /** OK */
        200: {
          content: {
            'application/json': components['schemas']['SelfServeCustomization'];
          };
        };
        422: components['responses']['UNPROCESSABLE_ENTITY'];
        default: components['responses']['DEFAULT_ERROR'];
      };
      requestBody: {
        content: {
          'application/json': components['schemas']['SelfServeCustomization'];
        };
      };
    };
  };
  '/integration/tax/avalara/settings': {
    /** Returns the vendor Avalara settings. */
    get: {
      responses: {
        /** OK */
        200: {
          content: {
            'application/json': components['schemas']['VendorAvalaraSettings'];
          };
        };
        default: components['responses']['DEFAULT_ERROR'];
      };
    };
    /** Updates the Avalara settings for you vendor. */
    put: {
      responses: {
        /** OK */
        200: {
          content: {
            'application/json': components['schemas']['VendorAvalaraSettings'];
          };
        };
        422: components['responses']['UNPROCESSABLE_ENTITY'];
        default: components['responses']['DEFAULT_ERROR'];
      };
      requestBody: {
        content: {
          'application/json': components['schemas']['UpdateVendorAvalaraSettingsArgs'];
        };
      };
    };
    /** Creates the Avalara settings for you vendor. */
    post: {
      responses: {
        /** OK */
        200: {
          content: {
            'application/json': components['schemas']['VendorAvalaraSettings'];
          };
        };
        422: components['responses']['UNPROCESSABLE_ENTITY'];
        default: components['responses']['DEFAULT_ERROR'];
      };
      requestBody: {
        content: {
          'application/json': components['schemas']['CreateVendorAvalaraSettingsArgs'];
        };
      };
    };
  };
  '/integration/tax/avalara/credentials/valid': {
    /** Validates the Avalara credentials for you vendor. */
    post: {
      responses: {
        /** OK */
        200: {
          content: {
            'application/json': components['schemas']['ValidateCredentialsResp'];
          };
        };
        422: components['responses']['UNPROCESSABLE_ENTITY'];
        default: components['responses']['DEFAULT_ERROR'];
      };
      requestBody: {
        content: {
          'application/json': components['schemas']['ValidateCredentialsArgs'];
        };
      };
    };
  };
  '/integration/tax/avalara/tax_code': {
    /** Lists the Avalara Tax codes associated for a specific company. */
    get: {
      responses: {
        /** OK */
        200: {
          content: {
            'application/json': components['schemas']['TaxCode'][];
          };
        };
        default: components['responses']['DEFAULT_ERROR'];
      };
    };
  };
  '/integration/tax/avalara/company': {
    /** Lists the companies found in your Avalara account. */
    get: {
      responses: {
        /** OK */
        200: {
          content: {
            'application/json': components['schemas']['Company'][];
          };
        };
        default: components['responses']['DEFAULT_ERROR'];
      };
    };
  };
  '/integration/tax/avalara/entity_use_code': {
    /** Lists the entity codes available in avalara. */
    get: {
      responses: {
        /** OK */
        200: {
          content: {
            'application/json': components['schemas']['EntityUseCode'][];
          };
        };
        default: components['responses']['DEFAULT_ERROR'];
      };
    };
  };
  '/recognized_revenue/': {
    /** Compute monthly recognized revenue */
    post: {
      responses: {
        /** OK */
        200: {
          content: {
            'application/json': components['schemas']['RevenueRecognitionEntry'][];
          };
        };
        422: components['responses']['UNPROCESSABLE_ENTITY'];
        default: components['responses']['DEFAULT_ERROR'];
      };
      requestBody: {
        content: {
          'application/json': components['schemas']['RevenueRecognitionInput'];
        };
      };
    };
  };
  '/features/': {
    /** Gets all existing features for a specific vendor. */
    get: {
      responses: {
        /** OK */
        200: {
          content: {
            'application/json': components['schemas']['Feature'][];
          };
        };
        default: components['responses']['DEFAULT_ERROR'];
      };
    };
  };
}

export interface components {
  schemas: {
    Error: {
      /** Errors */
      errors?: { [key: string]: unknown };
      /** Error message */
      message?: string;
      /** Error name */
      status?: string;
      /** Error code */
      code?: number;
    };
    Meter: {
      /** Unique name identifier */
      name: string;
      /** Name of the event associated with this meter */
      event_name: string;
      /** Name used for display in UI */
      display_name?: string;
      description?: string | null;
      /** Whether measurement values are to be considered incremental (versus a running total) */
      is_incremental: boolean;
      meter_type?: unknown;
      /** The expected unit for the measurement values associated with this meter. */
      unit_name?: unknown;
      expected_labels?: unknown[];
      primary_labels?: unknown[];
    };
    MeterInputArgs: {
      name?: string;
      expected_labels?: string[];
      vendor_id?: number;
      event_name?: string;
      meter_type?: 'COUNTER' | 'GAUGE';
      display_name?: string;
      unit_name?: string;
      description?: string;
      primary_labels?: string[];
      is_incremental?: boolean;
    };
    UpdateMeterArgs: {
      display_name?: string;
      description?: string;
    };
    Measurement: {
      /** The name of the event associated with this measurement. Events allow for a 1 to many relationship between measurement and meters. */
      event_name?: string;
      /** The raw value of the measurement */
      value: number;
      /** Applies to incremental meters and resets the total current value to this new value. */
      reset_total?: boolean;
      /** The unique name of the meter associated with this measurement */
      meter_name?: string;
      /** All times are parsed as `ISO-8601` formatted, UTC-based timestamps */
      time?: string;
      /** An ID that is unique for the set of labels and meter_name */
      id?: string;
      /** A set of key:value label pairs to supplement a measurement. Each meter defines its own set of primary and/or expected labels. */
      labels?: { [key: string]: string };
      /** The name of the customer to associate the measurement with. */
      customer_name?: string;
    };
    ContactInfo: {
      address_line_1?: string | null;
      address_line_2?: string | null;
      city?: string | null;
      state?: string | null;
      country?: string | null;
      zipcode?: string | null;
      url?: string | null;
      logo_url?: string | null;
      email?: string | null;
      secondary_emails?: string | null;
      phone?: string | null;
      legal_name?: string | null;
      vat_id?: string | null;
    };
    CustomerTag: {
      /** Supplementary tag that is associated with a customer */
      tag: string;
    };
    Customer: {
      /** Unique name identifier of a customer */
      name: string;
      display_name?: string;
      contact_info?: components['schemas']['ContactInfo'] | null;
      created_at?: string;
      measurement_mappings?: unknown[];
      tags?: components['schemas']['CustomerTag'][];
    };
    CustomerMeasurementMappingInputArgs: {
      /** A regex used to match the value of the associated label key. */
      value_regex: string;
      /** The label key used to map measurements to customers. */
      label: string;
    };
    ContactInfoInputArgs: {
      country?: string | null;
      address_line_2?: string | null;
      legal_name?: string | null;
      url?: string | null;
      address_line_1?: string | null;
      logo_url?: string | null;
      city?: string | null;
      zipcode?: string | null;
      state?: string | null;
      vat_id?: string | null;
      /** List of secondary contact emails (all email communication will also be sent to these emails). */
      secondary_emails?: string[] | null;
      phone?: string | null;
      email?: string | null;
    };
    CreateCustomerArgs: {
      name?: string;
      tags?: string[] | null;
      vendor_id?: number;
      autogenerate_accounting_customer?: boolean;
      display_name?: string;
      measurement_mappings?: components['schemas']['CustomerMeasurementMappingInputArgs'][];
      price_plan_tag?: string;
      created_at?: string;
      contact_info?: components['schemas']['ContactInfoInputArgs'];
      price_plan_name?: string;
      autogenerate_payment_gateway_customer?: boolean;
    };
    UpdateCustomerArgs: {
      name?: string;
      tags?: string[] | null;
      vendor_id?: number;
      display_name?: string;
      measurement_mappings?: components['schemas']['CustomerMeasurementMappingInputArgs'][];
      created_at?: string;
      contact_info?: components['schemas']['ContactInfoInputArgs'];
    };
    CustomerMeasurementMapping: {
      /** The label key used to map measurements to customers. */
      label: string;
      /** A regex used to match the value of the associated label key. */
      value_regex?: string | null;
    };
    CustomerPaymentMethodStatus: {
      /** The status of the customer's current payment method. Can be one of: NO_PAYMENT_GATEWAY_CREDENTIAL, NO_PAYMENT_METHOD, EXPIRED_PAYMENT_METHOD, VALID_PAYMENT_METHOD */
      status?: string;
    };
    PaymentGatewayCredential: {
      payment_gateway?: unknown;
      /** Payment gateway account id associated with customer */
      account_id: string;
      /** Unique name identifier of a customer */
      auth_token?: string | null;
    };
    CustomerPaymentGatewayCredentialInputArgs: {
      account_id?: string;
    };
    BillingSettings: {
      /** Time length of the grace period between the end of a billing cycle and invoice generation in days. */
      invoice_grace_period_length?: number | null;
      /** Time length unit of the grace period between the end of a billing cycle and invoice generation. Must be `day`. */
      invoice_grace_period_unit?: string | null;
      /** Time length of the grace period between the end of invoice generation and the actual charge. *NOTE*: The specified length is unitless. Unit is designated with the `payment_grace_period_unit` field. */
      payment_grace_period_length?: number | null;
      /** Time length unit of the grace period between the end of invoice generation and actual charge. One of `minute`, `hour`, `day`. */
      payment_grace_period_unit?: string | null;
      /** Flag that controls whether or not invoices should be sent to customers. */
      should_send_invoice_to_customers?: boolean | null;
      /** Flag that controls whether to invoice through Octane or through payment provider */
      invoice_via_octane?: boolean | null;
      /** Flag that controls whether invoices are auto-approved or require manual approval */
      auto_approve_invoices?: boolean | null;
      customer_invoice_detail_level?: unknown;
      /** Flag that controls whether or not to auto-charge the customer based on the invoice. */
      charges_enabled?: boolean | null;
      /** Flag that controls whether or not to invoice/charge the base rate, add ons and other fixed price plan components at the beginning of the billing cycle. */
      invoice_fixed_components_at_start?: boolean | null;
      /** Flag that controls the number of retry attempts for invoicing/payments. */
      retry_attempts?: number | null;
      /** Time length after which to attempt invoice/payment retry. */
      retry_frequency_length?: number | null;
      /** Time length unit after which to attempt invoice/payment retry. */
      retry_frequency_unit?: string | null;
      /** The percentage tax rate to apply to invoices. */
      tax_rate?: number | null;
      /** Flag that controls whether to do automated taxes via payment provider */
      tax_via_payment_provider?: boolean | null;
      /** Flag that controls whether or not to invoice/charge gauge meters upfront according to their value at start of cycle. Only applies if invoice_fixed_components_at_start is enabled. */
      invoice_metered_components_at_start?: boolean | null;
      /** Flag that controls whether or not to invoice/charge a true up for a billing cycle on the following invoice. Only applies if invoice_fixed_components_at_start is enabled. */
      invoice_overages?: boolean | null;
      /** Optional description attached to the invoice */
      invoice_memo?: string | null;
      /** Sets the due date on invoices to the number of days after the invoice is sent */
      days_until_due?: number | null;
      /** If using stripe, this field can be used to configure whether invoices should be auto advanced for collection */
      stripe_auto_advance?: boolean | null;
      /** Default value for whether to align billing cycles to calendar on subscriptions */
      align_billing_cycles_to_calendar?: boolean | null;
      /** Optional url of a custom image to include on invoices. */
      invoice_logo_url?: string | null;
      /** Flag determining whether ACH/Wire instructions should be included on invoices. */
      include_ach_instructions?: boolean | null;
      /** Account name for ACH/Wire transfer instructions */
      ach_account_name?: string | null;
      /** ABA/Routing number for ACH/Wire transfer instructions */
      ach_routing_number?: string | null;
      /** Account number for ACH/Wire transfer instructions */
      ach_account_number?: string | null;
      /** Swift code for ACH/Wire transfer instructions */
      ach_swift_code?: string | null;
      /** Bank name for ACH/Wire transfer instructions */
      ach_bank_name?: string | null;
      /** First line of bank address for ACH/Wire transfer instructions */
      ach_bank_address_1?: string | null;
      /** Second line of bank address for ACH/Wire transfer instructions */
      ach_bank_address_2?: string | null;
      /** True if customer updates should be synced to Stripe. */
      sync_customer_data_to_payment_gateway?: boolean | null;
      /** If using Stripe, this field can be used to configure whether invoices should be finalized immediately when they are created. */
      stripe_immediate_finalization?: boolean | null;
      /** If set, we will use this template id for our emails instead of our default one */
      alternate_sendgrid_template_id?: string | null;
    };
    CustomerBillingSettingsInputArgs: {
      customer_invoice_detail_level?: string;
      /** The percentage tax rate to apply to invoices. */
      tax_rate?: number | null;
      /** Flag that controls whether or not to invoice/charge a true up for a billing cycle on the following invoice. Only applies if invoice_fixed_components_at_start is enabled. */
      invoice_overages?: boolean | null;
      /** Optional description attached to the invoice */
      invoice_memo?: string | null;
      /** Bank name for ACH/Wire transfer instructions */
      ach_bank_name?: string | null;
      /** Account name for ACH/Wire transfer instructions */
      ach_account_name?: string | null;
      /** If using stripe, this field can be used to configure whether invoices should be auto advanced for collection */
      stripe_auto_advance?: boolean | null;
      /** Flag that controls the number of retry attempts for invoicing/payments. */
      retry_attempts?: number | null;
      /** Second line of bank address for ACH/Wire transfer instructions */
      ach_bank_address_2?: string | null;
      /** Flag determining whether ACH/Wire instructions should be included on invoices. */
      include_ach_instructions?: boolean | null;
      /** Time length unit of the grace period between the end of a billing cycle and invoice generation. Must be `day`. */
      invoice_grace_period_unit?: 'day' | null;
      /** Time length unit of the grace period between the end of invoice generation and actual charge. One of `minute`, `hour`, `day`. */
      payment_grace_period_unit?: string | null;
      /** Flag that controls whether or not invoices should be sent to customers. */
      should_send_invoice_to_customers?: boolean | null;
      /** First line of bank address for ACH/Wire transfer instructions */
      ach_bank_address_1?: string | null;
      /** Default value for whether to align billing cycles to calendar on subscriptions */
      align_billing_cycles_to_calendar?: boolean | null;
      /** True if customer updates should be synced to Stripe. */
      sync_customer_data_to_payment_gateway?: boolean | null;
      /** Sets the due date on invoices to the number of days after the invoice is sent */
      days_until_due?: number | null;
      /** Flag that controls whether or not to invoice/charge the base rate, add ons and other fixed price plan components at the beginning of the billing cycle. */
      invoice_fixed_components_at_start?: boolean | null;
      /** Optional url of a custom image to include on invoices. */
      invoice_logo_url?: string | null;
      /** If using Stripe, this field can be used to configure whether invoices should be finalized immediately when they are created. */
      stripe_immediate_finalization?: boolean | null;
      /** Flag that controls whether to invoice through Octane or through payment provider */
      invoice_via_octane?: boolean | null;
      /** Swift code for ACH/Wire transfer instructions */
      ach_swift_code?: string | null;
      /** Flag that controls whether or not to auto-charge the customer based on the invoice. */
      charges_enabled?: boolean | null;
      /** Time length unit after which to attempt invoice/payment retry. */
      retry_frequency_unit?: string | null;
      /** ABA/Routing number for ACH/Wire transfer instructions */
      ach_routing_number?: string | null;
      /** Flag that controls whether invoices are auto-approved or require manual approval */
      auto_approve_invoices?: boolean | null;
      /** Flag that controls whether or not to invoice/charge gauge meters upfront according to their value at start of cycle. Only applies if invoice_fixed_components_at_start is enabled. */
      invoice_metered_components_at_start?: boolean | null;
      /** Time length of the grace period between the end of a billing cycle and invoice generation in days. */
      invoice_grace_period_length?: number | null;
      /** Time length after which to attempt invoice/payment retry. */
      retry_frequency_length?: number | null;
      /** Time length of the grace period between the end of invoice generation and the actual charge. *NOTE*: The specified length is unitless. Unit is designated with the `payment_grace_period_unit` field. */
      payment_grace_period_length?: number | null;
      /** Account number for ACH/Wire transfer instructions */
      ach_account_number?: string | null;
      /** Flag that controls whether to do automated taxes via payment provider */
      tax_via_payment_provider?: boolean | null;
    };
    RevenueResponse: {
      revenue?: number;
    };
    CustomerStatus: {
      status?: string;
    };
    CustomerUsage: {
      usage?: number;
    };
    CustomerLabelLimit: {
      limit?: number;
      labels?: { [key: string]: string };
    };
    CustomerFeature: {
      label_limits?: components['schemas']['CustomerLabelLimit'][];
      quantity?: number;
      feature_name?: string;
      enabled?: boolean;
      limit?: number;
    };
    LineItems: {
      name?: string;
      price_int?: number;
      quantity?: number;
      start_time?: string;
      end_time?: string;
      quantity_unit?: string;
      description?: string;
      id?: string;
      price?: string;
      metadata?: { [key: string]: string };
    };
    RevenueBreakdown: {
      line_items?: components['schemas']['LineItems'][];
      total_revenue?: number;
    };
    CustomerMetadata: {
      /** Value of property for customer */
      value?: string;
      /** Property name */
      property?: string;
    };
    CustomerMetadataInput: {
      value?: string | null;
      property?: string;
    };
    Invoice: {
      due_date?: string;
      /** False if invoice has not been sent to the customer */
      is_invoiced?: boolean;
      /** [DEPRECATED] End time of the cycle in which the invoice was generated */
      end_time?: string;
      /** Earliest start time of line items covered by the invoice */
      min_item_start_time?: string;
      /** If there is an error processing this invoice, this field contains the error message. */
      status_error?: string;
      /** Tax amount applied to subtotal */
      tax_amount?: number;
      /** [DEPRECATED] Start time of the cycle in which the invoice was generated */
      start_time?: string;
      /** External unique 'uuid' identifier for this Invoice. */
      id?: string;
      line_items?: components['schemas']['LineItems'][];
      /** The number of retries done to send the invoice */
      invoice_retry_attempt?: number;
      /** The date the invoice will be issued to the end customer or forwarded to the payment processor. */
      issue_date?: string;
      /** Non-empty string if there was an error while processing payment */
      payment_error?: string;
      /** Any discount credits applied to the invoice */
      discount_credit?: number;
      latest_invoice_attempt_at?: string;
      /** False if not paid yet */
      is_paid?: boolean;
      /** Amount due before any credits are applied */
      sub_total?: number;
      /** False if not approved */
      is_approved?: boolean;
      /** The potentially permanent state this invoice can live in (e.g., ISSUED if the invoice has been issued to the customer) */
      status?: string;
      /** Latest end time of line items covered by the invoice */
      max_item_end_time?: string;
      /** Total amount due */
      amount_due?: number;
      /** The number of retries done to process the payment */
      payment_retry_attempt?: number;
      /** Non-empty string if there was an error while sending out invoice */
      invoicing_error?: string;
      /** Name of the customer this invoice is for. */
      customer_name?: string;
      latest_payment_attempt_at?: string;
      pdf_url?: string;
    };
    CreditTopOffPlan: {
      /** Unique identifier of this top off plan. */
      uuid?: string;
      /** The threshold in amount of credits at which the balance will be topped off. */
      trigger_amount: number;
      /** Amount of credits that are granted in a single top off. */
      grant_amount: number;
      /** Price for the grant, in lowest denomination (i.e cents). */
      price: number;
      /** Time length of the default expiration for credits granted in a top off. */
      expiration_length?: number | null;
      /** Time length unit for the default expiration for credits granted in a top off. */
      expiration_unit?: string | null;
      /** A description that will be used on the invoice line items. */
      description?: string | null;
    };
    CreateCreditTopOffPlanInputArgs: {
      /** Time length unit for the default expiration for credits granted in a top off. */
      expiration_unit?: string;
      /** Amount of credits that are granted in a single top off. */
      grant_amount: number;
      /** A description that will be used on the invoice line items. */
      description?: string;
      /** Price for the grant, in lowest denomination (i.e cents). */
      price: number;
      /** Time length of the default expiration for credits granted in a top off. */
      expiration_length?: number;
      /** The threshold in amount of credits at which the balance will be topped off. */
      trigger_amount: number;
    };
    UpdateCreditTopOffPlanInputArgs: {
      /** Time length unit for the default expiration for credits granted in a top off. */
      expiration_unit?: string;
      /** Amount of credits that are granted in a single top off. */
      grant_amount?: number;
      /** A description that will be used on the invoice line items. */
      description?: string;
      /** Price for the grant, in lowest denomination (i.e cents). */
      price?: number;
      /** Time length of the default expiration for credits granted in a top off. */
      expiration_length?: number;
      /** The threshold in amount of credits at which the balance will be topped off. */
      trigger_amount?: number;
    };
    AccountingCustomer: {
      /** ID of the customer in the target accounting platform */
      accounting_customer_id?: string;
    };
    CustomerAvalaraSettings: {
      /** True if Avalara integration should be enabled for this customer, False otherwise. */
      enable_integration?: boolean;
      /** Tax exemption number specific to this customer */
      exemption_number?: string;
      /** Entity code describing this customer. */
      entity_use_code?: string;
    };
    UpdateCustomerAvalaraSettingsArgs: {
      /** True if Avalara integration should be enabled for this customer, False otherwise. */
      enable_integration?: boolean;
      /** Tax exemption number specific to this customer */
      exemption_number?: string;
      /** Entity code describing this customer. */
      entity_use_code?: string;
    };
    ValidateAddressResp: {
      /** Set if 'sucess' is True. Geospatial latitude measurement, in Decimal Degrees (string). */
      longitude?: string;
      /** True if validation was successful, False address is invalid. */
      success?: boolean;
      /** Set if 'success' is True. The resolution quality of the geospatial coordinates. */
      resolution_quality?: string;
      /** Set if 'success' is False. Contains the details of why the address is invalid. */
      invalid_address_error?: string;
      /** Set if 'success' is True. Geospatial latitude measurement, in Decimal Degrees (string). */
      latitude?: string;
    };
    PriceTier: {
      /** Cap of the tier, meaning that any subsequent usage will be bucketed into the following tier. If cap is undefined, it is effectively treated as Infinity. */
      cap?: number;
      /** The price (in lowest currency denomination by which to charge, given that the usage is within the cap range. */
      price: number;
      /** The line item description to use if usage falls in this tier. */
      description?: string;
    };
    PriceScheme: {
      display_name?: string | null;
      name?: string | null;
      scheme_type?: unknown;
      /** Size of the unit batch to use for the prices. Can only be set if scheme_type='FLAT' or 'TIERED'. E.g. To charge $10 per 100 API Requests, set batch_size to 100. */
      batch_size?: number | null;
      /** Array of price tiers, each of which consists of `price` and `cap` key:value pairs */
      prices?: components['schemas']['PriceTier'][];
      /** Array of (key, value) meter labels to price on & the price tiers that should be used against those labels */
      price_list?: { [key: string]: unknown }[];
      time_unit_name?: string | null;
      unit_name?: string | null;
      /** The % increase/decrease in price after the minimum charge is reached. */
      post_minimum_charge_percentage_change?: number | null;
    };
    MeteredComponentLabelLimit: {
      /** Dictionary of labels (key: value) to which the limit applies. A value of 'any' will apply the limit to any single value of the field. */
      labels: unknown;
      /** Numeric limit set on the labels. */
      limit: number;
    };
    MeteredComponent: {
      meter_name: string;
      meter_display_name: string;
      price_scheme: components['schemas']['PriceScheme'];
      /** Limit on the usage for the meter. */
      limit?: number | null;
      label_limits: components['schemas']['MeteredComponentLabelLimit'][];
      /** Name to be used on invoice. */
      display_name?: string | null;
      /** External facing unique identifier of a metered component */
      external_uuid?: string;
      /** Minimum charge for the metered component */
      minimum_charge?: number | null;
      /** Minimum charge frequency (as a multiple of the price plan period) for the metered component */
      minimum_charge_frequency?: number | null;
    };
    Feature: {
      description?: string | null;
      /** Unique name of a feature */
      name: string;
      display_name?: string;
    };
    AddOn: {
      feature: components['schemas']['Feature'];
      /** Price of the add on */
      price: number;
      /** If true, customer is just charged once in the first billing cycle. */
      single_use: boolean;
      quantity_enabled: boolean;
      /** If true, immediately invoice the customer for this add on. */
      immediately_charge?: boolean;
      /** The maximum number of add-ons that an end-customer can apply to their subscription. */
      limit?: number;
    };
    Limit: {
      feature: components['schemas']['Feature'];
      /** Limit on feature */
      limit: number;
    };
    PricePlanTag: {
      /** Supplementary tag label that is associated with a specific version of a price plan */
      tag: string;
    };
    Trial: {
      time_length?: number | null;
      time_unit_name?: string | null;
      credit?: number | null;
    };
    PricePlan: {
      /** External facing unique identifier of a price plan */
      external_uuid?: string;
      /** Unique name indentifier of a price plan */
      name: string;
      /** UI-friendly name used for data display. Defaults to `name`. */
      display_name?: string;
      description?: string | null;
      /** Lowest denomination of currency. e.g. USD is represented as cents. */
      base_price?: number | null;
      base_price_frequency?: number | null;
      /** Custom invoice description for the base price line item. */
      base_price_description?: string | null;
      /** Time period that defines the length of a price plan cycle. One of `day`, `week`, `month`, `quarter`, or `year`. */
      period: string;
      metered_components: components['schemas']['MeteredComponent'][];
      /** Minimum amount to charge every 'period' */
      minimum_charge?: number | null;
      /** The frequency (as a an integer multiple of the period) at which to charge the minimum charge. */
      minimum_charge_frequency?: number | null;
      features?: components['schemas']['Feature'][];
      add_ons?: components['schemas']['AddOn'][];
      limits?: components['schemas']['Limit'][];
      tags?: components['schemas']['PricePlanTag'][];
      trial?: components['schemas']['Trial'];
      /** ISO-8601 formatted creation timestamp of price plan version */
      created_at?: string;
    };
    Discount: {
      discount_type?: unknown;
      amount?: number | null;
      /** The date when the discount is applied from. */
      start_date?: string | null;
      /** The date when the discount ends. */
      end_date?: string | null;
      /** Offset in number of billing cycles for when this discount will apply. For example, if set to 1, the discount will apply from the start of the next billing cycle. */
      billing_cycle_start_offset?: number;
      /** Duration of this discount in number of billing cycles. */
      billing_cycle_duration?: number | null;
      /** The id of coupon associated with this discount, none if discount does not originate from coupon */
      coupon_id?: number | null;
      /** External facing unique identifier of a price plan */
      external_uuid?: string;
      /** The scope that this discount covers. One of 'INVOICE_TOTAL', 'ADD_ON', 'METERED_COMPONENT'. */
      scope: string;
      /** Add-on this discount covers if scope is ADD_ON. */
      add_on?: components['schemas']['AddOn'];
      /** Metered Component this discount covers if scope is METERED_COMPONENT. */
      metered_component?: components['schemas']['MeteredComponent'];
      /** Dictionary of labels (key: value) to which the discount applies if scope is METERED_COMPONENT. */
      labels?: { [key: string]: string };
    };
    Subscription: {
      /** Unique name identifier of a customer */
      customer_name: unknown;
      /** Unique name indentifier of a price plan */
      price_plan_name: unknown;
      /** Price plan associated with this subscription. */
      price_plan?: components['schemas']['PricePlan'];
      /** Align billing cycles to a calendar unit if true. For example if the period is month, cycles will end on the first of every month. */
      align_to_calendar?: boolean;
      discounts?: (components['schemas']['Discount'] | null)[];
      add_ons?: unknown;
      /** Optional trial override for the associated subscription. */
      trial_override?: components['schemas']['Trial'];
      /** Optional base price override for the associated subscription. */
      base_price_override?: number | null;
      features_override?: components['schemas']['Feature'][];
      limits_override?: components['schemas']['Limit'][];
      /** ISO-8601 formatted timestamp that defines when the subscription should take effect. If this field is omitted, the subscription is effective upon creation. */
      effective_at?: string;
      /** ISO-8601 formatted timestamp that defines when the subscription will expire. */
      expired_at?: string | null;
    };
    TrialInputArgs: {
      time_length?: number;
      time_unit_name?: string;
      credit?: number;
    };
    FeatureInputArgs: {
      name: string;
      display_name?: string;
      description?: string;
    };
    DiscountInputArgs: {
      /** Length, in billing cycles, that this discount will be active. */
      billing_cycle_duration?: number;
      /** For ADD_ON scoped discounts: the name of the add on that the discount covers. */
      add_on_name?: string;
      discount_type?: 'FLAT' | 'PERCENT';
      /** For METERED_COMPONENT scoped discounts: the UUID of the metered component that the discount covers. */
      metered_component_uuid?: string;
      /** For METERED_COMPONENT scoped discounts: Dictionary of labels (key: value) that the discount covers. The entire set of labels must be provided. */
      labels?: { [key: string]: string };
      /** Offset, in number of billing cycles, for when this discount will apply. If set to 0, the discount will start applying from the current billing cycle. If set to 1, the discount will start applying from the next billing cycle, etc. For scheduled subscriptions, the offset starts from the initial billing cycle. */
      billing_cycle_start_offset?: number;
      amount?: number;
      /** The scope that this discount covers. One of 'INVOICE_TOTAL', 'ADD_ON', 'METERED_COMPONENT'. */
      scope?: 'INVOICE_TOTAL' | 'ADD_ON' | 'METERED_COMPONENT';
    };
    LimitInputArgs: {
      feature: components['schemas']['FeatureInputArgs'];
      limit?: number;
    };
    SubscriptionAddOnInput: {
      name: string;
      quantity?: number;
      /** Override for the add-on price on this subscription. */
      price?: number;
    };
    CreateSubscriptionArgs: {
      price_plan_id?: number;
      vendor_id?: number;
      trial_override?: components['schemas']['TrialInputArgs'];
      features_override?: components['schemas']['FeatureInputArgs'][];
      /** DEPRECATED - use discounts field */
      discount_override?: components['schemas']['DiscountInputArgs'];
      customer_id?: number;
      coupon_override_id?: number;
      align_to_calendar?: boolean;
      coupon_override_name?: string;
      discounts?: components['schemas']['DiscountInputArgs'][];
      limits_override?: components['schemas']['LimitInputArgs'][];
      effective_at?: string;
      price_plan_tag?: string;
      add_ons?: components['schemas']['SubscriptionAddOnInput'][];
      price_plan_name?: string;
    };
    UpdateSubscriptionArgs: {
      price_plan_id?: number;
      vendor_id?: number;
      trial_override?: components['schemas']['TrialInputArgs'] | null;
      features_override?: components['schemas']['FeatureInputArgs'][] | null;
      /** DEPRECATED - use discounts field */
      discount_override?: components['schemas']['DiscountInputArgs'] | null;
      customer_id?: number;
      coupon_override_id?: number;
      align_to_calendar?: boolean;
      /** Boolean that indicates whether to update the subscription at the start of the billing cycle. If 'true' and either of `effective_at` or `at_cycle_end` are set, will return an error. */
      at_cycle_start?: boolean;
      coupon_override_name?: string;
      discounts?: components['schemas']['DiscountInputArgs'][];
      limits_override?: components['schemas']['LimitInputArgs'][] | null;
      effective_at?: string;
      price_plan_tag?: string;
      add_ons?: components['schemas']['SubscriptionAddOnInput'][] | null;
      price_plan_name?: string;
      /** Boolean that indicates whether to update the subscription at the end of the billing cycle. If 'true' and either of `effective_at` or `at_cycle_start` are set, will return an error. */
      at_cycle_end?: boolean;
    };
    DeleteSubscriptionArgs: {
      expire_at?: string;
      vendor_id?: number;
      customer_id?: number;
      /** Boolean that indicates whether to expire the subscription at the end of thebilling cycle. If 'true' and `expire_at` is set, will return an error. */
      at_cycle_end?: boolean;
    };
    UpdateSubscriptionInPlaceArgs: {
      /** DEPRECATED - use discounts field */
      discount_override?: components['schemas']['DiscountInputArgs'] | null;
      discounts?: components['schemas']['DiscountInputArgs'][];
      add_ons?: components['schemas']['SubscriptionAddOnInput'][] | null;
      coupon_override_name?: string;
    };
    BillingCycleDate: {
      cycle_end: string;
      cycle_start: string;
    };
    ActiveSubscription: {
      /** Unique name identifier of a customer */
      customer_name: unknown;
      /** Unique name indentifier of a price plan */
      price_plan_name: unknown;
      /** Price plan associated with this subscription. */
      price_plan?: components['schemas']['PricePlan'];
      discounts?: (components['schemas']['Discount'] | null)[];
      add_ons?: unknown;
      /** Optional trial override for the associated subscription. */
      trial_override?: components['schemas']['Trial'];
      features_override?: components['schemas']['Feature'][];
      limits_override?: components['schemas']['Limit'][];
      /** ISO-8601 formatted timestamp that defines when the subscription should take effect. If this field is omitted, the subscription is effective upon creation. */
      effective_at?: string;
      /** ISO-8601 formatted timestamp that defines when the subscription will expire. */
      expired_at?: string | null;
      /** Align billing cycles to a calendar unit if true. For example if the period is month, cycles will end on the first of every month. */
      align_to_calendar?: boolean;
      /** Optional base price override for the associated subscription. */
      base_price_override?: number | null;
      current_billing_cycle?: components['schemas']['BillingCycleDate'];
      total_fixed_price?: number;
      discounted_fixed_price?: number;
    };
    SubscriptionAddOnItem: {
      /** Quantity represents how many of this add on you want to attach to the subscription. Can be positive forincreasing the number of this add on or negative for decreasing. */
      quantity?: number;
      feature_name?: string;
      /** Boolean that indicates whether to update the subscription add on at the start of the billing cycle. If 'true' and either of `effective_at` or `at_cycle_end` are set, will return an error. */
      at_cycle_start?: boolean;
      effective_at?: string;
      /** Boolean that indicates whether to update the subscription add on at the end of the billing cycle. If 'true' and either of `effective_at` or `at_cycle_start` are set, will return an error. */
      at_cycle_end?: boolean;
    };
    DeleteDiscountInputArgs: {
      /** External UUID representing the discount to be deleted. */
      discount_uuid: string;
    };
    PastInvoice: {
      issue_date?: string;
      due_date?: string;
      status_description?: string;
      amount_due?: number;
      export_url?: string;
      /** External unique 'uuid' identifier for this Invoice. */
      id?: string;
      customer_name?: string;
      status?: string;
    };
    PastInvoices: {
      /** The sort column offset to start at when paging forwards */
      forward_sort_offset?: string;
      sort_direction?: string;
      sort_column?: string;
      /** The unique offset to start at when paging forwards */
      forward_secondary_sort_offset?: string;
      invoices?: components['schemas']['PastInvoice'][];
      /** The number of items to fetch. Defaults to 10. */
      limit?: number;
    };
    CreateRetryArgs: { [key: string]: unknown };
    Retry: {
      success?: boolean;
    };
    PriceInputArgs: {
      cap?: number;
      price?: number;
      description?: string;
    };
    PriceSchemeInputArgs: {
      /** Array of price tiers, each of which consists of `price` and `cap` key:value pairs */
      prices?: components['schemas']['PriceInputArgs'][];
      /** Size of the unit batch to use for the prices. Can only be set if scheme_type='FLAT' or 'TIERED'. E.g. To charge $10 per 100 API Requests, set batch_size to 100. */
      batch_size?: number;
      /** The name of the unit used for this metered component (e.g., gigabyte) */
      unit_name?: string;
      /** Array of (key, value) meter labels to price on & the price tiers that should be used against those labels */
      price_list?: { [key: string]: unknown }[];
      /** The % increase/decrease in price after the minimum charge is reached (e.g., 25.5 -> 25.5% increase). */
      post_minimum_charge_percentage_change?: number;
      /** The time unit for the metered component (e.g., month or hour) */
      time_unit_name?: string;
      /** One of 'FLAT', 'TIERED', or 'STAIRSTEP' */
      scheme_type: string;
    };
    MeteredComponentLabelLimitInputArgs: {
      /** Numeric limit to set on customer usage for the meter with the given labels. */
      limit: number;
      /** Dictionary of labels (key: value) to which the limit applies. A value of 'any' will apply the limit to any single value of the field. */
      labels: { [key: string]: string };
    };
    MeteredComponentInputArgs: {
      price_scheme?: components['schemas']['PriceSchemeInputArgs'];
      label_limits?: components['schemas']['MeteredComponentLabelLimitInputArgs'][];
      /** Name to be used on invoice. */
      display_name?: string;
      /** Codename of the meter. */
      meter_name?: string;
      /** Minimum charge frequency (as a multiple of the price plan period) for the metered component */
      minimum_charge_frequency?: number | null;
      id?: number;
      /** Minimum charge for the metered component */
      minimum_charge?: number | null;
      meter_id?: number;
      /** Numeric limit to set on customer usage for the meter. */
      limit?: number;
    };
    AddOnInputArgs: {
      feature: components['schemas']['FeatureInputArgs'];
      quantity_enabled?: boolean;
      /** Whether this add on can only be used & charged once. */
      single_use?: boolean;
      /** This field indicates whether or not we should cut an invoice immediately upon attaching this add on to a price plan. */
      immediately_charge?: boolean;
      price?: number;
      limit?: number;
    };
    CreatePricePlanArgs: {
      name?: string;
      /** The frequency (as a an integer multiple of the period) at which to charge the base price. */
      base_price_frequency?: number;
      vendor_id?: number;
      period?: string;
      metered_components?: components['schemas']['MeteredComponentInputArgs'][];
      tags?: string[];
      display_name?: string;
      /** Custom invoice description for the base price line item. */
      base_price_description?: string | null;
      limits?: components['schemas']['LimitInputArgs'][];
      /** The frequency (as a an integer multiple of the period) at which to charge the minimum charge. */
      minimum_charge_frequency?: number | null;
      description?: string;
      features?: components['schemas']['FeatureInputArgs'][];
      trial?: components['schemas']['TrialInputArgs'];
      /** Minimum amount (in cents) to charge every price plan period. */
      minimum_charge?: number | null;
      base_price?: number;
      add_ons?: components['schemas']['AddOnInputArgs'][];
    };
    ListPricePlans: {
      /** The sort column offset to start at when paging forwards */
      forward_sort_offset?: string;
      sort_direction?: string;
      sort_column?: string;
      /** The unique offset to start at when paging forwards */
      forward_secondary_sort_offset?: string;
      price_plans?: components['schemas']['PricePlan'][];
      /** The number of items to fetch. Defaults to 10. */
      limit?: number;
    };
    UpdatePricePlanArgs: {
      name?: string;
      /** The frequency (as a an integer multiple of the period) at which to charge the base price. */
      base_price_frequency?: number;
      vendor_id?: number;
      period?: string;
      metered_components?: components['schemas']['MeteredComponentInputArgs'][];
      tags?: string[];
      display_name?: string;
      /** Custom invoice description for the base price line item. */
      base_price_description?: string | null;
      limits?: components['schemas']['LimitInputArgs'][];
      /** The frequency (as a an integer multiple of the period) at which to charge the minimum charge. */
      minimum_charge_frequency?: number | null;
      description?: string;
      features?: components['schemas']['FeatureInputArgs'][];
      trial?: components['schemas']['TrialInputArgs'];
      /** Minimum amount (in cents) to charge every price plan period. */
      minimum_charge?: number | null;
      base_price?: number;
      add_ons?: components['schemas']['AddOnInputArgs'][];
    };
    UpdatePricePlanInPlaceArgs: {
      metered_components?: components['schemas']['MeteredComponentInputArgs'][];
      display_name?: string;
      /** Custom invoice description for the base price line item. */
      base_price_description?: string | null;
      limits?: components['schemas']['LimitInputArgs'][];
      description?: string;
      features?: components['schemas']['FeatureInputArgs'][];
      add_ons?: components['schemas']['AddOnInputArgs'][];
    };
    SelfServePricePlansInputArgs: {
      price_plan_uuids?: string[];
    };
    AddFeaturesToPricePlanInput: {
      /** List of new features to add */
      features?: components['schemas']['FeatureInputArgs'][];
      /** List of new limits to add */
      limits?: components['schemas']['LimitInputArgs'][];
    };
    RemoveFeaturesFromPricePlanInput: {
      /** List of feature names to remove */
      feature_names: string[];
    };
    AddAddOnsToPricePlanInput: {
      /** List of add ons to add */
      add_ons: components['schemas']['AddOnInputArgs'][];
    };
    AddMeteredComponentsToPricePlanInput: {
      /** List of metered components to add */
      metered_components: components['schemas']['MeteredComponentInputArgs'][];
    };
    UpdateMeteredComponentLimitsInput: {
      label_limits?: components['schemas']['MeteredComponentLabelLimitInputArgs'][];
      /** Numeric limit to set on customer usage for the meter. */
      limit?: number | null;
    };
    PaymentGatewayCredentialInputArgs: {
      payment_gateway?: string;
      account_id?: string;
      auth_token?: string;
    };
    CreateBillingSettingsInputArgs: {
      customer_invoice_detail_level?: string;
      /** The percentage tax rate to apply to invoices. */
      tax_rate?: number | null;
      /** Flag that controls whether or not to invoice/charge a true up for a billing cycle on the following invoice. Only applies if invoice_fixed_components_at_start is enabled. */
      invoice_overages?: boolean;
      /** Optional description attached to the invoice */
      invoice_memo?: string | null;
      /** Bank name for ACH/Wire transfer instructions */
      ach_bank_name?: string | null;
      /** Account name for ACH/Wire transfer instructions */
      ach_account_name?: string | null;
      /** If using stripe, this field can be used to configure whether invoices should be auto advanced for collection */
      stripe_auto_advance?: boolean;
      /** Flag that controls the number of retry attempts for invoicing/payments. */
      retry_attempts?: number;
      /** Second line of bank address for ACH/Wire transfer instructions */
      ach_bank_address_2?: string | null;
      /** Flag determining whether ACH/Wire instructions should be included on invoices. */
      include_ach_instructions?: boolean | null;
      /** Time length unit of the grace period between the end of a billing cycle and invoice generation. Must be `day`. */
      invoice_grace_period_unit?: 'day';
      /** Time length unit of the grace period between the end of invoice generation and actual charge. One of `minute`, `hour`, `day`. */
      payment_grace_period_unit?: string;
      /** Flag that controls whether or not invoices should be sent to customers. */
      should_send_invoice_to_customers?: boolean;
      /** First line of bank address for ACH/Wire transfer instructions */
      ach_bank_address_1?: string | null;
      /** Default value for whether to align billing cycles to calendar on subscriptions */
      align_billing_cycles_to_calendar?: boolean;
      /** True if customer updates should be synced to Stripe. */
      sync_customer_data_to_payment_gateway?: boolean | null;
      /** Sets the due date on invoices to the number of days after the invoice is sent */
      days_until_due?: number | null;
      /** Flag that controls whether or not to invoice/charge the base rate, add ons and other fixed price plan components at the beginning of the billing cycle. */
      invoice_fixed_components_at_start?: boolean;
      /** Optional url of a custom image to include on invoices. */
      invoice_logo_url?: string | null;
      /** If using Stripe, this field can be used to configure whether invoices should be finalized immediately when they are created. */
      stripe_immediate_finalization?: boolean | null;
      /** Flag that controls whether to invoice through Octane or through payment provider */
      invoice_via_octane?: boolean;
      /** Swift code for ACH/Wire transfer instructions */
      ach_swift_code?: string | null;
      /** Flag that controls whether or not to auto-charge the customer based on the invoice. */
      charges_enabled?: boolean;
      /** Time length unit after which to attempt invoice/payment retry. */
      retry_frequency_unit?: string;
      /** ABA/Routing number for ACH/Wire transfer instructions */
      ach_routing_number?: string | null;
      /** Flag that controls whether invoices are auto-approved or require manual approval */
      auto_approve_invoices?: boolean;
      /** Flag that controls whether or not to invoice/charge gauge meters upfront according to their value at start of cycle. Only applies if invoice_fixed_components_at_start is enabled. */
      invoice_metered_components_at_start?: boolean;
      /** Time length of the grace period between the end of a billing cycle and invoice generation in days. */
      invoice_grace_period_length?: number;
      /** Time length after which to attempt invoice/payment retry. */
      retry_frequency_length?: number;
      /** Time length of the grace period between the end of invoice generation and the actual charge. *NOTE*: The specified length is unitless. Unit is designated with the `payment_grace_period_unit` field. */
      payment_grace_period_length?: number;
      /** Account number for ACH/Wire transfer instructions */
      ach_account_number?: string | null;
      /** Flag that controls whether to do automated taxes via payment provider */
      tax_via_payment_provider?: boolean;
    };
    UpdateBillingSettingsInputArgs: {
      customer_invoice_detail_level?: string;
      /** The percentage tax rate to apply to invoices. */
      tax_rate?: number | null;
      /** Flag that controls whether or not to invoice/charge a true up for a billing cycle on the following invoice. Only applies if invoice_fixed_components_at_start is enabled. */
      invoice_overages?: boolean;
      /** Optional description attached to the invoice */
      invoice_memo?: string | null;
      /** Bank name for ACH/Wire transfer instructions */
      ach_bank_name?: string | null;
      /** Account name for ACH/Wire transfer instructions */
      ach_account_name?: string | null;
      /** If using stripe, this field can be used to configure whether invoices should be auto advanced for collection */
      stripe_auto_advance?: boolean;
      /** Flag that controls the number of retry attempts for invoicing/payments. */
      retry_attempts?: number;
      /** Second line of bank address for ACH/Wire transfer instructions */
      ach_bank_address_2?: string | null;
      /** Flag determining whether ACH/Wire instructions should be included on invoices. */
      include_ach_instructions?: boolean | null;
      /** Time length unit of the grace period between the end of a billing cycle and invoice generation. Must be `day`. */
      invoice_grace_period_unit?: 'day';
      /** Time length unit of the grace period between the end of invoice generation and actual charge. One of `minute`, `hour`, `day`. */
      payment_grace_period_unit?: string;
      /** Flag that controls whether or not invoices should be sent to customers. */
      should_send_invoice_to_customers?: boolean;
      /** First line of bank address for ACH/Wire transfer instructions */
      ach_bank_address_1?: string | null;
      /** Default value for whether to align billing cycles to calendar on subscriptions */
      align_billing_cycles_to_calendar?: boolean;
      /** True if customer updates should be synced to Stripe. */
      sync_customer_data_to_payment_gateway?: boolean | null;
      /** Sets the due date on invoices to the number of days after the invoice is sent */
      days_until_due?: number | null;
      /** Flag that controls whether or not to invoice/charge the base rate, add ons and other fixed price plan components at the beginning of the billing cycle. */
      invoice_fixed_components_at_start?: boolean;
      /** Optional url of a custom image to include on invoices. */
      invoice_logo_url?: string | null;
      /** If using Stripe, this field can be used to configure whether invoices should be finalized immediately when they are created. */
      stripe_immediate_finalization?: boolean | null;
      /** Flag that controls whether to invoice through Octane or through payment provider */
      invoice_via_octane?: boolean;
      /** Swift code for ACH/Wire transfer instructions */
      ach_swift_code?: string | null;
      /** Flag that controls whether or not to auto-charge the customer based on the invoice. */
      charges_enabled?: boolean;
      /** Time length unit after which to attempt invoice/payment retry. */
      retry_frequency_unit?: string;
      /** ABA/Routing number for ACH/Wire transfer instructions */
      ach_routing_number?: string | null;
      /** Flag that controls whether invoices are auto-approved or require manual approval */
      auto_approve_invoices?: boolean;
      /** Flag that controls whether or not to invoice/charge gauge meters upfront according to their value at start of cycle. Only applies if invoice_fixed_components_at_start is enabled. */
      invoice_metered_components_at_start?: boolean;
      /** Time length of the grace period between the end of a billing cycle and invoice generation in days. */
      invoice_grace_period_length?: number;
      /** Time length after which to attempt invoice/payment retry. */
      retry_frequency_length?: number;
      /** Time length of the grace period between the end of invoice generation and the actual charge. *NOTE*: The specified length is unitless. Unit is designated with the `payment_grace_period_unit` field. */
      payment_grace_period_length?: number;
      /** Account number for ACH/Wire transfer instructions */
      ach_account_number?: string | null;
      /** Flag that controls whether to do automated taxes via payment provider */
      tax_via_payment_provider?: boolean;
    };
    Customer1: {
      /** Unique name identifier of a customer */
      name: string;
    };
    PricePlan1: {
      /** Unique name indentifier of a price plan */
      name: string;
    };
    Coupon: {
      /** Unique name identifier. */
      name: string;
      /** UI-friendly name used for data display. Defaults to `name`. */
      display_name?: string;
      /** The time when the coupon will stop being effective one its applied. */
      duration_length?: number | null;
      /** The unit time unit to apply to the specified duration length. */
      duration_unit?: string | null;
      /** ISO-8601 formatted timestamp that defines after what timestamp this coupon cannot be applied. */
      expiration_time?: string | null;
      frequency?: unknown;
      /** The maximum number of times this coupon can be used. */
      max_uses?: number | null;
      /** Customer facing code that can be used to apply coupon. */
      code?: string | null;
      discount_type?: unknown;
      /** The amount of discount to give based on discount_type */
      discount_amount: number;
      excluded_customers?: components['schemas']['Customer1'][];
      excluded_price_plans?: components['schemas']['PricePlan1'][];
    };
    CouponInputArgs: {
      vendor_id?: number;
      name: string;
      display_name?: string;
      expiration_time?: string;
      frequency: 'ONCE' | 'RECURRING';
      duration_length?: number;
      duration_unit?: string;
      max_uses?: number;
      code?: string;
      excluded_customers?: string[];
      excluded_price_plans?: string[];
      discount_type: 'FLAT' | 'PERCENT';
      discount_amount: number;
    };
    ApplyCouponInputArgs: {
      name?: string;
      vendor_id?: number;
      customer_id?: number;
      code?: string;
      customer_name?: string;
    };
    CreateRefundArgs: {
      /** Invoice that the refund should be against */
      invoice_uuid?: string;
      /** Amount to be refunded */
      amount?: number;
      /** Invoice that the refund should be against */
      invoice_id?: number;
    };
    Refund: {
      success?: boolean;
    };
    CustomerPortalSettings: {
      /** Comma-separated list of names to filter visible price plans by. */
      price_plan_names_filter?: string | null;
      /** Comma-separated list of tags to filter visible price plans by. */
      price_plan_tags_filter?: string | null;
    };
    UpdateCustomerPortalSettingsInputArgs: {
      price_plan_tags_filter?: string;
      vendor_id?: number;
      price_plan_names_filter?: string;
    };
    CustomerPortalTokenInputArgs: {
      customer_name?: string;
    };
    CustomerPortalToken: {
      token?: string;
    };
    CustomerPortalUrl: {
      url?: string;
    };
    CustomerPortalVendor: {
      /** Unique name identifier of a Vendor */
      name?: string;
      /** Display name for the Vendor */
      display_name?: string;
      /** Full contact info for the Vendor */
      contact_info?: components['schemas']['ContactInfo'];
      /** Vendor's current payment gateway. */
      payment_gateway?: string;
      /** Currency preference of the Vendor. */
      currency?: string;
    };
    CustomerPortalInvoiceStatus: {
      update_source?: string;
      /** The timestamp that the action will be performed at. */
      pending_action_time?: string;
      /** The current upcoming action associated with this invoice status, if any. */
      action?: string;
      error?: string;
      /** Creation time of this invoice status. */
      created_at?: string;
      /** Time the invoice status was last updated. */
      updated_at?: string;
      /** The current processing state for this invoice. */
      status?: string;
    };
    CustomerPortalInvoice: {
      /** The date the invoice will be issued to the end customer or forwarded to the payment processor. */
      issue_date?: string;
      due_date?: string;
      /** Total amount due */
      amount_due?: number;
      /** Tax amount applied to subtotal */
      tax_amount?: number;
      /** [DEPRECATED] Start time of the cycle in which the invoice was generated */
      start_time?: string;
      /** Any discount credits applied to the invoice */
      discount_credit?: number;
      /** [DEPRECATED] End time of the cycle in which the invoice was generated */
      end_time?: string;
      /** False if not paid yet */
      is_paid?: boolean;
      /** Amount due before any credits are applied */
      sub_total?: number;
      id?: string;
      line_items?: components['schemas']['LineItems'][];
      /** Earliest start time of line items covered by the invoice */
      min_item_start_time?: string;
      /** Information related to the current status of this invoice. */
      status?: components['schemas']['CustomerPortalInvoiceStatus'];
      /** Latest end time of line items covered by the invoice */
      max_item_end_time?: string;
      /** Url pointing to the pdf of this invoice. */
      pdf_url?: string;
    };
    CustomerPortalActiveSubscription: {
      /** The total fixed price with all discounts applied. */
      discounted_fixed_price?: number;
      /** Customer's current active subscription. Includes the price plan and overrides they are subscribed to. */
      subscription?: components['schemas']['Subscription'];
      /** The date that the customer will be invoiced for their current billing cycle. */
      invoicing_date?: string;
      /** The total fixed price the customer will be charged for this billing cycle. Includes the base price and any add ons. */
      total_fixed_price?: number;
      /** Customer's current active biling cycle. */
      billing_cycle: components['schemas']['BillingCycleDate'];
    };
    CustomerPortalActiveSubscriptionInputArgs: {
      price_plan_uuid?: string;
      add_ons?: components['schemas']['SubscriptionAddOnInput'][] | null;
    };
    CustomerPortalSubscription: {
      price_plan?: components['schemas']['PricePlan'];
    };
    CustomerPortalSubscriptionInputArgs: {
      price_plan_name?: string;
    };
    CustomerPortalStripeCredential: {
      client_secret?: string;
      account_id?: string;
      publishable_key?: string;
    };
    CustomerPortalMeterLabels: {
      key?: string;
      /** Primary label values associated with the key */
      values?: string[];
    };
    CustomerPortalLabelDisplayName: {
      /** The raw value of the label data */
      name?: string;
      display_name?: string;
    };
    CustomerPortalMeterLabelsWithDisplayName: {
      /** Primary label key and prettified version of the key */
      key?: components['schemas']['CustomerPortalLabelDisplayName'];
      /** Primary label values associated with the key */
      values?: components['schemas']['CustomerPortalLabelDisplayName'][];
    };
    CustomerPortalMeter: {
      /** Type of the meter. E.g. COUNTER or GAUGE. */
      meter_type?: string;
      /** Name of the unit the meter uses. */
      unit_name?: string;
      /** Name of the meter. */
      meter_name?: string;
      /** Primary labels with keys and values */
      labels?: components['schemas']['CustomerPortalMeterLabels'][];
      /** Display name of the meter. */
      meter_display_name?: string;
      /** The raw and prettified label keys and values */
      labels_with_display_names?: components['schemas']['CustomerPortalMeterLabelsWithDisplayName'][];
    };
    DailyUsage: {
      /** Label key. Only present if label_group_by is provided. */
      label_key?: string;
      /** Total usage during this window. */
      usage?: number;
      /** Start of the 24 hour time window in UTC. */
      time?: string;
      /** Label value. Only present if label_group_by is provided. */
      label_value?: string;
    };
    CycleUsage: {
      /** The end of the billing cycle in UTC. */
      cycle_end?: string;
      usage_by_time?: components['schemas']['DailyUsage'][];
      /** The start of the billing cycle in UTC. */
      cycle_start?: string;
      /** Total usage in the cycle. */
      total_usage?: number;
    };
    CustomerPortalUsage: {
      /** Type of the meter. E.g. COUNTER or GAUGE. */
      meter_type?: string;
      /** Name of the unit the meter uses. */
      unit_name?: string;
      /** Daily usage across the previous billing cycle. */
      previous_cycle_usage?: components['schemas']['CycleUsage'];
      /** Name of the meter. */
      meter_name?: string;
      /** Daily usage across the current billing cycle. */
      current_cycle_usage?: components['schemas']['CycleUsage'];
      /** Display name of the meter. */
      meter_display_name?: string;
    };
    CustomerPortalLabelFilter: {
      key?: string;
      /** Primary label value associated with the key */
      value?: string;
    };
    CustomerPortalMeterLabelFilter: {
      /** Primary labels with keys and values */
      label_filters?: components['schemas']['CustomerPortalLabelFilter'][];
      /** Name of the meter. */
      meter_name: string;
      /** The label key to group results by. */
      label_group_by?: string;
      /** The aggregate function to use for the meter. */
      aggregate?: 'sum' | 'time_weighted' | 'latest';
    };
    BankAccountInfo: {
      /** Country the bank account is in. */
      country?: string;
      /** Name of the bank */
      bank_name?: string;
      external_id?: string;
      /** Bank account type. E.g. Savings/Checking */
      account_type?: string;
      /** Routing number for the bank accopunt */
      routing_number?: number;
      /** Last 4 digits of the bank account number. */
      last4?: string;
    };
    CardInfo: {
      /** Country of the card */
      country?: string;
      /** Month the card expires */
      exp_month?: number;
      external_id?: string;
      /** Brand of card. E.g. Amex, Visa, etc. */
      brand?: string;
      /** Year the card expires */
      exp_year?: number;
      /** Last 4 digits of the card. */
      last4?: string;
    };
    CustomerPortalPaymentMethod: {
      /** Type of payment method for the customer. */
      payment_method_type?: string;
      /** Info about the customer's US bank account, if that is their payment method. */
      bank_account_info?: components['schemas']['BankAccountInfo'];
      /** Info about the customer's card, if that is their payment method. */
      card_info?: components['schemas']['CardInfo'];
    };
    SelfServeSettings: {
      /** True if the customer can purchase credits via self serve. Defaults to False. */
      purchase_credits: boolean;
      /** Time length of the default expiration for credits bought in the customer portal. */
      credits_expiration_length?: number | null;
      /** Time length unit for the default expiration for credits bought in the customer portal. */
      credits_expiration_unit?: string | null;
      /** Price per credit, in cents, that the customer is charged for buying credits through the customer portal */
      price_per_credit_cents?: number | null;
      /** True if the customer can switch their current price plan via self serve. Defaults to False. */
      switch_price_plans: boolean;
      /** True if the vendor has enabled customization for their customer portal. */
      customization?: boolean;
    };
    SelfServeCustomization: {
      /** Dictionary of customization settings as key value pairs. */
      settings: { [key: string]: string };
    };
    CreditLedger: {
      pending?: boolean;
      /** The change in numer of credits */
      amount?: number;
      /** Credit balance as of this change */
      balance?: number;
      /** The time at which this credit balance change occurred. */
      timestamp?: string;
    };
    CustomerPortalCreditPurchase: {
      /** Number of credits to purchase. */
      amount: number;
    };
    CreditGrant: {
      /** The source of the grant. */
      source?: string;
      /** The date at which this grant expires */
      expires_at?: string;
      /** Optional description. This is only viewable internally */
      description?: string;
      /** The date at which this grant is effective */
      effective_at?: string;
      /** Total price paid for the credits, in cents */
      price?: number;
      /** Number of credits granted */
      amount?: number;
      /** A unique identifier for this grant */
      uuid?: string;
      /** Name of the customer who received the grant */
      customer_name?: string;
    };
    Webhook: {
      /** The url to send the webhooks to. */
      url: string;
      /** Unique string identifier representing this webhook configuration. */
      uuid?: string;
      /** Determines whether Octane will sign the outgoing webhook */
      enable_signature: boolean;
    };
    CreateWebhookArgs: {
      enable_signature?: boolean;
      url?: string;
    };
    ListCreditGrantsArgs: {
      /** The sort column offset to start at when paging forwards */
      forward_sort_offset?: string;
      sort_direction?: string;
      sort_column?: string;
      /** The unique offset to start at when paging forwards */
      forward_secondary_sort_offset?: string;
      /** Customer to filter the results to */
      customer_name?: string;
      /** The number of items to fetch. Defaults to 10. */
      limit?: number;
    };
    ListCreditGrants: {
      /** The sort column offset to start at when paging forwards */
      forward_sort_offset?: string;
      sort_direction?: string;
      sort_column?: string;
      /** The unique offset to start at when paging forwards */
      forward_secondary_sort_offset?: string;
      credit_grants?: components['schemas']['CreditGrant'][];
      /** The number of items to fetch. Defaults to 10. */
      limit?: number;
    };
    CreateCreditGrantArgs: {
      /** The date at which this grant expires */
      expires_at?: string;
      /** Optional description. This is only viewable internally */
      description?: string;
      /** The date at which the grant is effective */
      effective_at?: string;
      /** Total price paid for the credits in cents. Defaults to $1 (100 cents) per credit if not specified */
      price?: number;
      /** Number of credits to grant */
      amount: number;
      /** Name of the customer receving the grant */
      customer_name: string;
    };
    RollApiKeyArgs: {
      /** The date at which this API key will expire. Will default to 7 days. */
      expires_at?: string;
      /** The API key you want to roll. */
      api_key: string;
    };
    RollApiKeys: {
      /** The newly generated API Key. */
      api_key?: string;
      success?: boolean;
    };
    UpdateSelfServeSettingsArgs: {
      /** Time length of the default expiration for credits bought in the customer portal. */
      credits_expiration_length?: number;
      /** True if the customer can switch their current price plan via self serve. Defaults to False. */
      switch_price_plans?: boolean;
      /** Price per credit, in cents, that the customer is charged for buying credits through the customer portal */
      price_per_credit_cents?: number;
      /** Time length unit for the default expiration for credits bought in the customer portal. */
      credits_expiration_unit?: string;
      /** True if the customer can purchase credits via self serve. Defaults to False. */
      purchase_credits?: boolean;
      /** True if the vendor has enabled customization for their customer portal. */
      enabled?: boolean;
      /** True if the vendor has enabled customization for their customer portal. */
      customization?: boolean;
    };
    VendorAvalaraSettings: {
      /** Password of the Avalara account. */
      password?: string;
      /** Enable/Disable the Avalara integration. */
      enable_integration?: boolean;
      /** The item description to use to represent all the lines on the Octane invoice. */
      item_description?: string;
      /** he tax code to associate with the item that is representing the Octane invoice. */
      tax_code?: string;
      /** True if the documents generated in Avalara should be committed, false otherwise. */
      commit_documents?: boolean;
      /** The Avalara item code to use to represent all the line items on the Octane invoice. */
      item_code?: string;
      /** True if connecting to Avalara sandbox account, false otherwise. */
      sandbox_mode?: boolean;
      /** The Avalara company code string to associate the Octane vendor with. */
      company_code?: string;
      /** Username of the Avalara account. */
      username?: string;
      /** True if enabling logging for Avalara calls, false otherwise. */
      enable_logging?: boolean;
    };
    CreateVendorAvalaraSettingsArgs: {
      /** Password of the Avalara account. */
      password: string;
      /** Enable/Disable the Avalara integration. */
      enable_integration: boolean;
      /** The item description to use to represent all the lines on the Octane invoice. */
      item_description?: string;
      /** The tax code to associate with the item that is representing the Octane invoice. */
      tax_code?: string;
      /** True if the documents generated in Avalara should be committed, false otherwise. Defaults to False. */
      commit_documents?: boolean;
      /** The Avalara item code to use to represent all the line items on the Octane invoice. */
      item_code?: string;
      /** True if connecting to Avalara sandbox account, false otherwise. */
      sandbox_mode: boolean;
      /** The Avalara company code string to associate the Octane vendor with. */
      company_code?: string;
      /** Username of the Avalara account. */
      username: string;
      /** True if enabling logging for Avalara calls, false otherwise. Defaults to False. */
      enable_logging?: boolean;
    };
    UpdateVendorAvalaraSettingsArgs: {
      /** Enable/Disable the Avalara integration. */
      enable_integration?: boolean;
      /** The item description to use to represent all the lines on the Octane invoice. */
      item_description?: string;
      /** he tax code to associate with the item that is representing the Octane invoice. */
      tax_code?: string;
      /** True if the documents generated in Avalara should be committed, false otherwise. */
      commit_documents?: boolean;
      /** The Avalara item code to use to represent all the line items on the Octane invoice. */
      item_code?: string;
      /** The Avalara company code string to associate the Octane vendor with. */
      company_code?: string;
      /** True if enabling logging for Avalara calls, false otherwise. */
      enable_logging?: boolean;
    };
    ValidateCredentialsArgs: {
      /** Password of the Avalara account */
      password: string;
      /** True if using a Avalara sandbox account, False otherwise */
      sandbox_mode: boolean;
      /** Username of the Avalara account */
      username: string;
    };
    ValidateCredentialsResp: {
      /** Indicates whether the ping to Avalara was successful and the credentials were validated. */
      success?: boolean;
    };
    TaxCode: {
      /** A code string that identifies this tax code. */
      tax_code?: string;
      /** The Avalara Entity Use Code represented by this tax code. */
      entity_use_code?: string;
      /** A friendly description of this tax code. */
      description?: string;
      /** The unique ID number of this tax code. */
      id?: string;
      /** The type of this tax code. */
      tax_code_type_id?: string;
    };
    Company: {
      /** This flag indicates whether tax activity can occur for this company. */
      is_active?: boolean;
      /** The name of this company, as shown to customers. */
      company_name?: string;
      /** The unique ID number of this company. */
      id?: string;
      /** A unique code that references this company within your account. */
      company_code?: string;
      /** This flag is true if this company is the default company for this account. */
      is_default?: boolean;
    };
    EntityUseCode: {
      /** The name of this entity use code. */
      name?: string;
      /** A list of countries where this use code is valid. */
      valid_countries?: string[];
      /** The Avalara-recognized entity use code for this definition. */
      code?: string;
      /** Text describing the meaning of this use code. */
      description?: string;
    };
    RevenueRecognitionInput: {
      /** List of customer names for which to compute booked/recognized revenue. */
      customer_names?: string[];
    };
    RevenueRecognitionEntry: {
      /** The change in recognized revenue this month (in cents). */
      recognized?: number;
      /** The newly booked amount in this month (in cents). */
      booked?: number;
      /** The change in deferred revenue this month (in cents). */
      deferred?: number;
      /** The month in which the revenue is booked and(or) recognized. */
      month?: string;
    };
  };
  responses: {
    /** Default error response */
    DEFAULT_ERROR: {
      content: {
        'application/json': components['schemas']['Error'];
      };
    };
    /** Unprocessable Entity */
    UNPROCESSABLE_ENTITY: {
      content: {
        'application/json': components['schemas']['Error'];
      };
    };
  };
}

export interface operations {}

export interface external {}
