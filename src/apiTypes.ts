/**
 * This file was auto-generated by openapi-typescript.
 * Do not make direct changes to the file.
 */

export interface paths {
  '/meters/': {
    /** Get all meters for a given vendor. */
    get: {
      responses: {
        /** OK */
        200: {
          content: {
            'application/json': components['schemas']['Meter'][];
          };
        };
        default: components['responses']['DEFAULT_ERROR'];
      };
    };
    /** Create a new meter for a given vendor. */
    post: {
      responses: {
        /** OK */
        200: {
          content: {
            'application/json': components['schemas']['Meter'];
          };
        };
        422: components['responses']['UNPROCESSABLE_ENTITY'];
        default: components['responses']['DEFAULT_ERROR'];
      };
      requestBody: {
        content: {
          'application/json': components['schemas']['MeterInputArgs'];
        };
      };
    };
  };
  '/meters/{meter_name}': {
    /** Get a meter by its unique name. */
    get: {
      parameters: {
        path: {
          meter_name: string;
        };
      };
      responses: {
        /** OK */
        200: {
          content: {
            'application/json': components['schemas']['Meter'];
          };
        };
        default: components['responses']['DEFAULT_ERROR'];
      };
    };
    /** Update a meter by its unique name. */
    put: {
      parameters: {
        path: {
          meter_name: string;
        };
      };
      responses: {
        /** OK */
        200: {
          content: {
            'application/json': components['schemas']['Meter'];
          };
        };
        422: components['responses']['UNPROCESSABLE_ENTITY'];
        default: components['responses']['DEFAULT_ERROR'];
      };
      requestBody: {
        content: {
          'application/json': components['schemas']['UpdateMeterArgs'];
        };
      };
    };
    /** Delete a meter by its unique name. Meters can only be deleted if not in-use by a price plan. */
    delete: {
      parameters: {
        path: {
          meter_name: string;
        };
      };
      responses: {
        /** No Content */
        204: never;
        default: components['responses']['DEFAULT_ERROR'];
      };
    };
    parameters: {
      path: {
        meter_name: string;
      };
    };
  };
  '/meters/{meter_name}/archive': {
    /** Update a meter by its unique name. */
    post: {
      parameters: {
        path: {
          meter_name: string;
        };
      };
      responses: {
        /** OK */
        200: unknown;
        default: components['responses']['DEFAULT_ERROR'];
      };
    };
    parameters: {
      path: {
        meter_name: string;
      };
    };
  };
  '/measurements/': {
    post: {
      responses: {
        /** OK */
        200: {
          content: {
            'application/json': components['schemas']['Measurement'];
          };
        };
        422: components['responses']['UNPROCESSABLE_ENTITY'];
        default: components['responses']['DEFAULT_ERROR'];
      };
      requestBody: {
        content: {
          'application/json': components['schemas']['Measurement'];
        };
      };
    };
  };
  '/measurements/multi': {
    post: {
      responses: {
        /** OK */
        200: {
          content: {
            'application/json': components['schemas']['Measurement'][];
          };
        };
        422: components['responses']['UNPROCESSABLE_ENTITY'];
        default: components['responses']['DEFAULT_ERROR'];
      };
      requestBody: {
        content: {
          'application/json': components['schemas']['Measurement'][];
        };
      };
    };
  };
  '/customers/': {
    /** Retrieve all customers for a given vendor. */
    get: {
      responses: {
        /** OK */
        200: {
          content: {
            'application/json': components['schemas']['Customer'][];
          };
        };
        default: components['responses']['DEFAULT_ERROR'];
      };
    };
    /** Create a new customer. */
    post: {
      responses: {
        /** OK */
        200: {
          content: {
            'application/json': components['schemas']['Customer'];
          };
        };
        422: components['responses']['UNPROCESSABLE_ENTITY'];
        default: components['responses']['DEFAULT_ERROR'];
      };
      requestBody: {
        content: {
          'application/json': components['schemas']['CreateCustomerArgs'];
        };
      };
    };
  };
  '/customers/{customer_name}': {
    /** Fetch a customer by their unique name. */
    get: {
      parameters: {
        path: {
          customer_name: string;
        };
      };
      responses: {
        /** OK */
        200: {
          content: {
            'application/json': components['schemas']['Customer'];
          };
        };
        default: components['responses']['DEFAULT_ERROR'];
      };
    };
    /** Update a single customer. To update Customer measurement mappings, use the `customers/{customer_name}/mappings` endpoint. */
    put: {
      parameters: {
        path: {
          customer_name: string;
        };
      };
      responses: {
        /** OK */
        200: {
          content: {
            'application/json': components['schemas']['Customer'];
          };
        };
        422: components['responses']['UNPROCESSABLE_ENTITY'];
        default: components['responses']['DEFAULT_ERROR'];
      };
      requestBody: {
        content: {
          'application/json': components['schemas']['UpdateCustomerArgs'];
        };
      };
    };
    /** Delete a customer by their unique name. */
    delete: {
      parameters: {
        path: {
          customer_name: string;
        };
      };
      responses: {
        /** No Content */
        204: never;
        default: components['responses']['DEFAULT_ERROR'];
      };
    };
    parameters: {
      path: {
        customer_name: string;
      };
    };
  };
  '/customers/{customer_name}/mappings': {
    /** Fetch all measurement mappings for a specific customer (by unique customer name). */
    get: {
      parameters: {
        path: {
          customer_name: string;
        };
      };
      responses: {
        /** OK */
        200: {
          content: {
            'application/json': components['schemas']['CustomerMeasurementMapping'][];
          };
        };
        default: components['responses']['DEFAULT_ERROR'];
      };
    };
    /** Create a new measurement mapping for a customer. If no value_regex is passed, label existence is checked instead. */
    post: {
      parameters: {
        path: {
          customer_name: string;
        };
      };
      responses: {
        /** OK */
        200: {
          content: {
            'application/json': components['schemas']['CustomerMeasurementMapping'];
          };
        };
        422: components['responses']['UNPROCESSABLE_ENTITY'];
        default: components['responses']['DEFAULT_ERROR'];
      };
      requestBody: {
        content: {
          'application/json': components['schemas']['CustomerMeasurementMappingInputArgs'];
        };
      };
    };
    parameters: {
      path: {
        customer_name: string;
      };
    };
  };
  '/customers/{customer_name}/payment_method_status': {
    /** Fetch payment method status for a specific customer (by unique customer name). */
    get: {
      parameters: {
        path: {
          customer_name: string;
        };
      };
      responses: {
        /** OK */
        200: {
          content: {
            'application/json': components['schemas']['CustomerPaymentMethodStatus'];
          };
        };
        default: components['responses']['DEFAULT_ERROR'];
      };
    };
    parameters: {
      path: {
        customer_name: string;
      };
    };
  };
  '/customers/{customer_name}/payment_gateway_credentials': {
    /**
     * Get the payment gateway credentials from the vendor's configured payment gateway for the given customer.
     * For example, this endpoint will return a customer's Stripe customer ID, assuming the vendor has integrated with stripe and has configured the given customer with a Stripe customer ID.
     */
    get: {
      parameters: {
        path: {
          customer_name: string;
        };
      };
      responses: {
        /** OK */
        200: {
          content: {
            'application/json': components['schemas']['PaymentGatewayCredential'];
          };
        };
        default: components['responses']['DEFAULT_ERROR'];
      };
    };
    /**
     * Add credentials for a customer's account in the vendor's currently configured payment gateway.
     * For example, this endpoint can be used to associate a customer with a Stripe customer ID.
     */
    post: {
      parameters: {
        path: {
          customer_name: string;
        };
      };
      responses: {
        /** OK */
        200: {
          content: {
            'application/json': components['schemas']['PaymentGatewayCredential'];
          };
        };
        422: components['responses']['UNPROCESSABLE_ENTITY'];
        default: components['responses']['DEFAULT_ERROR'];
      };
      requestBody: {
        content: {
          'application/json': components['schemas']['CustomerPaymentGatewayCredentialInputArgs'];
        };
      };
    };
    parameters: {
      path: {
        customer_name: string;
      };
    };
  };
  '/customers/{customer_name}/billing_settings': {
    /** Fetch the billing settings for a customer. */
    get: {
      parameters: {
        path: {
          customer_name: string;
        };
      };
      responses: {
        /** OK */
        200: {
          content: {
            'application/json': components['schemas']['BillingSettings'];
          };
        };
        default: components['responses']['DEFAULT_ERROR'];
      };
    };
    /** Update billing settings for a customer. */
    put: {
      parameters: {
        path: {
          customer_name: string;
        };
      };
      responses: {
        /** OK */
        200: {
          content: {
            'application/json': components['schemas']['BillingSettings'];
          };
        };
        422: components['responses']['UNPROCESSABLE_ENTITY'];
        default: components['responses']['DEFAULT_ERROR'];
      };
      requestBody: {
        content: {
          'application/json': components['schemas']['CustomerBillingSettingsInputArgs'];
        };
      };
    };
    /** Create billing settings for a customer. */
    post: {
      parameters: {
        path: {
          customer_name: string;
        };
      };
      responses: {
        /** OK */
        200: {
          content: {
            'application/json': components['schemas']['BillingSettings'];
          };
        };
        422: components['responses']['UNPROCESSABLE_ENTITY'];
        default: components['responses']['DEFAULT_ERROR'];
      };
      requestBody: {
        content: {
          'application/json': components['schemas']['CustomerBillingSettingsInputArgs'];
        };
      };
    };
    /** Delete billing settings for a customer. */
    delete: {
      parameters: {
        path: {
          customer_name: string;
        };
      };
      responses: {
        /** No Content */
        204: never;
        default: components['responses']['DEFAULT_ERROR'];
      };
    };
    parameters: {
      path: {
        customer_name: string;
      };
    };
  };
  '/customers/{customer_name}/revenue': {
    /** Fetch revenue of a customer from start_time and end_time. */
    get: {
      parameters: {
        path: {
          customer_name: string;
        };
        query: {
          start_time?: string;
          end_time?: string;
        };
      };
      responses: {
        /** OK */
        200: {
          content: {
            'application/json': components['schemas']['RevenueResponse'];
          };
        };
        422: components['responses']['UNPROCESSABLE_ENTITY'];
        default: components['responses']['DEFAULT_ERROR'];
      };
    };
    parameters: {
      path: {
        customer_name: string;
      };
    };
  };
  '/customers/{customer_name}/invoice/{invoice_id}/{token}': {
    /** Fetch current cycle revenue for a customer and generate an invoice. */
    get: {
      parameters: {
        path: {
          token: string;
          invoice_id: number;
          customer_name: string;
        };
      };
      responses: {
        default: components['responses']['DEFAULT_ERROR'];
      };
    };
    parameters: {
      path: {
        token: string;
        invoice_id: number;
        customer_name: string;
      };
    };
  };
  '/customers/{customer_name}/sample_invoice/{as_of_str}/{token}': {
    /** Fetch current cycle revenue for a customer and generate an invoice. */
    get: {
      parameters: {
        path: {
          token: string;
          customer_name: string;
          as_of_str: string;
        };
      };
      responses: {
        default: components['responses']['DEFAULT_ERROR'];
      };
    };
    parameters: {
      path: {
        token: string;
        customer_name: string;
        as_of_str: string;
      };
    };
  };
  '/customers/{customer_name}/sample_invoice/{token}': {
    /** Fetch current cycle revenue for a customer and generate an invoice. */
    get: {
      parameters: {
        path: {
          token: string;
          customer_name: string;
        };
      };
      responses: {
        default: components['responses']['DEFAULT_ERROR'];
      };
    };
    parameters: {
      path: {
        token: string;
        customer_name: string;
      };
    };
  };
  '/customers/{customer_name}/status': {
    /** Get the current status for a customer. */
    get: {
      parameters: {
        path: {
          customer_name: string;
        };
      };
      responses: {
        /** OK */
        200: {
          content: {
            'application/json': components['schemas']['CustomerStatus'];
          };
        };
        default: components['responses']['DEFAULT_ERROR'];
      };
    };
    parameters: {
      path: {
        customer_name: string;
      };
    };
  };
  '/customers/{customer_name}/usage': {
    /** For the given meter, get a customer's total usage. */
    get: {
      parameters: {
        path: {
          customer_name: string;
        };
        query: {
          /** Ending timestamp to consider usage formatted as ISO-8601. */
          end_time?: string;
          /** Starting timestamp to consider usage formatted as ISO-8601. */
          start_time?: string;
          meter_name?: string;
        };
      };
      responses: {
        /** OK */
        200: {
          content: {
            'application/json': components['schemas']['CustomerUsage'];
          };
        };
        422: components['responses']['UNPROCESSABLE_ENTITY'];
        default: components['responses']['DEFAULT_ERROR'];
      };
    };
    parameters: {
      path: {
        customer_name: string;
      };
    };
  };
  '/customers/{customer_name}/features/{feature_name}': {
    /** Get the details of a feature for a given customer. The feature's status is determined by their subscription first, and by their price plan if no feature overrides are found on the subscription. */
    get: {
      parameters: {
        path: {
          feature_name: string;
          customer_name: string;
        };
      };
      responses: {
        /** OK */
        200: {
          content: {
            'application/json': components['schemas']['CustomerFeature'];
          };
        };
        default: components['responses']['DEFAULT_ERROR'];
      };
    };
    parameters: {
      path: {
        feature_name: string;
        customer_name: string;
      };
    };
  };
  '/customers/{customer_name}/accrued_revenue': {
    /** Get the accrued revenue and invoice line items for the given customer. */
    get: {
      parameters: {
        path: {
          customer_name: string;
        };
      };
      responses: {
        /** OK */
        200: {
          content: {
            'application/json': components['schemas']['RevenueBreakdown'];
          };
        };
        default: components['responses']['DEFAULT_ERROR'];
      };
    };
    parameters: {
      path: {
        customer_name: string;
      };
    };
  };
  '/customers/{customer_name}/accounting': {
    /** Get the accounting customer ID of a customer that has been connected via an accounting integration. */
    get: {
      parameters: {
        path: {
          customer_name: string;
        };
      };
      responses: {
        /** OK */
        200: {
          content: {
            'application/json': components['schemas']['AccountingCustomer'];
          };
        };
        default: components['responses']['DEFAULT_ERROR'];
      };
    };
    /** Connect an Octane customer to an Accounting customer through the configured Accounting integration. The vendor must have an integration configured. */
    post: {
      parameters: {
        path: {
          customer_name: string;
        };
      };
      responses: {
        /** OK */
        200: unknown;
        422: components['responses']['UNPROCESSABLE_ENTITY'];
        default: components['responses']['DEFAULT_ERROR'];
      };
      requestBody: {
        content: {
          'application/json': components['schemas']['AccountingCustomer'];
        };
      };
    };
    parameters: {
      path: {
        customer_name: string;
      };
    };
  };
  '/customers/{customer_name}/metadata': {
    /** Get the metadata for a given customer */
    get: {
      parameters: {
        path: {
          customer_name: string;
        };
      };
      responses: {
        default: components['responses']['DEFAULT_ERROR'];
      };
    };
    /** Add metadata to a customer (e.g., a tuple of Region: US for a US based customer) */
    post: {
      parameters: {
        path: {
          customer_name: string;
        };
      };
      responses: {
        /** OK */
        200: unknown;
        422: components['responses']['UNPROCESSABLE_ENTITY'];
        default: components['responses']['DEFAULT_ERROR'];
      };
      requestBody: {
        content: {
          'application/json': components['schemas']['CustomerMetadata'][];
        };
      };
    };
    parameters: {
      path: {
        customer_name: string;
      };
    };
  };
  '/customers/{customer_name}/invoices': {
    /** Get a list of invoices and their line items for a customer. */
    get: {
      parameters: {
        path: {
          customer_name: string;
        };
        query: {
          sort_direction?: string;
          customer_name?: string;
          start_time?: string;
          /** The unique offset to start at when paging forwards */
          forward_secondary_sort_offset?: string;
          /** The number of items to fetch. Defaults to 10. */
          limit?: number;
          status?: string;
          sort_column?: string;
          /** The sort column offset to start at when paging forwards */
          forward_sort_offset?: string;
        };
      };
      responses: {
        /** OK */
        200: {
          content: {
            'application/json': components['schemas']['Invoice'][];
          };
        };
        422: components['responses']['UNPROCESSABLE_ENTITY'];
        default: components['responses']['DEFAULT_ERROR'];
      };
    };
    parameters: {
      path: {
        customer_name: string;
      };
    };
  };
  '/customers/{customer_name}/subscriptions': {
    /** Get all subscriptions for the customer. */
    get: {
      parameters: {
        path: {
          customer_name: string;
        };
      };
      responses: {
        /** OK */
        200: {
          content: {
            'application/json': components['schemas']['Subscription'][];
          };
        };
        default: components['responses']['DEFAULT_ERROR'];
      };
    };
    /** Create a new subscription for a customer / price plan combination (by unique name). */
    post: {
      parameters: {
        path: {
          customer_name: string;
        };
      };
      responses: {
        /** OK */
        200: {
          content: {
            'application/json': components['schemas']['Subscription'];
          };
        };
        422: components['responses']['UNPROCESSABLE_ENTITY'];
        default: components['responses']['DEFAULT_ERROR'];
      };
      requestBody: {
        content: {
          'application/json': components['schemas']['CreateSubscriptionArgs'];
        };
      };
    };
    parameters: {
      path: {
        customer_name: string;
      };
    };
  };
  '/customers/{customer_name}/subscription': {
    /** Update a subscription for a specific customer (by customer name). */
    put: {
      parameters: {
        path: {
          customer_name: string;
        };
      };
      responses: {
        /** OK */
        200: {
          content: {
            'application/json': components['schemas']['Subscription'];
          };
        };
        422: components['responses']['UNPROCESSABLE_ENTITY'];
        default: components['responses']['DEFAULT_ERROR'];
      };
      requestBody: {
        content: {
          'application/json': components['schemas']['UpdateSubscriptionArgs'];
        };
      };
    };
    /** Delete a subscription for a specific customer (by customer name). */
    delete: {
      parameters: {
        path: {
          customer_name: string;
        };
      };
      responses: {
        /** No Content */
        204: never;
        422: components['responses']['UNPROCESSABLE_ENTITY'];
        default: components['responses']['DEFAULT_ERROR'];
      };
      requestBody: {
        content: {
          'application/json': components['schemas']['DeleteSubscriptionArgs'];
        };
      };
    };
    parameters: {
      path: {
        customer_name: string;
      };
    };
  };
  '/customers/{customer_name}/subscription/update_in_place': {
    /** Update a subscription in-place for a specific customer (by customer name). */
    put: {
      parameters: {
        path: {
          customer_name: string;
        };
      };
      responses: {
        /** OK */
        200: {
          content: {
            'application/json': components['schemas']['Subscription'];
          };
        };
        422: components['responses']['UNPROCESSABLE_ENTITY'];
        default: components['responses']['DEFAULT_ERROR'];
      };
      requestBody: {
        content: {
          'application/json': components['schemas']['UpdateSubscriptionInPlaceArgs'];
        };
      };
    };
    parameters: {
      path: {
        customer_name: string;
      };
    };
  };
  '/customers/{customer_name}/active_subscription': {
    /** Get the customer's current active subscription. */
    get: {
      parameters: {
        path: {
          customer_name: string;
        };
      };
      responses: {
        /** OK */
        200: {
          content: {
            'application/json': components['schemas']['ActiveSubscription'];
          };
        };
        default: components['responses']['DEFAULT_ERROR'];
      };
    };
    parameters: {
      path: {
        customer_name: string;
      };
    };
  };
  '/customers/{customer_name}/scheduled_subscriptions': {
    /** Get a list of any subscriptions scheduled to start in the future for the given customer. */
    get: {
      parameters: {
        path: {
          customer_name: string;
        };
      };
      responses: {
        /** OK */
        200: {
          content: {
            'application/json': components['schemas']['Subscription'][];
          };
        };
        default: components['responses']['DEFAULT_ERROR'];
      };
    };
    parameters: {
      path: {
        customer_name: string;
      };
    };
  };
  '/customers/{customer_name}/subscription/add_ons': {
    /** Add or remove add ons from the current customer's subscription. */
    post: {
      parameters: {
        path: {
          customer_name: string;
        };
      };
      responses: {
        /** OK */
        200: unknown;
        422: components['responses']['UNPROCESSABLE_ENTITY'];
        default: components['responses']['DEFAULT_ERROR'];
      };
      requestBody: {
        content: {
          'application/json': components['schemas']['SubscriptionAddOnItem'][];
        };
      };
    };
    parameters: {
      path: {
        customer_name: string;
      };
    };
  };
  '/invoices/{invoice_uuid}/status/': {
    /**
     * Manually change the status of an invoice in Octane. For example,
     * if an invoice was paid outside of Octane's payment providers, you can reflect that in Octane by
     * setting the status to paid.
     */
    post: {
      parameters: {
        path: {
          invoice_uuid: string;
        };
      };
      responses: {
        default: components['responses']['DEFAULT_ERROR'];
      };
    };
    parameters: {
      path: {
        invoice_uuid: string;
      };
    };
  };
  '/invoices/': {
    /** Fetch a list of historical invoices generated by Octane. */
    get: {
      parameters: {
        query: {
          sort_direction?: string;
          customer_name?: string;
          start_time?: string;
          /** The unique offset to start at when paging forwards */
          forward_secondary_sort_offset?: string;
          /** The number of items to fetch. Defaults to 10. */
          limit?: number;
          status?: string;
          sort_column?: string;
          /** The sort column offset to start at when paging forwards */
          forward_sort_offset?: string;
        };
      };
      responses: {
        /** OK */
        200: {
          content: {
            'application/json': components['schemas']['PastInvoices'];
          };
        };
        422: components['responses']['UNPROCESSABLE_ENTITY'];
        default: components['responses']['DEFAULT_ERROR'];
      };
    };
  };
  '/invoices/upcoming': {
    /** Fetch a list of the upcoming invoices for your account. */
    get: {
      parameters: {
        query: {
          sort_direction?: string;
          customer_name?: string;
          start_time?: string;
          /** The unique offset to start at when paging forwards */
          forward_secondary_sort_offset?: string;
          /** The number of items to fetch. Defaults to 10. */
          limit?: number;
          status?: string;
          sort_column?: string;
          /** The sort column offset to start at when paging forwards */
          forward_sort_offset?: string;
        };
      };
      responses: {
        /** OK */
        200: {
          content: {
            'application/json': components['schemas']['UpcomingInvoices'];
          };
        };
        422: components['responses']['UNPROCESSABLE_ENTITY'];
        default: components['responses']['DEFAULT_ERROR'];
      };
    };
  };
  '/invoices/{invoice_uuid_token}/pdf': {
    /** Return the invoice pdf for the given invoice_uuid, first validating token. */
    get: {
      parameters: {
        path: {
          invoice_uuid_token: string;
        };
      };
      responses: {
        default: components['responses']['DEFAULT_ERROR'];
      };
    };
    parameters: {
      path: {
        invoice_uuid_token: string;
      };
    };
  };
  '/price_plans/': {
    /** Get all price plans associated with a vendor. */
    get: {
      responses: {
        /** OK */
        200: {
          content: {
            'application/json': components['schemas']['PricePlan'][];
          };
        };
        default: components['responses']['DEFAULT_ERROR'];
      };
    };
    /** Create a price plan for a vendor. */
    post: {
      responses: {
        /** OK */
        200: {
          content: {
            'application/json': components['schemas']['PricePlan'];
          };
        };
        422: components['responses']['UNPROCESSABLE_ENTITY'];
        default: components['responses']['DEFAULT_ERROR'];
      };
      requestBody: {
        content: {
          'application/json': components['schemas']['CreatePricePlanArgs'];
        };
      };
    };
  };
  '/price_plans/{price_plan_name}/{tag}': {
    /** Get an existing price plan. */
    get: {
      parameters: {
        path: {
          price_plan_name: string;
          tag: string;
        };
      };
      responses: {
        /** OK */
        200: {
          content: {
            'application/json': components['schemas']['PricePlan'];
          };
        };
        default: components['responses']['DEFAULT_ERROR'];
      };
    };
    parameters: {
      path: {
        price_plan_name: string;
        tag: string;
      };
    };
  };
  '/price_plans/paginate': {
    /** List all price plans with pagination. */
    get: {
      parameters: {
        query: {
          sort_direction?: string;
          names?: string[];
          /** The unique offset to start at when paging forwards */
          forward_secondary_sort_offset?: string;
          /** The number of items to fetch. Defaults to 10. */
          limit?: number;
          tags?: string[];
          sort_column?: string;
          /** The sort column offset to start at when paging forwards */
          forward_sort_offset?: string;
        };
      };
      responses: {
        /** OK */
        200: {
          content: {
            'application/json': components['schemas']['ListPricePlans'];
          };
        };
        422: components['responses']['UNPROCESSABLE_ENTITY'];
        default: components['responses']['DEFAULT_ERROR'];
      };
    };
  };
  '/price_plans/{price_plan_name}': {
    /** Fetch an existing price plan. */
    get: {
      parameters: {
        path: {
          price_plan_name: string;
        };
      };
      responses: {
        /** OK */
        200: {
          content: {
            'application/json': components['schemas']['PricePlan'];
          };
        };
        default: components['responses']['DEFAULT_ERROR'];
      };
    };
    /** Update an existing price plan. */
    put: {
      parameters: {
        path: {
          price_plan_name: string;
        };
      };
      responses: {
        /** OK */
        200: {
          content: {
            'application/json': components['schemas']['PricePlan'];
          };
        };
        422: components['responses']['UNPROCESSABLE_ENTITY'];
        default: components['responses']['DEFAULT_ERROR'];
      };
      requestBody: {
        content: {
          'application/json': components['schemas']['UpdatePricePlanArgs'];
        };
      };
    };
    /** Delete an existing Price Plan. Price Plans which map to active Subscriptions must be replaced or removed before deletion can occur. */
    delete: {
      parameters: {
        path: {
          price_plan_name: string;
        };
      };
      responses: {
        /** No Content */
        204: never;
        default: components['responses']['DEFAULT_ERROR'];
      };
    };
    parameters: {
      path: {
        price_plan_name: string;
      };
    };
  };
  '/price_plans/update_in_place/{price_plan_name}/{tag}': {
    /** Edit a price plan without creating a new version. */
    post: {
      parameters: {
        path: {
          price_plan_name: string;
          tag: string;
        };
      };
      responses: {
        /** OK */
        200: {
          content: {
            'application/json': components['schemas']['PricePlan'];
          };
        };
        422: components['responses']['UNPROCESSABLE_ENTITY'];
        default: components['responses']['DEFAULT_ERROR'];
      };
      requestBody: {
        content: {
          'application/json': components['schemas']['UpdatePricePlanInPlaceArgs'];
        };
      };
    };
    parameters: {
      path: {
        price_plan_name: string;
        tag: string;
      };
    };
  };
  '/price_plans/update_in_place/{price_plan_name}': {
    /** Edit a price plan without creating a new version. */
    post: {
      parameters: {
        path: {
          price_plan_name: string;
        };
      };
      responses: {
        /** OK */
        200: {
          content: {
            'application/json': components['schemas']['PricePlan'];
          };
        };
        422: components['responses']['UNPROCESSABLE_ENTITY'];
        default: components['responses']['DEFAULT_ERROR'];
      };
      requestBody: {
        content: {
          'application/json': components['schemas']['UpdatePricePlanInPlaceArgs'];
        };
      };
    };
    parameters: {
      path: {
        price_plan_name: string;
      };
    };
  };
  '/price_plans/{price_plan_name}/archive': {
    /** Archive a price plan that has no active/scheduled subscription. */
    post: {
      parameters: {
        path: {
          price_plan_name: string;
        };
      };
      responses: {
        /** OK */
        200: unknown;
        default: components['responses']['DEFAULT_ERROR'];
      };
    };
    parameters: {
      path: {
        price_plan_name: string;
      };
    };
  };
  '/price_plans/self_serve': {
    /** Get all price plans marked for self serve for this vendor. */
    get: {
      responses: {
        /** OK */
        200: {
          content: {
            'application/json': components['schemas']['PricePlan'][];
          };
        };
        default: components['responses']['DEFAULT_ERROR'];
      };
    };
    /** Set the exhaustive list of price plans that the customer can see and select via self serve. */
    post: {
      responses: {
        /** OK */
        200: unknown;
        422: components['responses']['UNPROCESSABLE_ENTITY'];
        default: components['responses']['DEFAULT_ERROR'];
      };
      requestBody: {
        content: {
          'application/json': components['schemas']['SelfServePricePlansInputArgs'];
        };
      };
    };
  };
  '/payment_gateway_credentials/': {
    /** Returns the payment gateway information for your account (the Paddle or Stripe credentials used to issue and pay invoices) */
    get: {
      responses: {
        /** OK */
        200: {
          content: {
            'application/json': components['schemas']['PaymentGatewayCredential'];
          };
        };
        default: components['responses']['DEFAULT_ERROR'];
      };
    };
    /** Adds the credentials for a payment gateway, to be used to issue and pay invoices to your account. */
    post: {
      responses: {
        /** OK */
        200: {
          content: {
            'application/json': components['schemas']['PaymentGatewayCredential'];
          };
        };
        422: components['responses']['UNPROCESSABLE_ENTITY'];
        default: components['responses']['DEFAULT_ERROR'];
      };
      requestBody: {
        content: {
          'application/json': components['schemas']['PaymentGatewayCredentialInputArgs'];
        };
      };
    };
  };
  '/billing_settings/': {
    /** Get billing settings for a vendor. */
    get: {
      responses: {
        /** OK */
        200: {
          content: {
            'application/json': components['schemas']['BillingSettings'];
          };
        };
        default: components['responses']['DEFAULT_ERROR'];
      };
    };
    /** Update billing settings for a vendor. */
    put: {
      responses: {
        /** OK */
        200: {
          content: {
            'application/json': components['schemas']['BillingSettings'];
          };
        };
        422: components['responses']['UNPROCESSABLE_ENTITY'];
        default: components['responses']['DEFAULT_ERROR'];
      };
      requestBody: {
        content: {
          'application/json': components['schemas']['UpdateBillingSettingsInputArgs'];
        };
      };
    };
    /** Create billing settings for a vendor. */
    post: {
      responses: {
        /** OK */
        200: {
          content: {
            'application/json': components['schemas']['BillingSettings'];
          };
        };
        422: components['responses']['UNPROCESSABLE_ENTITY'];
        default: components['responses']['DEFAULT_ERROR'];
      };
      requestBody: {
        content: {
          'application/json': components['schemas']['CreateBillingSettingsInputArgs'];
        };
      };
    };
    /** Delete billing settings for a vendor. */
    delete: {
      responses: {
        /** No Content */
        204: never;
        default: components['responses']['DEFAULT_ERROR'];
      };
    };
  };
  '/coupons/': {
    /** Gets all coupons for a specific vendor. */
    get: {
      responses: {
        /** OK */
        200: {
          content: {
            'application/json': components['schemas']['Coupon'][];
          };
        };
        default: components['responses']['DEFAULT_ERROR'];
      };
    };
    /** Create a coupon for a vendor. */
    post: {
      responses: {
        /** OK */
        200: {
          content: {
            'application/json': components['schemas']['Coupon'];
          };
        };
        422: components['responses']['UNPROCESSABLE_ENTITY'];
        default: components['responses']['DEFAULT_ERROR'];
      };
      requestBody: {
        content: {
          'application/json': components['schemas']['CouponInputArgs'];
        };
      };
    };
  };
  '/coupons/{coupon_name}': {
    /** Get a specific coupon for a vendor. */
    get: {
      parameters: {
        path: {
          coupon_name: string;
        };
      };
      responses: {
        /** OK */
        200: {
          content: {
            'application/json': components['schemas']['Coupon'];
          };
        };
        default: components['responses']['DEFAULT_ERROR'];
      };
    };
    /** Delete a specific coupon for a vendor. */
    delete: {
      parameters: {
        path: {
          coupon_name: string;
        };
      };
      responses: {
        /** No Content */
        204: never;
        default: components['responses']['DEFAULT_ERROR'];
      };
    };
    parameters: {
      path: {
        coupon_name: string;
      };
    };
  };
  '/coupons/apply_coupon': {
    /** Apply a coupon to the provided customer. */
    post: {
      responses: {
        /** OK */
        200: unknown;
        422: components['responses']['UNPROCESSABLE_ENTITY'];
        default: components['responses']['DEFAULT_ERROR'];
      };
      requestBody: {
        content: {
          'application/json': components['schemas']['ApplyCouponInputArgs'];
        };
      };
    };
  };
  '/refund/': {
    /** Create a refund for a paid invoice. */
    post: {
      responses: {
        /** Accepted */
        202: {
          content: {
            'application/json': components['schemas']['Refund'];
          };
        };
        422: components['responses']['UNPROCESSABLE_ENTITY'];
        default: components['responses']['DEFAULT_ERROR'];
      };
      requestBody: {
        content: {
          'application/json': components['schemas']['CreateRefundArgs'];
        };
      };
    };
  };
  '/customer_portal_settings/': {
    /** Fetch the Customer Portal settings for your account. */
    get: {
      responses: {
        /** OK */
        200: {
          content: {
            'application/json': components['schemas']['CustomerPortalSettings'];
          };
        };
        default: components['responses']['DEFAULT_ERROR'];
      };
    };
    /** Update Customer Portal settings for your account. */
    post: {
      responses: {
        /** OK */
        200: {
          content: {
            'application/json': components['schemas']['CustomerPortalSettings'];
          };
        };
        422: components['responses']['UNPROCESSABLE_ENTITY'];
        default: components['responses']['DEFAULT_ERROR'];
      };
      requestBody: {
        content: {
          'application/json': components['schemas']['UpdateCustomerPortalSettingsInputArgs'];
        };
      };
    };
  };
  '/ecp/token': {
    /** Generate a customer-scoped JWT to authorize access to ECP endpoints. This endpoint expects the vendor API key for authentication. */
    post: {
      responses: {
        /** OK */
        200: {
          content: {
            'application/json': components['schemas']['CustomerPortalToken'];
          };
        };
        422: components['responses']['UNPROCESSABLE_ENTITY'];
        default: components['responses']['DEFAULT_ERROR'];
      };
      requestBody: {
        content: {
          'application/json': components['schemas']['CustomerPortalTokenInputArgs'];
        };
      };
    };
  };
  '/ecp/customer_portal_url': {
    /** Generate the url to the customer portal. This endpoint expects the vendor API key for authentication. */
    post: {
      responses: {
        /** OK */
        200: {
          content: {
            'application/json': components['schemas']['CustomerPortalUrl'];
          };
        };
        422: components['responses']['UNPROCESSABLE_ENTITY'];
        default: components['responses']['DEFAULT_ERROR'];
      };
      requestBody: {
        content: {
          'application/json': components['schemas']['CustomerPortalTokenInputArgs'];
        };
      };
    };
  };
  '/ecp/portal_url': {
    /** Get the url to the customer portal. This endpoint expects the customer-scoped token for authentication. */
    get: {
      responses: {
        /** OK */
        200: {
          content: {
            'application/json': components['schemas']['CustomerPortalUrl'];
          };
        };
        default: components['responses']['DEFAULT_ERROR'];
      };
    };
  };
  '/ecp/vendor': {
    /** Get relevant information about the customer's vendor. This endpoint expects the customer-scoped token for authentication. */
    get: {
      responses: {
        /** OK */
        200: {
          content: {
            'application/json': components['schemas']['CustomerPortalVendor'];
          };
        };
        default: components['responses']['DEFAULT_ERROR'];
      };
    };
  };
  '/ecp/price_plans': {
    /** Get all price plans visible to the given customer for self serve. By default, no price plans are visible. Price plan visibility can be configured by the vendor using the /price_plans/self_serve endpoint. */
    get: {
      responses: {
        /** OK */
        200: {
          content: {
            'application/json': components['schemas']['PricePlan'][];
          };
        };
        default: components['responses']['DEFAULT_ERROR'];
      };
    };
  };
  '/ecp/invoices': {
    /** Get all invoices visible to the given customer. This endpoint expects the customer-scoped token for authentication. */
    get: {
      responses: {
        /** OK */
        200: {
          content: {
            'application/json': components['schemas']['CustomerPortalInvoice'][];
          };
        };
        default: components['responses']['DEFAULT_ERROR'];
      };
    };
  };
  '/ecp/active_subscription': {
    /** Fetch the customer's active subscription and related information if they exists. This endpoint expects the customer-scoped token for authentication. */
    get: {
      responses: {
        /** OK */
        200: {
          content: {
            'application/json': components['schemas']['CustomerPortalActiveSubscription'];
          };
        };
        default: components['responses']['DEFAULT_ERROR'];
      };
    };
    /** Create/update the customer's subscription. This endpoint expects the customer-scoped token for authentication. */
    post: {
      responses: {
        /** OK */
        200: {
          content: {
            'application/json': components['schemas']['CustomerPortalSubscription'];
          };
        };
        422: components['responses']['UNPROCESSABLE_ENTITY'];
        default: components['responses']['DEFAULT_ERROR'];
      };
      requestBody: {
        content: {
          'application/json': components['schemas']['CustomerPortalActiveSubscriptionInputArgs'];
        };
      };
    };
  };
  '/ecp/subscription': {
    /** Fetch the customer's active price plan if it exists. This endpoint expects the customer-scoped token for authentication. */
    get: {
      responses: {
        /** OK */
        200: {
          content: {
            'application/json': components['schemas']['CustomerPortalSubscription'];
          };
        };
        default: components['responses']['DEFAULT_ERROR'];
      };
    };
    /** Create/update the customer's subscription. This endpoint expects the customer-scoped token for authentication. */
    post: {
      responses: {
        /** OK */
        200: {
          content: {
            'application/json': components['schemas']['CustomerPortalSubscription'];
          };
        };
        422: components['responses']['UNPROCESSABLE_ENTITY'];
        default: components['responses']['DEFAULT_ERROR'];
      };
      requestBody: {
        content: {
          'application/json': components['schemas']['CustomerPortalSubscriptionInputArgs'];
        };
      };
    };
    /** Cancel the customer's subscription. This endpoint expects the customer-scoped token for authentication. */
    delete: {
      responses: {
        /** No Content */
        204: never;
        default: components['responses']['DEFAULT_ERROR'];
      };
    };
  };
  '/ecp/setup_intent': {
    /** Attempt to create a Stripe SetupIntent object. This endpoint expects the customer-scoped token for authentication. */
    post: {
      responses: {
        /** OK */
        200: {
          content: {
            'application/json': components['schemas']['CustomerPortalStripeCredential'];
          };
        };
        default: components['responses']['DEFAULT_ERROR'];
      };
    };
  };
  '/ecp/payment_method_status': {
    /** Gets the customer's current payment method status. Returns a 400 if the customer has no configuration or if the current payment provider doesn't have customer-level payment status. This endpoint expects the customer-scoped token for authentication. */
    get: {
      responses: {
        /** OK */
        200: {
          content: {
            'application/json': components['schemas']['CustomerPaymentMethodStatus'];
          };
        };
        default: components['responses']['DEFAULT_ERROR'];
      };
    };
  };
  '/ecp/contact_info': {
    /** Gets the customer's contact info. This endpoint expects the customer-scoped token for authentication. */
    get: {
      responses: {
        /** OK */
        200: {
          content: {
            'application/json': components['schemas']['ContactInfo'];
          };
        };
        default: components['responses']['DEFAULT_ERROR'];
      };
    };
    /** Create/update the customer's contact info. This endpoint expects the customer-scoped token for authentication. */
    put: {
      responses: {
        /** OK */
        200: {
          content: {
            'application/json': components['schemas']['ContactInfo'];
          };
        };
        422: components['responses']['UNPROCESSABLE_ENTITY'];
        default: components['responses']['DEFAULT_ERROR'];
      };
      requestBody: {
        content: {
          'application/json': components['schemas']['ContactInfoInputArgs'];
        };
      };
    };
  };
  '/ecp/usage': {
    /** Get the customer's daily usage by meter for current and previous billing cycles. This endpoint expects the customer-scoped token for authentication. */
    get: {
      responses: {
        /** OK */
        200: {
          content: {
            'application/json': components['schemas']['CustomerPortalUsage'][];
          };
        };
        default: components['responses']['DEFAULT_ERROR'];
      };
    };
  };
  '/ecp/payment_method': {
    /** Get the customer's current payment method if it exists in their payment gateway. This endpoint expects the customer-scoped token for authentication. */
    get: {
      responses: {
        /** OK */
        200: {
          content: {
            'application/json': components['schemas']['CustomerPortalPaymentMethod'];
          };
        };
        default: components['responses']['DEFAULT_ERROR'];
      };
    };
  };
  '/ecp/self_serve_settings': {
    /** Get the customer's self serve settings. This endpoint expects the customer-scoped token for authentication. */
    get: {
      responses: {
        /** OK */
        200: {
          content: {
            'application/json': components['schemas']['SelfServeSettings'];
          };
        };
        default: components['responses']['DEFAULT_ERROR'];
      };
    };
  };
  '/webhooks/': {
    /** Get all Webhooks for a given Vendor. */
    get: {
      responses: {
        /** OK */
        200: {
          content: {
            'application/json': components['schemas']['Webhook'][];
          };
        };
        default: components['responses']['DEFAULT_ERROR'];
      };
    };
    /** Add an endpoint to use with Octane's Webhook API. */
    post: {
      responses: {
        /** OK */
        200: {
          content: {
            'application/json': components['schemas']['Webhook'];
          };
        };
        422: components['responses']['UNPROCESSABLE_ENTITY'];
        default: components['responses']['DEFAULT_ERROR'];
      };
      requestBody: {
        content: {
          'application/json': components['schemas']['CreateWebhookArgs'];
        };
      };
    };
  };
  '/webhooks/{uuid}': {
    /** Retrieve a webhook given its UUID. */
    get: {
      parameters: {
        path: {
          uuid: string;
        };
      };
      responses: {
        /** OK */
        200: {
          content: {
            'application/json': components['schemas']['Webhook'];
          };
        };
        default: components['responses']['DEFAULT_ERROR'];
      };
    };
    /** Delete and unregister a webhook URL given its UUID. */
    delete: {
      parameters: {
        path: {
          uuid: string;
        };
      };
      responses: {
        /** No Content */
        204: never;
        default: components['responses']['DEFAULT_ERROR'];
      };
    };
    parameters: {
      path: {
        uuid: string;
      };
    };
  };
  '/credits/grant/': {
    /** Returns all the credit grants under your account. */
    get: {
      responses: {
        /** OK */
        200: {
          content: {
            'application/json': components['schemas']['ListCreditGrants'];
          };
        };
        422: components['responses']['UNPROCESSABLE_ENTITY'];
        default: components['responses']['DEFAULT_ERROR'];
      };
      requestBody: {
        content: {
          'application/json': components['schemas']['ListCreditGrantsArgs'];
        };
      };
    };
    /** Creates a credit grant for one of your customers. */
    post: {
      responses: {
        /** OK */
        200: {
          content: {
            'application/json': components['schemas']['CreditGrant'];
          };
        };
        422: components['responses']['UNPROCESSABLE_ENTITY'];
        default: components['responses']['DEFAULT_ERROR'];
      };
      requestBody: {
        content: {
          'application/json': components['schemas']['CreateCreditGrantArgs'];
        };
      };
    };
  };
  '/credits/grant/{grant_uuid}/void': {
    /** Deactivates a credit grant with the given grant UUID. */
    post: {
      parameters: {
        path: {
          grant_uuid: string;
        };
      };
      responses: {
        /** OK */
        200: unknown;
        default: components['responses']['DEFAULT_ERROR'];
      };
    };
    parameters: {
      path: {
        grant_uuid: string;
      };
    };
  };
  '/credits/ledger/{customer_name}/{as_of_str}': {
    /** Returns the credit ledger for one of your customers. */
    get: {
      parameters: {
        path: {
          customer_name: string;
          as_of_str: string;
        };
      };
      responses: {
        /** OK */
        200: {
          content: {
            'application/json': components['schemas']['CreditLedger'][];
          };
        };
        default: components['responses']['DEFAULT_ERROR'];
      };
    };
    parameters: {
      path: {
        customer_name: string;
        as_of_str: string;
      };
    };
  };
  '/credits/ledger/{customer_name}/': {
    /** Returns the credit ledger for one of your customers. */
    get: {
      parameters: {
        path: {
          customer_name: string;
        };
      };
      responses: {
        /** OK */
        200: {
          content: {
            'application/json': components['schemas']['CreditLedger'][];
          };
        };
        default: components['responses']['DEFAULT_ERROR'];
      };
    };
    parameters: {
      path: {
        customer_name: string;
      };
    };
  };
  '/invoices/{invoice_uuid}/retries': {
    /**
     * Moves the invoice into the next logical action. For example, an invoice that is generated gets moved to issued, and
     * an invoice that is in payment error tries payment again. For more information see our docs https://docs.getoctane.io/docs/manual-invoicing-triggers.
     */
    post: {
      parameters: {
        path: {
          invoice_uuid: string;
        };
      };
      responses: {
        /** Accepted */
        202: {
          content: {
            'application/json': components['schemas']['Retry'];
          };
        };
        422: components['responses']['UNPROCESSABLE_ENTITY'];
        default: components['responses']['DEFAULT_ERROR'];
      };
      requestBody: {
        content: {
          'application/json': components['schemas']['CreateRetryArgs'];
        };
      };
    };
    parameters: {
      path: {
        invoice_uuid: string;
      };
    };
  };
  '/admin/api_key/roll': {
    post: {
      responses: {
        /** OK */
        200: {
          content: {
            'application/json': components['schemas']['RollApiKeys'];
          };
        };
        422: components['responses']['UNPROCESSABLE_ENTITY'];
        default: components['responses']['DEFAULT_ERROR'];
      };
      requestBody: {
        content: {
          'application/json': components['schemas']['RollApiKeyArgs'];
        };
      };
    };
  };
  '/self_serve_settings/': {
    /** Get self serve settings for a vendor. */
    get: {
      responses: {
        /** OK */
        200: {
          content: {
            'application/json': components['schemas']['SelfServeSettings'];
          };
        };
        default: components['responses']['DEFAULT_ERROR'];
      };
    };
    /**
     * Update the self serve settings for a vendor. If partial fields
     * are given, we will only update the provided fields.
     */
    put: {
      responses: {
        /** OK */
        200: {
          content: {
            'application/json': components['schemas']['SelfServeSettings'];
          };
        };
        422: components['responses']['UNPROCESSABLE_ENTITY'];
        default: components['responses']['DEFAULT_ERROR'];
      };
      requestBody: {
        content: {
          'application/json': components['schemas']['UpdateSelfServeSettingsArgs'];
        };
      };
    };
    /**
     * Create the self serve settings for a vendor. If partial fields
     * are given, we will fallback on default values.
     */
    post: {
      responses: {
        /** OK */
        200: {
          content: {
            'application/json': components['schemas']['SelfServeSettings'];
          };
        };
        422: components['responses']['UNPROCESSABLE_ENTITY'];
        default: components['responses']['DEFAULT_ERROR'];
      };
      requestBody: {
        content: {
          'application/json': components['schemas']['UpdateSelfServeSettingsArgs'];
        };
      };
    };
  };
}

export interface components {
  schemas: {
    Meter: {
      /** Unique name identifier */
      name: string;
      /** Name used for display in UI */
      display_name?: string;
      description?: string | null;
      /** Whether measurement values are to be considered incremental (versus a running total) */
      is_incremental: boolean;
      meter_type?: unknown;
      /** The expected unit for the measurement values associated with this meter. */
      unit_name?: unknown;
      expected_labels?: unknown[];
      primary_labels?: unknown[];
    };
    MeterInputArgs: {
      unit_name?: string;
      display_name?: string;
      name?: string;
      meter_type?: 'COUNTER' | 'GAUGE';
      vendor_id?: number;
      is_incremental?: boolean;
      primary_labels?: string[];
      description?: string;
      expected_labels?: string[];
    };
    Error: {
      /** Errors */
      errors?: { [key: string]: unknown };
      /** Error name */
      status?: string;
      /** Error message */
      message?: string;
      /** Error code */
      code?: number;
    };
    UpdateMeterArgs: {
      display_name?: string;
      description?: string;
    };
    Measurement: {
      /** The name of the customer to associate the measurement with. */
      customer_name?: string;
      /** All times are parsed as `ISO-8601` formatted, UTC-based timestamps */
      time?: string;
      /** A set of key:value label pairs to supplement a measurement. Each meter defines its own set of primary and/or expected labels. */
      labels?: { [key: string]: string };
      /** Applies to incremental meters and resets the total current value to this new value. */
      reset_total?: boolean;
      /** The raw value of the measurement */
      value: number;
      /** The unique name of the meter associated with this measurement */
      meter_name: string;
    };
    ContactInfo: {
      address_line_1?: string | null;
      address_line_2?: string | null;
      city?: string | null;
      state?: string | null;
      country?: string | null;
      zipcode?: string | null;
      url?: string | null;
      logo_url?: string | null;
      email?: string | null;
      secondary_emails?: string | null;
      phone?: string | null;
      legal_name?: string | null;
      vat_id?: string | null;
    };
    CustomerTag: {
      /** Supplementary tag that is associated with a customer */
      tag: string;
    };
    Customer: {
      /** Unique name identifier of a customer */
      name: string;
      display_name?: string;
      contact_info?: components['schemas']['ContactInfo'] | null;
      created_at?: string;
      measurement_mappings?: unknown[];
      tags?: components['schemas']['CustomerTag'][];
    };
    CustomerMeasurementMappingInputArgs: {
      /** The label key used to map measurements to customers. */
      label: string;
      /** A regex used to match the value of the associated label key. */
      value_regex: string;
    };
    ContactInfoInputArgs: {
      address_line_2?: string | null;
      address_line_1?: string | null;
      url?: string | null;
      legal_name?: string | null;
      /** List of secondary contact emails (all email communication will also be sent to these emails). */
      secondary_emails?: string[] | null;
      city?: string | null;
      country?: string | null;
      phone?: string | null;
      email?: string | null;
      logo_url?: string | null;
      vat_id?: string | null;
      zipcode?: string | null;
      state?: string | null;
    };
    CreateCustomerArgs: {
      price_plan_name?: string;
      measurement_mappings?: components['schemas']['CustomerMeasurementMappingInputArgs'][];
      display_name?: string;
      name?: string;
      autogenerate_payment_gateway_customer?: boolean;
      vendor_id?: number;
      created_at?: string;
      contact_info?: components['schemas']['ContactInfoInputArgs'];
      autogenerate_accounting_customer?: boolean;
      price_plan_tag?: string;
      tags?: string[] | null;
    };
    UpdateCustomerArgs: {
      measurement_mappings?: components['schemas']['CustomerMeasurementMappingInputArgs'][];
      display_name?: string;
      name?: string;
      vendor_id?: number;
      created_at?: string;
      contact_info?: components['schemas']['ContactInfoInputArgs'];
      tags?: string[] | null;
    };
    CustomerMeasurementMapping: {
      /** The label key used to map measurements to customers. */
      label: string;
      /** A regex used to match the value of the associated label key. */
      value_regex?: string | null;
    };
    CustomerPaymentMethodStatus: {
      /** The status of the customer's current payment method. Can be one of: NO_PAYMENT_GATEWAY_CREDENTIAL, NO_PAYMENT_METHOD, EXPIRED_PAYMENT_METHOD, VALID_PAYMENT_METHOD */
      status?: string;
    };
    PaymentGatewayCredential: {
      payment_gateway?: unknown;
      /** Payment gateway account id associated with customer */
      account_id: string;
      /** Unique name identifier of a customer */
      auth_token?: string | null;
    };
    CustomerPaymentGatewayCredentialInputArgs: {
      account_id?: string;
    };
    BillingSettings: {
      /** Time length of the grace period between the end of a billing cycle and invoice generation in days. */
      invoice_grace_period_length?: number | null;
      /** Time length unit of the grace period between the end of a billing cycle and invoice generation. Must be `day`. */
      invoice_grace_period_unit?: string | null;
      /** Time length of the grace period between the end of invoice generation and the actual charge. *NOTE*: The specified length is unitless. Unit is designated with the `payment_grace_period_unit` field. */
      payment_grace_period_length?: number | null;
      /** Time length unit of the grace period between the end of invoice generation and actual charge. One of `minute`, `hour`, `day`. */
      payment_grace_period_unit?: string | null;
      /** Flag that controls whether or not invoices should be sent to customers. */
      should_send_invoice_to_customers?: boolean | null;
      /** Flag that controls whether to invoice through Octane or through payment provider */
      invoice_via_octane?: boolean | null;
      /** Flag that controls whether invoices are auto-approved or require manual approval */
      auto_approve_invoices?: boolean | null;
      customer_invoice_detail_level?: unknown;
      /** Flag that controls whether or not to auto-charge the customer based on the invoice. */
      charges_enabled?: boolean | null;
      /** Flag that controls whether or not to invoice/charge the base rate, add ons and other fixed price plan components at the beginning of the billing cycle. */
      invoice_fixed_components_at_start?: boolean | null;
      /** Flag that controls the number of retry attempts for invoicing/payments. */
      retry_attempts?: number | null;
      /** Time length after which to attempt invoice/payment retry. */
      retry_frequency_length?: number | null;
      /** Time length unit after which to attempt invoice/payment retry. */
      retry_frequency_unit?: string | null;
      /** The percentage tax rate to apply to invoices. */
      tax_rate?: number | null;
      /** Flag that controls whether to do automated taxes via payment provider */
      tax_via_payment_provider?: boolean | null;
      /** Flag that controls whether or not to invoice/charge gauge meters upfront according to their value at start of cycle. Only applies if invoice_fixed_components_at_start is enabled. */
      invoice_metered_components_at_start?: boolean | null;
      /** Flag that controls whether or not to invoice/charge a true up for a billing cycle on the following invoice. Only applies if invoice_fixed_components_at_start is enabled. */
      invoice_overages?: boolean | null;
      /** Optional description attached to the invoice */
      invoice_memo?: string | null;
      /** Sets the due date on invoices to the number of days after the invoice is sent */
      days_until_due?: number | null;
      /** If using stripe, this field can be used to configure whether invoices should be auto advanced for collection */
      stripe_auto_advance?: boolean | null;
      /** Default value for whether to align billing cycles to calendar on subscriptions */
      align_billing_cycles_to_calendar?: boolean | null;
      /** Optional url of a custom image to include on invoices. */
      invoice_logo_url?: string | null;
      /** Flag determining whether ACH/Wire instructions should be included on invoices. */
      include_ach_instructions?: boolean | null;
      /** Account name for ACH/Wire transfer instructions */
      ach_account_name?: string | null;
      /** ABA/Routing number for ACH/Wire transfer instructions */
      ach_routing_number?: string | null;
      /** Account number for ACH/Wire transfer instructions */
      ach_account_number?: string | null;
      /** Swift code for ACH/Wire transfer instructions */
      ach_swift_code?: string | null;
      /** Bank name for ACH/Wire transfer instructions */
      ach_bank_name?: string | null;
      /** First line of bank address for ACH/Wire transfer instructions */
      ach_bank_address_1?: string | null;
      /** Second line of bank address for ACH/Wire transfer instructions */
      ach_bank_address_2?: string | null;
      /** True if customer updates should be synced to Stripe. */
      sync_customer_data_to_payment_gateway?: boolean | null;
      /** If using Stripe, this field can be used to configure whether invoices should be finalized immediately when they are created. */
      stripe_immediate_finalization?: boolean | null;
    };
    CustomerBillingSettingsInputArgs: {
      /** Sets the due date on invoices to the number of days after the invoice is sent */
      days_until_due?: number | null;
      /** Time length unit of the grace period between the end of a billing cycle and invoice generation. Must be `day`. */
      invoice_grace_period_unit?: 'day' | null;
      /** Flag that controls whether or not to invoice/charge the base rate, add ons and other fixed price plan components at the beginning of the billing cycle. */
      invoice_fixed_components_at_start?: boolean | null;
      /** First line of bank address for ACH/Wire transfer instructions */
      ach_bank_address_1?: string | null;
      /** Flag determining whether ACH/Wire instructions should be included on invoices. */
      include_ach_instructions?: boolean | null;
      customer_invoice_detail_level?: string;
      /** If using stripe, this field can be used to configure whether invoices should be auto advanced for collection */
      stripe_auto_advance?: boolean | null;
      /** If using Stripe, this field can be used to configure whether invoices should be finalized immediately when they are created. */
      stripe_immediate_finalization?: boolean | null;
      /** True if customer updates should be synced to Stripe. */
      sync_customer_data_to_payment_gateway?: boolean | null;
      /** Time length of the grace period between the end of invoice generation and the actual charge. *NOTE*: The specified length is unitless. Unit is designated with the `payment_grace_period_unit` field. */
      payment_grace_period_length?: number | null;
      /** Account name for ACH/Wire transfer instructions */
      ach_account_name?: string | null;
      /** Bank name for ACH/Wire transfer instructions */
      ach_bank_name?: string | null;
      /** Default value for whether to align billing cycles to calendar on subscriptions */
      align_billing_cycles_to_calendar?: boolean | null;
      /** Flag that controls whether to invoice through Octane or through payment provider */
      invoice_via_octane?: boolean | null;
      /** The percentage tax rate to apply to invoices. */
      tax_rate?: number | null;
      /** Flag that controls whether or not to invoice/charge gauge meters upfront according to their value at start of cycle. Only applies if invoice_fixed_components_at_start is enabled. */
      invoice_metered_components_at_start?: boolean | null;
      /** Optional description attached to the invoice */
      invoice_memo?: string | null;
      /** Time length of the grace period between the end of a billing cycle and invoice generation in days. */
      invoice_grace_period_length?: number | null;
      /** Swift code for ACH/Wire transfer instructions */
      ach_swift_code?: string | null;
      /** Time length after which to attempt invoice/payment retry. */
      retry_frequency_length?: number | null;
      /** Flag that controls whether or not to auto-charge the customer based on the invoice. */
      charges_enabled?: boolean | null;
      /** Flag that controls the number of retry attempts for invoicing/payments. */
      retry_attempts?: number | null;
      /** Flag that controls whether or not invoices should be sent to customers. */
      should_send_invoice_to_customers?: boolean | null;
      /** ABA/Routing number for ACH/Wire transfer instructions */
      ach_routing_number?: string | null;
      /** Flag that controls whether or not to invoice/charge a true up for a billing cycle on the following invoice. Only applies if invoice_fixed_components_at_start is enabled. */
      invoice_overages?: boolean | null;
      /** Optional url of a custom image to include on invoices. */
      invoice_logo_url?: string | null;
      /** Flag that controls whether to do automated taxes via payment provider */
      tax_via_payment_provider?: boolean | null;
      /** Time length unit of the grace period between the end of invoice generation and actual charge. One of `minute`, `hour`, `day`. */
      payment_grace_period_unit?: string | null;
      /** Second line of bank address for ACH/Wire transfer instructions */
      ach_bank_address_2?: string | null;
      /** Flag that controls whether invoices are auto-approved or require manual approval */
      auto_approve_invoices?: boolean | null;
      /** Account number for ACH/Wire transfer instructions */
      ach_account_number?: string | null;
      /** Time length unit after which to attempt invoice/payment retry. */
      retry_frequency_unit?: string | null;
    };
    RevenueResponse: {
      revenue?: number;
    };
    CustomerStatus: {
      status?: string;
    };
    CustomerUsage: {
      usage?: number;
    };
    CustomerLabelLimit: {
      limit?: number;
      labels?: { [key: string]: string };
    };
    CustomerFeature: {
      feature_name?: string;
      limit?: number;
      quantity?: number;
      label_limits?: components['schemas']['CustomerLabelLimit'][];
      enabled?: boolean;
    };
    LineItems: {
      name?: string;
      quantity_unit?: string;
      start_time?: string;
      price?: string;
      id?: string;
      price_int?: number;
      end_time?: string;
      quantity?: number;
      description?: string;
      metadata?: { [key: string]: string };
    };
    RevenueBreakdown: {
      total_revenue?: number;
      line_items?: components['schemas']['LineItems'][];
    };
    AccountingCustomer: {
      /** ID of the customer in the target accounting platform */
      accounting_customer_id?: string;
    };
    CustomerMetadata: {
      property?: string;
      value?: string | null;
    };
    Invoice: {
      /** [DEPRECATED] Start time of the cycle in which the invoice was generated */
      start_time?: string;
      id?: string;
      /** False if not paid yet */
      is_paid?: boolean;
      /** Non-empty string if there was an error while sending out invoice */
      invoicing_error?: string;
      /** False if not approved */
      is_approved?: boolean;
      line_items?: components['schemas']['LineItems'][];
      /** The date the invoice will be issued to the end customer or forwarded to the payment processor. */
      issue_date?: string;
      /** Tax amount applied to subtotal */
      tax_amount?: number;
      /** Earliest start time of line items covered by the invoice */
      min_item_start_time?: string;
      /** Non-empty string if there was an error while processing payment */
      payment_error?: string;
      /** The number of retries done to send the invoice */
      invoice_retry_attempt?: number;
      latest_invoice_attempt_at?: string;
      /** Total amount due */
      amount_due?: number;
      latest_payment_attempt_at?: string;
      /** [DEPRECATED] End time of the cycle in which the invoice was generated */
      end_time?: string;
      pdf_url?: string;
      /** The number of retries done to process the payment */
      payment_retry_attempt?: number;
      status?: string;
      due_date?: string;
      /** False if invoice has not been sent to the customer */
      is_invoiced?: boolean;
      /** Latest end time of line items covered by the invoice */
      max_item_end_time?: string;
      /** Amount due before any credits are applied */
      sub_total?: number;
      /** Any discount credits applied to the invoice */
      discount_credit?: number;
    };
    PriceTier: {
      /** The line item description to use if usage falls in this tier. */
      description?: string;
      /** Cap of the tier, meaning that any subsequent usage will be bucketed into the following tier. If cap is undefined, it is effectively treated as Infinity. */
      cap?: number;
      /** The price (in lowest currency denomination by which to charge, given that the usage is within the cap range. */
      price: number;
    };
    PriceScheme: {
      display_name?: string | null;
      name?: string | null;
      scheme_type?: unknown;
      /** Size of the unit batch to use for the prices. Can only be set if scheme_type='FLAT' or 'TIERED'. E.g. To charge $10 per 100 API Requests, set batch_size to 100. */
      batch_size?: number | null;
      /** Array of price tiers, each of which consists of `price` and `cap` key:value pairs */
      prices?: components['schemas']['PriceTier'][];
      /** Array of (key, value) meter labels to price on & the price tiers that should be used against those labels */
      price_list?: { [key: string]: unknown }[];
      time_unit_name?: string | null;
      unit_name?: string | null;
    };
    MeteredComponentLabelLimit: {
      /** Dictionary of labels (key: value) to which the limit applies. A value of 'any' will apply the limit to any single value of the field. */
      labels: unknown;
      /** Numeric limit set on the labels. */
      limit: number;
    };
    MeteredComponent: {
      meter_name: string;
      meter_display_name: string;
      price_scheme: components['schemas']['PriceScheme'];
      /** Limit on the usage for the meter. */
      limit?: number | null;
      label_limits: components['schemas']['MeteredComponentLabelLimit'][];
      /** Name to be used on invoice. */
      display_name?: string | null;
      /** External facing unique identifier of a metered component */
      external_uuid?: string;
    };
    Feature: {
      description?: string | null;
      /** Unique name of a feature */
      name: string;
      display_name?: string;
    };
    AddOn: {
      feature: components['schemas']['Feature'];
      /** Price of the add on */
      price: number;
      /** If true, customer is just charged once in the first billing cycle. */
      single_use: boolean;
      quantity_enabled: boolean;
      /** If true, immediately invoice the customer for this add on. */
      immediately_charge?: boolean;
    };
    Limit: {
      feature: components['schemas']['Feature'];
      /** Limit on feature */
      limit: number;
    };
    PricePlanTag: {
      /** Supplementary tag label that is associated with a specific version of a price plan */
      tag: string;
    };
    Trial: {
      time_length?: number | null;
      time_unit_name?: string | null;
      credit?: number | null;
    };
    PricePlan: {
      /** External facing unique identifier of a price plan */
      external_uuid?: string;
      /** Unique name indentifier of a price plan */
      name: string;
      /** UI-friendly name used for data display. Defaults to `name`. */
      display_name?: string;
      description?: string | null;
      /** Lowest denomination of currency. e.g. USD is represented as cents. */
      base_price?: number | null;
      base_price_frequency?: number | null;
      /** Custom invoice description for the base price line item. */
      base_price_description?: string | null;
      /** Time period that defines the length of a price plan cycle. One of `day`, `week`, `month`, `quarter`, or `year`. */
      period: string;
      metered_components: components['schemas']['MeteredComponent'][];
      /** Minimum amount to charge every 'period' */
      minimum_charge?: number | null;
      features?: components['schemas']['Feature'][];
      add_ons?: components['schemas']['AddOn'][];
      limits?: components['schemas']['Limit'][];
      tags?: components['schemas']['PricePlanTag'][];
      trial?: components['schemas']['Trial'];
      /** ISO-8601 formatted creation timestamp of price plan version */
      created_at?: string;
    };
    Discount: {
      discount_type?: unknown;
      amount?: number | null;
      /** The date when the discount is applied from. */
      start_date?: string | null;
      /** The date when the discount ends. */
      end_date?: string | null;
      /** The id of coupon associated with this discount, none if discount does not originate from coupon */
      coupon_id?: number | null;
      /** External facing unique identifier of a price plan */
      external_uuid?: string;
      /** The scope that this discount covers. One of 'INVOICE_TOTAL', 'ADD_ON', 'METERED_COMPONENT'. */
      scope: string;
      /** Add-on this discount covers if scope is ADD_ON. */
      add_on?: components['schemas']['AddOn'];
      /** Metered Component this discount covers if scope is METERED_COMPONENT. */
      metered_component?: components['schemas']['MeteredComponent'];
      /** Dictionary of labels (key: value) to which the discount applies if scope is METERED_COMPONENT. */
      labels?: { [key: string]: string };
    };
    Subscription: {
      /** Unique name identifier of a customer */
      customer_name: unknown;
      /** Unique name indentifier of a price plan */
      price_plan_name: unknown;
      /** Price plan associated with this subscription. */
      price_plan?: components['schemas']['PricePlan'];
      /** Align billing cycles to a calendar unit if true. For example if the period is month, cycles will end on the first of every month. */
      align_to_calendar?: boolean;
      /** Optional discount override for the associated subscription. */
      discount_override?: components['schemas']['Discount'];
      add_ons?: unknown;
      /** Optional trial override for the associated subscription. */
      trial_override?: components['schemas']['Trial'];
      /** Optional base price override for the associated subscription. */
      base_price_override?: number | null;
      features_override?: components['schemas']['Feature'][];
      limits_override?: components['schemas']['Limit'][];
      /** ISO-8601 formatted timestamp that defines when the subscription should take effect. If this field is omitted, the subscription is effective upon creation. */
      effective_at?: string;
      /** ISO-8601 formatted timestamp that defines when the subscription will expire. */
      expired_at?: string | null;
    };
    TrialInputArgs: {
      credit?: number;
      time_length?: number;
      time_unit_name?: string;
    };
    FeatureInputArgs: {
      display_name?: string;
      name?: string;
      description?: string;
    };
    LimitInputArgs: {
      limit?: number;
      feature?: components['schemas']['FeatureInputArgs'];
    };
    SubscriptionAddOnInput: {
      quantity?: number;
      name: string;
      /** Override for the add-on price on this subscription. */
      price?: number;
    };
    DiscountInputArgs: {
      /** The scope that this discount covers. One of 'INVOICE_TOTAL', 'ADD_ON', 'METERED_COMPONENT'. */
      scope?: string;
      /** For ADD_ON scoped discounts: the name of the add on that the discount covers. */
      add_on_name?: string;
      /** For METERED_COMPONENT scoped discounts: the UUID of the meter component that the discount covers. */
      metered_component_uuid?: string;
      discount_type?: 'FLAT' | 'PERCENT';
      /** For METERED_COMPONENT scoped discounts: Dictionary of labels (key: value) that the discount covers. The entire set of labels must be provided. */
      labels?: { [key: string]: string };
      amount?: number;
    };
    CreateSubscriptionArgs: {
      price_plan_name?: string;
      trial_override?: components['schemas']['TrialInputArgs'];
      coupon_override_name?: string;
      vendor_id?: number;
      effective_at?: string;
      features_override?: components['schemas']['FeatureInputArgs'][];
      coupon_override_id?: number;
      limits_override?: components['schemas']['LimitInputArgs'][];
      add_ons?: components['schemas']['SubscriptionAddOnInput'][];
      price_plan_id?: number;
      discount_override?: components['schemas']['DiscountInputArgs'];
      price_plan_tag?: string;
      align_to_calendar?: boolean;
      customer_id?: number;
    };
    UpdateSubscriptionArgs: {
      price_plan_name?: string;
      trial_override?: components['schemas']['TrialInputArgs'] | null;
      coupon_override_name?: string;
      vendor_id?: number;
      /** Boolean that indicates whether to update the subscription at the start of the billing cycle. If 'true' and either of `effective_at` or `at_cycle_end` are set, will return an error. */
      at_cycle_start?: boolean;
      effective_at?: string;
      features_override?: components['schemas']['FeatureInputArgs'][] | null;
      coupon_override_id?: number;
      limits_override?: components['schemas']['LimitInputArgs'][] | null;
      add_ons?: components['schemas']['SubscriptionAddOnInput'][] | null;
      price_plan_id?: number;
      discount_override?: components['schemas']['DiscountInputArgs'] | null;
      /** Boolean that indicates whether to update the subscription at the end of the billing cycle. If 'true' and either of `effective_at` or `at_cycle_start` are set, will return an error. */
      at_cycle_end?: boolean;
      price_plan_tag?: string;
      align_to_calendar?: boolean;
      customer_id?: number;
    };
    DeleteSubscriptionArgs: {
      customer_id?: number;
      /** Boolean that indicates whether to expire the subscription at the end of thebilling cycle. If 'true' and `expire_at` is set, will return an error. */
      at_cycle_end?: boolean;
      expire_at?: string;
      vendor_id?: number;
    };
    UpdateSubscriptionInPlaceArgs: {
      add_ons?: components['schemas']['SubscriptionAddOnInput'][] | null;
      discount_override?: components['schemas']['DiscountInputArgs'] | null;
      coupon_override_name?: string;
    };
    BillingCycleDate: {
      cycle_end: string;
      cycle_start: string;
    };
    ActiveSubscription: {
      /** Unique name identifier of a customer */
      customer_name: unknown;
      /** Unique name indentifier of a price plan */
      price_plan_name: unknown;
      /** Price plan associated with this subscription. */
      price_plan?: components['schemas']['PricePlan'];
      /** Optional discount override for the associated subscription. */
      discount_override?: components['schemas']['Discount'];
      add_ons?: unknown;
      /** Optional trial override for the associated subscription. */
      trial_override?: components['schemas']['Trial'];
      features_override?: components['schemas']['Feature'][];
      limits_override?: components['schemas']['Limit'][];
      /** ISO-8601 formatted timestamp that defines when the subscription should take effect. If this field is omitted, the subscription is effective upon creation. */
      effective_at?: string;
      /** ISO-8601 formatted timestamp that defines when the subscription will expire. */
      expired_at?: string | null;
      /** Align billing cycles to a calendar unit if true. For example if the period is month, cycles will end on the first of every month. */
      align_to_calendar?: boolean;
      /** Optional base price override for the associated subscription. */
      base_price_override?: number | null;
      current_billing_cycle?: components['schemas']['BillingCycleDate'];
      total_fixed_price?: number;
      discounted_fixed_price?: number;
    };
    SubscriptionAddOnItem: {
      feature_name?: string;
      effective_at?: string;
      /** Quantity represents how many of this add on you want to attach to the subscription. Can be positive forincreasing the number of this add on or negative for decreasing. */
      quantity?: number;
      /** Boolean that indicates whether to update the subscription add on at the end of the billing cycle. If 'true' and either of `effective_at` or `at_cycle_start` are set, will return an error. */
      at_cycle_end?: boolean;
      /** Boolean that indicates whether to update the subscription add on at the start of the billing cycle. If 'true' and either of `effective_at` or `at_cycle_end` are set, will return an error. */
      at_cycle_start?: boolean;
    };
    PastInvoice: {
      due_date?: string;
      customer_name?: string;
      issue_date?: string;
      status?: string;
      export_url?: string;
      status_description?: string;
      amount_due?: number;
    };
    PastInvoices: {
      sort_direction?: string;
      invoices?: components['schemas']['PastInvoice'][];
      /** The unique offset to start at when paging forwards */
      forward_secondary_sort_offset?: string;
      /** The number of items to fetch. Defaults to 10. */
      limit?: number;
      sort_column?: string;
      /** The sort column offset to start at when paging forwards */
      forward_sort_offset?: string;
    };
    UpcomingInvoice: {
      customer_name?: string;
      export_url?: string;
      generate_date?: string;
    };
    UpcomingInvoices: {
      sort_direction?: string;
      invoices?: components['schemas']['UpcomingInvoice'][];
      /** The unique offset to start at when paging forwards */
      forward_secondary_sort_offset?: string;
      /** The number of items to fetch. Defaults to 10. */
      limit?: number;
      sort_column?: string;
      /** The sort column offset to start at when paging forwards */
      forward_sort_offset?: string;
    };
    PriceInputArgs: {
      description?: string;
      cap?: number;
      price?: number;
    };
    PriceSchemeInputArgs: {
      /** The name of the unit used for this metered component (e.g., gigabyte) */
      unit_name?: string;
      /** Array of (key, value) meter labels to price on & the price tiers that should be used against those labels */
      price_list?: { [key: string]: unknown }[];
      /** Array of price tiers, each of which consists of `price` and `cap` key:value pairs */
      prices?: components['schemas']['PriceInputArgs'][];
      /** One of 'FLAT', 'TIERED', or 'STAIRSTEP' */
      scheme_type: string;
      /** The time unit for the metered component (e.g., month or hour) */
      time_unit_name?: string;
      /** Size of the unit batch to use for the prices. Can only be set if scheme_type='FLAT' or 'TIERED'. E.g. To charge $10 per 100 API Requests, set batch_size to 100. */
      batch_size?: number;
    };
    MeteredComponentLabelLimitInputArgs: {
      /** Numeric limit to set on customer usage for the meter with the given labels. */
      limit: number;
      /** Dictionary of labels (key: value) to which the limit applies. A value of 'any' will apply the limit to any single value of the field. */
      labels: { [key: string]: string };
    };
    MeteredComponentInputArgs: {
      /** Name to be used on invoice. */
      display_name?: string;
      meter_id?: number;
      id?: number;
      price_scheme?: components['schemas']['PriceSchemeInputArgs'];
      /** Numeric limit to set on customer usage for the meter. */
      limit?: number;
      label_limits?: components['schemas']['MeteredComponentLabelLimitInputArgs'][];
      /** Codename of the meter. */
      meter_name?: string;
    };
    AddOnInputArgs: {
      price?: number;
      feature?: components['schemas']['FeatureInputArgs'];
      limit?: number;
      quantity_enabled?: boolean;
      /** Whether this add on can only be used & charged once. */
      single_use?: boolean;
      /** This field indicates whether or not we should cut an invoice immediately upon attaching this add on to a price plan. */
      immediately_charge?: boolean;
    };
    CreatePricePlanArgs: {
      display_name?: string;
      name?: string;
      /** The frequency (as a an integer multiple of the period) at which to charge the base price. */
      base_price_frequency?: number;
      metered_components?: components['schemas']['MeteredComponentInputArgs'][];
      vendor_id?: number;
      /** Minimum amount (in cents) to charge every price plan period. */
      minimum_charge?: number | null;
      period?: string;
      limits?: components['schemas']['LimitInputArgs'][];
      /** Custom invoice description for the base price line item. */
      base_price_description?: string | null;
      add_ons?: components['schemas']['AddOnInputArgs'][];
      description?: string;
      features?: components['schemas']['FeatureInputArgs'][];
      trial?: components['schemas']['TrialInputArgs'];
      base_price?: number;
      tags?: string[];
    };
    ListPricePlans: {
      sort_direction?: string;
      /** The unique offset to start at when paging forwards */
      forward_secondary_sort_offset?: string;
      /** The number of items to fetch. Defaults to 10. */
      limit?: number;
      price_plans?: components['schemas']['PricePlan'][];
      sort_column?: string;
      /** The sort column offset to start at when paging forwards */
      forward_sort_offset?: string;
    };
    UpdatePricePlanArgs: {
      display_name?: string;
      name?: string;
      /** The frequency (as a an integer multiple of the period) at which to charge the base price. */
      base_price_frequency?: number;
      metered_components?: components['schemas']['MeteredComponentInputArgs'][];
      vendor_id?: number;
      /** Minimum amount (in cents) to charge every price plan period. */
      minimum_charge?: number | null;
      period?: string;
      limits?: components['schemas']['LimitInputArgs'][];
      /** Custom invoice description for the base price line item. */
      base_price_description?: string | null;
      add_ons?: components['schemas']['AddOnInputArgs'][];
      description?: string;
      features?: components['schemas']['FeatureInputArgs'][];
      trial?: components['schemas']['TrialInputArgs'];
      base_price?: number;
      tags?: string[];
    };
    UpdatePricePlanInPlaceArgs: {
      display_name?: string;
      metered_components?: components['schemas']['MeteredComponentInputArgs'][];
      limits?: components['schemas']['LimitInputArgs'][];
      add_ons?: components['schemas']['AddOnInputArgs'][];
      /** Custom invoice description for the base price line item. */
      base_price_description?: string | null;
      description?: string;
      features?: components['schemas']['FeatureInputArgs'][];
    };
    SelfServePricePlansInputArgs: {
      price_plan_uuids?: string[];
    };
    PaymentGatewayCredentialInputArgs: {
      account_id?: string;
      payment_gateway?: string;
      auth_token?: string;
    };
    CreateBillingSettingsInputArgs: {
      /** Sets the due date on invoices to the number of days after the invoice is sent */
      days_until_due?: number | null;
      /** Time length unit of the grace period between the end of a billing cycle and invoice generation. Must be `day`. */
      invoice_grace_period_unit?: 'day';
      /** Flag that controls whether or not to invoice/charge the base rate, add ons and other fixed price plan components at the beginning of the billing cycle. */
      invoice_fixed_components_at_start?: boolean;
      /** First line of bank address for ACH/Wire transfer instructions */
      ach_bank_address_1?: string | null;
      /** Flag determining whether ACH/Wire instructions should be included on invoices. */
      include_ach_instructions?: boolean | null;
      customer_invoice_detail_level?: string;
      /** If using stripe, this field can be used to configure whether invoices should be auto advanced for collection */
      stripe_auto_advance?: boolean;
      /** If using Stripe, this field can be used to configure whether invoices should be finalized immediately when they are created. */
      stripe_immediate_finalization?: boolean | null;
      /** True if customer updates should be synced to Stripe. */
      sync_customer_data_to_payment_gateway?: boolean | null;
      /** Time length of the grace period between the end of invoice generation and the actual charge. *NOTE*: The specified length is unitless. Unit is designated with the `payment_grace_period_unit` field. */
      payment_grace_period_length?: number;
      /** Account name for ACH/Wire transfer instructions */
      ach_account_name?: string | null;
      /** Bank name for ACH/Wire transfer instructions */
      ach_bank_name?: string | null;
      /** Default value for whether to align billing cycles to calendar on subscriptions */
      align_billing_cycles_to_calendar?: boolean;
      /** Flag that controls whether to invoice through Octane or through payment provider */
      invoice_via_octane?: boolean;
      /** The percentage tax rate to apply to invoices. */
      tax_rate?: number | null;
      /** Flag that controls whether or not to invoice/charge gauge meters upfront according to their value at start of cycle. Only applies if invoice_fixed_components_at_start is enabled. */
      invoice_metered_components_at_start?: boolean;
      /** Optional description attached to the invoice */
      invoice_memo?: string | null;
      /** Time length of the grace period between the end of a billing cycle and invoice generation in days. */
      invoice_grace_period_length?: number;
      /** Swift code for ACH/Wire transfer instructions */
      ach_swift_code?: string | null;
      /** Time length after which to attempt invoice/payment retry. */
      retry_frequency_length?: number;
      /** Flag that controls whether or not to auto-charge the customer based on the invoice. */
      charges_enabled?: boolean;
      /** Flag that controls the number of retry attempts for invoicing/payments. */
      retry_attempts?: number;
      /** Flag that controls whether or not invoices should be sent to customers. */
      should_send_invoice_to_customers?: boolean;
      /** ABA/Routing number for ACH/Wire transfer instructions */
      ach_routing_number?: string | null;
      /** Flag that controls whether or not to invoice/charge a true up for a billing cycle on the following invoice. Only applies if invoice_fixed_components_at_start is enabled. */
      invoice_overages?: boolean;
      /** Optional url of a custom image to include on invoices. */
      invoice_logo_url?: string | null;
      /** Flag that controls whether to do automated taxes via payment provider */
      tax_via_payment_provider?: boolean;
      /** Time length unit of the grace period between the end of invoice generation and actual charge. One of `minute`, `hour`, `day`. */
      payment_grace_period_unit?: string;
      /** Second line of bank address for ACH/Wire transfer instructions */
      ach_bank_address_2?: string | null;
      /** Flag that controls whether invoices are auto-approved or require manual approval */
      auto_approve_invoices?: boolean;
      /** Account number for ACH/Wire transfer instructions */
      ach_account_number?: string | null;
      /** Time length unit after which to attempt invoice/payment retry. */
      retry_frequency_unit?: string;
    };
    UpdateBillingSettingsInputArgs: {
      /** Sets the due date on invoices to the number of days after the invoice is sent */
      days_until_due?: number | null;
      /** Time length unit of the grace period between the end of a billing cycle and invoice generation. Must be `day`. */
      invoice_grace_period_unit?: 'day';
      /** Flag that controls whether or not to invoice/charge the base rate, add ons and other fixed price plan components at the beginning of the billing cycle. */
      invoice_fixed_components_at_start?: boolean;
      /** First line of bank address for ACH/Wire transfer instructions */
      ach_bank_address_1?: string | null;
      /** Flag determining whether ACH/Wire instructions should be included on invoices. */
      include_ach_instructions?: boolean | null;
      customer_invoice_detail_level?: string;
      /** If using stripe, this field can be used to configure whether invoices should be auto advanced for collection */
      stripe_auto_advance?: boolean;
      /** If using Stripe, this field can be used to configure whether invoices should be finalized immediately when they are created. */
      stripe_immediate_finalization?: boolean | null;
      /** True if customer updates should be synced to Stripe. */
      sync_customer_data_to_payment_gateway?: boolean | null;
      /** Time length of the grace period between the end of invoice generation and the actual charge. *NOTE*: The specified length is unitless. Unit is designated with the `payment_grace_period_unit` field. */
      payment_grace_period_length?: number;
      /** Account name for ACH/Wire transfer instructions */
      ach_account_name?: string | null;
      /** Bank name for ACH/Wire transfer instructions */
      ach_bank_name?: string | null;
      /** Default value for whether to align billing cycles to calendar on subscriptions */
      align_billing_cycles_to_calendar?: boolean;
      /** Flag that controls whether to invoice through Octane or through payment provider */
      invoice_via_octane?: boolean;
      /** The percentage tax rate to apply to invoices. */
      tax_rate?: number | null;
      /** Flag that controls whether or not to invoice/charge gauge meters upfront according to their value at start of cycle. Only applies if invoice_fixed_components_at_start is enabled. */
      invoice_metered_components_at_start?: boolean;
      /** Optional description attached to the invoice */
      invoice_memo?: string | null;
      /** Time length of the grace period between the end of a billing cycle and invoice generation in days. */
      invoice_grace_period_length?: number;
      /** Swift code for ACH/Wire transfer instructions */
      ach_swift_code?: string | null;
      /** Time length after which to attempt invoice/payment retry. */
      retry_frequency_length?: number;
      /** Flag that controls whether or not to auto-charge the customer based on the invoice. */
      charges_enabled?: boolean;
      /** Flag that controls the number of retry attempts for invoicing/payments. */
      retry_attempts?: number;
      /** Flag that controls whether or not invoices should be sent to customers. */
      should_send_invoice_to_customers?: boolean;
      /** ABA/Routing number for ACH/Wire transfer instructions */
      ach_routing_number?: string | null;
      /** Flag that controls whether or not to invoice/charge a true up for a billing cycle on the following invoice. Only applies if invoice_fixed_components_at_start is enabled. */
      invoice_overages?: boolean;
      /** Optional url of a custom image to include on invoices. */
      invoice_logo_url?: string | null;
      /** Flag that controls whether to do automated taxes via payment provider */
      tax_via_payment_provider?: boolean;
      /** Time length unit of the grace period between the end of invoice generation and actual charge. One of `minute`, `hour`, `day`. */
      payment_grace_period_unit?: string;
      /** Second line of bank address for ACH/Wire transfer instructions */
      ach_bank_address_2?: string | null;
      /** Flag that controls whether invoices are auto-approved or require manual approval */
      auto_approve_invoices?: boolean;
      /** Account number for ACH/Wire transfer instructions */
      ach_account_number?: string | null;
      /** Time length unit after which to attempt invoice/payment retry. */
      retry_frequency_unit?: string;
    };
    Customer1: {
      /** Unique name identifier of a customer */
      name: string;
    };
    PricePlan1: {
      /** Unique name indentifier of a price plan */
      name: string;
    };
    Coupon: {
      /** Unique name identifier. */
      name: string;
      /** UI-friendly name used for data display. Defaults to `name`. */
      display_name?: string;
      /** The time when the coupon will stop being effective one its applied. */
      duration_length?: number | null;
      /** The unit time unit to apply to the specified duration length. */
      duration_unit?: string | null;
      /** ISO-8601 formatted timestamp that defines after what timestamp this coupon cannot be applied. */
      expiration_time?: string | null;
      frequency?: unknown;
      /** The maximum number of times this coupon can be used. */
      max_uses?: number | null;
      /** Customer facing code that can be used to apply coupon. */
      code?: string | null;
      discount_type?: unknown;
      /** The amount of discount to give based on discount_type */
      discount_amount: number;
      excluded_customers?: components['schemas']['Customer1'][];
      excluded_price_plans?: components['schemas']['PricePlan1'][];
    };
    CouponInputArgs: {
      vendor_id?: number;
      name: string;
      display_name?: string;
      expiration_time?: string;
      frequency: 'ONCE' | 'RECURRING';
      duration_length?: number;
      duration_unit?: string;
      max_uses?: number;
      code?: string;
      excluded_customers?: string[];
      excluded_price_plans?: string[];
      discount_type: 'FLAT' | 'PERCENT';
      discount_amount: number;
    };
    ApplyCouponInputArgs: {
      customer_name?: string;
      name?: string;
      vendor_id?: number;
      code?: string;
      customer_id?: number;
    };
    CreateRefundArgs: {
      /** Amount to be refunded */
      amount?: number;
      /** Invoice that the refund should be against */
      invoice_id?: number;
      /** Invoice that the refund should be against */
      invoice_uuid?: string;
    };
    Refund: {
      success?: boolean;
    };
    CustomerPortalSettings: {
      /** Comma-separated list of names to filter visible price plans by. */
      price_plan_names_filter?: string | null;
      /** Comma-separated list of tags to filter visible price plans by. */
      price_plan_tags_filter?: string | null;
    };
    UpdateCustomerPortalSettingsInputArgs: {
      price_plan_names_filter?: string;
      price_plan_tags_filter?: string;
      vendor_id?: number;
    };
    CustomerPortalTokenInputArgs: {
      customer_name?: string;
    };
    CustomerPortalToken: {
      token?: string;
    };
    CustomerPortalUrl: {
      url?: string;
    };
    CustomerPortalVendor: {
      /** Display name for the Vendor */
      display_name?: string;
      /** Unique name identifier of a Vendor */
      name?: string;
      /** Full contact info for the Vendor */
      contact_info?: components['schemas']['ContactInfo'];
      /** Vendor's current payment gateway. */
      payment_gateway?: string;
      /** Currency preference of the Vendor. */
      currency?: string;
    };
    CustomerPortalInvoiceStatus: {
      error?: string;
      /** The current upcoming action associated with this invoice status, if any. */
      action?: string;
      /** The timestamp that the action will be performed at. */
      pending_action_time?: string;
      /** Creation time of this invoice status. */
      created_at?: string;
      /** The current processing state for this invoice. */
      status?: string;
      /** Time the invoice status was last updated. */
      updated_at?: string;
      update_source?: string;
    };
    CustomerPortalInvoice: {
      due_date?: string;
      /** [DEPRECATED] Start time of the cycle in which the invoice was generated */
      start_time?: string;
      /** The date the invoice will be issued to the end customer or forwarded to the payment processor. */
      issue_date?: string;
      /** Tax amount applied to subtotal */
      tax_amount?: number;
      /** Earliest start time of line items covered by the invoice */
      min_item_start_time?: string;
      id?: string;
      /** False if not paid yet */
      is_paid?: boolean;
      /** [DEPRECATED] End time of the cycle in which the invoice was generated */
      end_time?: string;
      /** Latest end time of line items covered by the invoice */
      max_item_end_time?: string;
      /** Total amount due */
      amount_due?: number;
      /** Url pointing to the pdf of this invoice. */
      pdf_url?: string;
      /** Information related to the current status of this invoice. */
      status?: components['schemas']['CustomerPortalInvoiceStatus'];
      /** Amount due before any credits are applied */
      sub_total?: number;
      line_items?: components['schemas']['LineItems'][];
      /** Any discount credits applied to the invoice */
      discount_credit?: number;
    };
    CustomerPortalActiveSubscription: {
      /** The total fixed price the customer will be charged for this billing cycle. Includes the base price and any add ons. */
      total_fixed_price?: number;
      /** The total fixed price with all discounts applied. */
      discounted_fixed_price?: number;
      /** Customer's current active biling cycle. */
      billing_cycle: components['schemas']['BillingCycleDate'];
      /** Customer's current active subscription. Includes the price plan and overrides they are subscribed to. */
      subscription?: components['schemas']['Subscription'];
      /** The date that the customer will be invoiced for their current billing cycle. */
      invoicing_date?: string;
    };
    CustomerPortalActiveSubscriptionInputArgs: {
      add_ons?: components['schemas']['SubscriptionAddOnInput'][] | null;
      price_plan_uuid?: string;
    };
    CustomerPortalSubscription: {
      price_plan?: components['schemas']['PricePlan'];
    };
    CustomerPortalSubscriptionInputArgs: {
      price_plan_name?: string;
    };
    CustomerPortalStripeCredential: {
      account_id?: string;
      client_secret?: string;
      publishable_key?: string;
    };
    DailyUsage: {
      /** Start of the 24 hour time window in UTC. */
      time?: string;
      /** Total usage during this window. */
      usage?: number;
    };
    CycleUsage: {
      /** The end of the billing cycle in UTC. */
      cycle_end?: string;
      /** The start of the billing cycle in UTC. */
      cycle_start?: string;
      usage_by_time?: components['schemas']['DailyUsage'][];
      /** Total usage in the cycle. */
      total_usage?: number;
    };
    CustomerPortalUsage: {
      /** Daily usage across the current billing cycle. */
      current_cycle_usage?: components['schemas']['CycleUsage'];
      /** Name of the unit the meter uses. */
      unit_name?: string;
      /** Type of the meter. E.g. COUNTER or GAUGE. */
      meter_type?: string;
      /** Daily usage across the previous billing cycle. */
      previous_cycle_usage?: components['schemas']['CycleUsage'];
      /** Name of the meter. */
      meter_name?: string;
      /** Display name of the meter. */
      meter_display_name?: string;
    };
    CardInfo: {
      /** Month the card expires */
      exp_month?: number;
      /** Year the card expires */
      exp_year?: number;
      /** Brand of card. E.g. Amex, Visa, etc. */
      brand?: string;
      /** Last 4 digits of the card. */
      last4?: string;
      /** Country of the card */
      country?: string;
    };
    BankAccountInfo: {
      /** Name of the bank */
      bank_name?: string;
      /** Bank account type. E.g. Savings/Checking */
      account_type?: string;
      /** Last 4 digits of the bank account number. */
      last4?: string;
      /** Country the bank account is in. */
      country?: string;
      /** Routing number for the bank accopunt */
      routing_number?: number;
    };
    CustomerPortalPaymentMethod: {
      /** Info about the customer's card, if that is their payment method. */
      card_info?: components['schemas']['CardInfo'];
      /** Info about the customer's US bank account, if that is their payment method. */
      bank_account_info?: components['schemas']['BankAccountInfo'];
      /** Type of payment method for the customer. */
      payment_method_type?: string;
    };
    SelfServeSettings: {
      /** True if the customer can purchase credits via self serve. Defaults to False. */
      purchase_credits?: boolean;
      /** True if the customer can switch their current price plan via self serve. Defaults to False. */
      switch_price_plans?: boolean;
    };
    Webhook: {
      /** The url to send the webhooks to. */
      url: string;
      /** Unique string identifier representing this webhook configuration. */
      uuid?: string;
      /** Determines whether Octane will sign the outgoing webhook */
      enable_signature: boolean;
    };
    CreateWebhookArgs: {
      enable_signature?: boolean;
      url?: string;
    };
    ListCreditGrantsArgs: {
      sort_direction?: string;
      /** Customer to filter the results to */
      customer_name?: string;
      /** The unique offset to start at when paging forwards */
      forward_secondary_sort_offset?: string;
      /** The number of items to fetch. Defaults to 10. */
      limit?: number;
      sort_column?: string;
      /** The sort column offset to start at when paging forwards */
      forward_sort_offset?: string;
    };
    CreditGrant: {
      /** The date at which this grant expires */
      expires_at?: string;
      /** Name of the customer who received the grant */
      customer_name?: string;
      /** The source of the grant. */
      source?: string;
      /** Total price paid for the credits, in cents */
      price?: number;
      /** The date at which this grant is effective */
      effective_at?: string;
      /** A unique identifier for this grant */
      uuid?: string;
      /** Optional description. This is only viewable internally */
      description?: string;
      /** Number of credits granted */
      amount?: number;
    };
    ListCreditGrants: {
      sort_direction?: string;
      /** The unique offset to start at when paging forwards */
      forward_secondary_sort_offset?: string;
      /** The number of items to fetch. Defaults to 10. */
      limit?: number;
      credit_grants?: components['schemas']['CreditGrant'][];
      sort_column?: string;
      /** The sort column offset to start at when paging forwards */
      forward_sort_offset?: string;
    };
    CreateCreditGrantArgs: {
      /** The date at which this grant expires */
      expires_at?: string;
      /** Name of the customer receving the grant */
      customer_name: string;
      /** Total price paid for the credits in cents. Defaults to $1 (100 cents) per credit if not specified */
      price?: number;
      /** The date at which the grant is effective */
      effective_at?: string;
      /** Optional description. This is only viewable internally */
      description?: string;
      /** Number of credits to grant */
      amount: number;
    };
    CreditLedger: {
      /** The change in numer of credits */
      amount?: number;
      pending?: boolean;
      /** Credit balance as of this change */
      balance?: number;
      /** The time at which this credit balance change occurred. */
      timestamp?: string;
    };
    CreateRetryArgs: { [key: string]: unknown };
    Retry: {
      success?: boolean;
    };
    RollApiKeyArgs: {
      /** The date at which this API key will expire. Will default to 7 days. */
      expires_at?: string;
      /** The API key you want to roll. */
      api_key: string;
    };
    RollApiKeys: {
      success?: boolean;
      /** The newly generated API Key. */
      api_key?: string;
    };
    UpdateSelfServeSettingsArgs: {
      /** True if the customer can purchase credits via self serve. Defaults to False. */
      purchase_credits?: boolean;
      /** True if the customer can switch their current price plan via self serve. Defaults to False. */
      switch_price_plans?: boolean;
    };
  };
  responses: {
    /** Default error response */
    DEFAULT_ERROR: {
      content: {
        'application/json': components['schemas']['Error'];
      };
    };
    /** Unprocessable Entity */
    UNPROCESSABLE_ENTITY: {
      content: {
        'application/json': components['schemas']['Error'];
      };
    };
  };
}

export interface operations {}

export interface external {}
